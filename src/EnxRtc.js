var EnxRtc =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 32);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Common_config__);
/* global console */
//const moment = require('moment');
const dayjs = __webpack_require__(33);

/*
 * API to write logs based on traditional logging mechanisms: debug, trace, info, warning, error
 */

const Logger = (() => {
    const DEBUG = 0;
    const TRACE = 1;
    const INFO = 2;
    const WARNING = 3;
    const ERROR = 4;
    const NONE = 5;
    var logLevel =  NONE;
    let logPrefix = `${dayjs().format('YYMMDDHHmmss')}::` ;
    let outputFunction;
    const setLogIE = () => {
        if (!window.console) {
            const console = {
                log() { },
                warn() { },
                error() { },
                time() { },
                timeEnd() { },
            };
        }
    };
    setLogIE();
    // It sets the new log level. We can set it to NONE if we do not want to print logs
    const setLogLevel = (level) => {
        console.log ("setting log level:  old: " + Logger.logLevel + " new: " + level);
        if (typeof level === "string" || typeof level === "number") {
            let targetLevel = level;
            if (typeof targetLevel === "number") {
                targetLevel = Math.round(level);
                if (targetLevel <= Logger.NONE && targetLevel >= Logger.DEBUG) Logger.logLevel = targetLevel;
            }
            else {
                var arr = ["DEBUG", "TRACE", "INFO", "WARNING", "ERROR", "NONE"]
                if (arr.indexOf(targetLevel) > -1) {
                    Logger.logLevel = targetLevel;
                }
                else {
                    Logger.error('setLogLevel() invalid param');
                }
            }
            if (Logger.logLevel > Logger.INFO) Logger.logLevel = Logger.INFO;
        }
        else {
            Logger.error('setLogLevel() invalid param type');
        }
    };

    const getLogLevel = (level) => {
        return Logger.logLevel;
    };

    outputFunction = (args) => {
        // eslint-disable-next-line no-console
        console.log(...args);
    };

    const setOutputFunction = (newOutputFunction) => {
        outputFunction = newOutputFunction;
    };

    const setLogPrefix = (newLogPrefix) => {
        logPrefix = newLogPrefix;
    };
    const setLogCache = (keyValue, arg) => {

        if (__WEBPACK_IMPORTED_MODULE_0__Common_config___default.a.getLocalStorageItem('vcxRTCLib-log') != null) {
            const logData = JSON.parse(__WEBPACK_IMPORTED_MODULE_0__Common_config___default.a.getLocalStorageItem('vcxRTCLib-log'));

            const length = Object.keys(logData).length;
            if (length > 500) {
                delete (Object.keys(logData)[0]);
            }
            let logString = '';
            for (const i in arg) {
                if (typeof arg[i] === 'object') {
                    logString += JSON.stringify(arg[i], null, 2);
                } else {
                    logString += arg[i];
                }
            }
            logData[keyValue] = logString;
            __WEBPACK_IMPORTED_MODULE_0__Common_config___default.a.removeLocalStorageItem ('vcxRTCLib-log');
            __WEBPACK_IMPORTED_MODULE_0__Common_config___default.a.setLocalStorageItem('vcxRTCLib-log', JSON.stringify(logData, null, 2));
        }
    };
    // Generic function to print logs for a given level:
    //  Logger.[DEBUG, TRACE, INFO, WARNING, ERROR]
    const log = (level, ...args) => {
        let out = dayjs().format('YYMMDDHHmmssSSS') + ":";
        if (level < Logger.logLevel) {
            return;
        }
        switch(level){
        case Logger.DEBUG:
          out += 'D';
        break;
        case Logger.TRACE:
          out += 'T';
        break;
        case Logger.INFO:
          out += 'I';
        break;
        case Logger.WARNING:
          out += 'W';
        break;
        case Logger.ERROR:
          out += 'E';
        break;
        }
        out += "::"
        const logDetails = __WEBPACK_IMPORTED_MODULE_0__Common_config___default.a.getLocalStorageItem('logID');
        out += logDetails != null ? logDetails : '';
        const tempArgs = [out].concat(args);
        setLogCache(out, args);
        if (Logger.panel !== undefined) {
            let tmp = '';
            for (let idx = 0; idx < tempArgs.length; idx += 1) {
                tmp += tempArgs[idx];
            }
            Logger.panel.value = `${Logger.panel.value}\n${tmp}`;
        } else {
            outputFunction.apply(Logger, [tempArgs]);
        }
    };

    const debug = (...args) => {
        Logger.log(Logger.DEBUG, ...args);
    };

    const trace = (...args) => {
        Logger.log(Logger.TRACE, ...args);
    };

    const info = (...args) => {
        Logger.log(Logger.INFO, ...args);
    };

    const warning = (...args) => {
        Logger.log(Logger.WARNING, ...args);
    };

    const error = (...args) => {
        Logger.log(Logger.ERROR, ...args);
    };

    return {
        DEBUG,
        TRACE,
        INFO,
        WARNING,
        ERROR,
        NONE,
        setLogLevel,
        getLogLevel,
        setOutputFunction,
        setLogPrefix,
        log,
        debug,
        trace,
        info,
        warning,
        error,
    };
})();

Logger.logLevel  = Logger.INFO;
/* harmony default export */ __webpack_exports__["default"] = (Logger);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

//enablex
const path = __webpack_require__(34);

const that = {};

const getBrowserInfo = () => {
  let version = 'none';
  let name;
  let verOffset;
  const userAgent = window.navigator.userAgent;

  if ((verOffset = userAgent.indexOf('OPR')) != -1) {
    name = 'opera';
  } else if ((verOffset = userAgent.indexOf('Firefox')) != -1) {
    name = 'mozilla';
  } else if ((verOffset = userAgent.indexOf('Edg')) != -1) {
    name = 'edge';
  } else if ((verOffset = userAgent.indexOf('Chrome')) != -1) {
    name = 'chrome-stable';
  } else if ((verOffset = userAgent.indexOf('Safari')) != -1) {
    name = 'safari';
    if ((verOffset = userAgent.indexOf('Version')) != -1) {
      version = userAgent.substring(verOffset + 8);
    }
  } else if (((verOffset = userAgent.indexOf('MSIE')) != -1) || ((verOffset = userAgent.indexOf('Windows NT')) != -1)) {
    name = 'IE';
  } else {
    if ((userAgent.includes('iPhone') || userAgent.includes('iPad')) &&  userAgent.includes('Mobile') &&
        ((verOffset = userAgent.indexOf('OS'))  != -1)){
      const verStr = userAgent.substring(verOffset + 3);
      if (verStr) version = verStr.substring(0,verStr.indexOf(" "));
      if (version) {
        // its IOS webkit browser, set name as safari and version from OS ver
        version.replace(/_/g, ".");
        name = 'safari';
      }else {
        name = 'none'; verOffset =-1;
      }
    }else{
      name = 'none';
    }
  }

  if (version == 'none' && verOffset != -1) {
    const verStr = userAgent.substring(verOffset);
    if ((verOffset = verStr.indexOf('/')) != -1) {
      version = verStr.substring(verOffset + 1);
    }
  }

  let tempVersion;
  if ((tempVersion = version.indexOf(';')) != -1) {
    version = version.substring(0, tempVersion);
  }
  if ((tempVersion = version.indexOf(' ')) != -1) {
    version = version.substring(0, tempVersion);
  }
  const type = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(userAgent) ?
    'mobile' : 'desktop';
  return {
    name,
    version,
    device_type: type,
  };
};


that.socketCustomPathSupported = true;
that.socketCustomPath = '/v3/socket.io/';
const get_socketiopath= () => {
  if(that.socketCustomPathSupported) {
    if(that.socketCustomPath != undefined) return that.socketCustomPath;
    else return '/v3/socket.io/'
  } else {
    return undefined;
  }
};

that.socketiopath = get_socketiopath();

that.browser_info = getBrowserInfo();

that.is_supported = !!(((RTCPeerConnection !== undefined) && (/chrome-stable|mozilla|safari|opera|edge/i.test(that.browser_info.name))));

that.browser_type = (window.navigator.userAgent.match('Chrome') ? 'chrome-stable' :
  window.navigator.userAgent.match('Firefox') ? 'mozilla' :
    window.navigator.userAgent.match(/Safari|AppleWebKit/g) ? 'safari' :
      window.navigator.userAgent.match('Edge') ? 'edge' :
        window.navigator.userAgent.match('Electron') ? 'electron' :
          window.navigator.userAgent.match('.NET') ? 'IE' : 'none');

that.device_type =
  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i.test(window.navigator.userAgent) ?
    'mobile' : 'desktop';

that.videoBitrateQualityMap;

that.cameraResolutionTable;
const operationLocalStorage = (storage, opcode, key, value) => {
    let ret = key;
    switch(opcode){
    case 'get':
      ret = storage.getItem(key);
    break;
    case 'set':
      storage.setItem(key, value);
    break;
    case 'remove':
      storage.removeItem(key);
    break;
    }
    return ret;
}
const processLocalStorageItem = (opcode, key, value) =>{
  try{
    return operationLocalStorage(localStorage, opcode, key, value);
  }catch (e){
    if (e.SecurityError != undefined){
      try {
        return operationLocalStorage(sessionStorage,opcode, key, value);
      }catch (e) {
        return  null;
      }
    }
    return  null;
  }
}
module.exports = {
  product: {
    company: 'Vcloudx Inc', //Compny name
    product: 'enablex.io', //Product name
    version: '2.3.24', // version
    release: '2.3.24', //release

  },
  default_region: ['IN'],
  data_throughput_duration: 2, // in seconds
  video_bandwidth_duration: 10, // in seconds
  audio_bandwidth_duration: 10, // in seconds
  video_layer_bitrates: {
    0: 300000,
    1: 800000,
    2: 1500000,
  },
  video_resolution_range: {
    FD: { min: { width: 160, height: 90 }, max: { width: 1280, height: 720 } },
    HD: { min: { width: 320, height: 180 }, max: { width: 1280, height: 720 } },
    SD: { min: { width: 320, height: 180 }, max: { width: 960, height: 540 } },
    LD: { min: { width: 160, height: 90 }, max: { width: 640, height: 360 } },
    Default: {min: { width: 160, height: 90 }, max:{ width: 1280, height: 720 } }
  },
  video_bandwidth_range: {
    FD: { 0: { min: 100, max: 1200 }, 1: { min: 100, max: 800 }, 2: { min: 100, max: 400 } },
    HD: { 0: { min: 100, max: 1200 }, 1: { min: 100, max: 800 }, 2: { min: 100, max: 400 } },
    SD: { 0: { min: 100, max: 700 }, 1: { min: 100, max: 400 }, 2: { min: 100, max: 250 } },
    LD: { 0: { min: 80, max: 400 }, 1: { min: 80, max: 250 }, 2: { min: 80, max: 150 } },
    ND: { 0: { min: 0, max: 0 }, 1: { min: 40, max: 200 }, 2: { min: 40, max: 100 } },
    share: { min: 100, max: 400 },
    canvas: { min: 1024, max: 4096 },
  },

  screen_resolution_range: {
    FD: {bw:600, fps:20},
    HD: {bw:600, fps:20},
    SD: {bw:400, fps:15},
    LD: {bw:200, fps:10}
  },

  proxy_api_url: 'apiproxy.enablex.io',
  proxy_api_port: 443,
  ice_servers: {
    IN: {
          turnURI: 'turns:ts.enablex.io:443',
          turnUsername: 'vcxturn',
          turnCredential: 'V201301',
          stunURI: 'stun:stun.l.google.com:19302',
        },
    US: {
        turnURI: 'turns:eu2ts.enablex.io:443',
        turnUsername: 'vcxturn',
        turnCredential: 'V201301',
        stunURI: 'stun:stun.l.google.com:19302',
        },
    SG: {
        turnURI: 'turns:sgts.enablex.io:443',
        turnUsername: 'vcxturn',
        turnCredential: 'V201301',
        stunURI: 'stun:stun.l.google.com:19302',
        },
    DE: {
        turnURI: 'turns:gwcts.enablex.io:443',
        turnUsername: 'vcxturn',
        turnCredential: 'V201301',
        stunURI: 'stun:stun.l.google.com:19302',
        },
  },
  browser_info: that.browser_info,
  browser_type: that.browser_type,
  device_type: that.device_type,
  socketiopath: that.socketiopath,
  user_agent: window.navigator.userAgent,
  is_supported: () => that.is_supported,
  setVideoBwQualityMapper: (videoBitrateQualityMap) => {
    if (videoBitrateQualityMap.minBwKbpsToCheck) {
      that.videoBitrateQualityMap = videoBitrateQualityMap.bpsQualityMapTable.slice();
      that.cameraResolutionTable = videoBitrateQualityMap.camResTable.slice();
    }
    that.videoQualityMapMinBwKbps = videoBitrateQualityMap.minBwKbpsToCheck;
  },
  getBitrateMapTable: () => that.videoBitrateQualityMap,
  getCamResolutionTable: () => that.cameraResolutionTable,
  getCamResTableToCheck: (kbps) => {
    if (that.videoBitrateQualityMap !== undefined && (kbps <= that.videoQualityMapMinBwKbps)) {
      for (let i = 0; i < that.videoBitrateQualityMap.length; i++) {
        if (that.videoBitrateQualityMap[i].kbps <= kbps) {
          return {
            resTable: that.cameraResolutionTable.slice(that.videoBitrateQualityMap[i].resTable.index),
            fps: that.videoBitrateQualityMap[i].fps.max,
          };
        }
      }
    }
  },
  internetDetectionUrl: 'https://api.enablex.io/status',
  getLocalStorageItem: (key) => processLocalStorageItem('get',key),
  setLocalStorageItem: (key, value) => processLocalStorageItem('set', key, value),
  removeLocalStorageItem: (key) => processLocalStorageItem('remove', key),
  senduserDataMaximumLimit: 2048, // in kBs
  noise_analysis: true,
  noise_suppression_sdk_url: 'https://d1seim8g02n0k0.cloudfront.net/noise_suppression_sdk/EnxNs.js',
  csp_enabled: false,
  eventLogLevel: "error",
  getMediaConnectionTimeoutSecs: (isStreamingClient) => {return (isStreamingClient ? 5 : 30);},
  socketErrorTimeoutSecs: 5,
};


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Events__ = __webpack_require__(4);
/*
 * View class represents a HTML component
 * Every view is an EventDispatcher.
 */



const View = () => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["c" /* EventDispatcher */])({});

  // Variables

  // URL where it will look for icons and assets
  that.url = '';
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (View);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
This file is for handle DOM Element.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/

/* global document */


/*
 * Class Stream represents a HTML DOM Element. It will handle the element properties
 */
const Element = (spec) => {
    const that = {};

    that.name = spec.name;
    that.src = spec.src;
    that.srcObject = spec.srcObject;
    that.href = spec.href;
    that.rel = spec.rel;
    that.type = spec.type;
    that.target = spec.target;
    that.autoplay = spec.autoplay;
    that.playsinline = spec.playsinline;
    that.alt = spec.alt;
    that.title = spec.title;
    that.id = spec.id;
    that.class = spec.class;
    that.style = Element.getStyle(spec.style);
    that.object = null;

    if (that.name && that.name != '' && that.name != null) {
        that.object = document.createElement(that.name);

        if (that.src && that.src != '' && that.src != null) {
            that.object.setAttribute('src', that.src);
        }
        if (that.srcObject && that.srcObject != '' && that.srcObject != null) {
            that.object.setAttribute('srcObject', that.srcObject);
        }
        if (that.href && that.href != '' && that.href != null) {
            that.object.setAttribute('href', that.href);
        }
        if (that.target && that.target != '' && that.target != null) {
            that.object.setAttribute('target', that.target);
        }
        if (that.alt && that.alt != '' && that.alt != null) {
            that.object.setAttribute('alt', that.alt);
        }
        if (that.title && that.title != '' && that.title != null) {
            that.object.setAttribute('title', that.title);
        }
        if (that.rel && that.rel != '' && that.rel != null) {
            that.object.setAttribute('rel', that.rel);
        }
        if (that.type && that.type != '' && that.type != null) {
            that.object.setAttribute('type', that.type);
        }
        if (that.autoplay && that.autoplay != '' && that.autoplay != null) {
            that.object.setAttribute('autoplay', that.autoplay);
        }
        if (that.playsinline && that.playsinline != '' && that.playsinline != null) {
            that.object.setAttribute('playsinline', that.playsinline);
        }
        if (that.id && that.id != '' && that.id != null) {
            that.object.setAttribute('id', that.id);
        }
        if (that.class && that.class != '' && that.class != null) {
            that.object.setAttribute('class', that.class);
        }
        if (that.style && that.style != '' && that.style != null) {
            that.object.setAttribute('style', that.style);
        }
    }
    return that.object;
};

Element.getStyle = (styles) => {
    let style = '';
    for (const key in styles) {
        style += `${key}:${styles[key]};`;
    }
    return style;
};

Element.getById = (id) => {
    const elem = document.getElementById(id);
    return elem;
};

Element.getByClass = (className) => {
    const elem = document.getElementsByClassName(className)[0];
    return elem;
};

Element.getByTag = (tagName) => {
    const elem = document.getElementsByTagName(tagName)[0];
    return elem;
};

Element.getTagByDOM = (tagName, DOM) => {
    const elem = DOM.getElementsByTagName(tagName)[0];
    return elem;
};

Element.getByClass = (className, DOM) => {
    const elem = DOM.getElementsByClassName(className)[0];
    return elem;
};

Element.append = (childDOM, parentDOM) => {
    const elem = parentDOM.appendChild(childDOM);
    return elem;
};

Element.setStyle = (DOM, property, value) => {
    DOM.style[property] = value;
};

Element.addCssFile = (DOM) => {
    Element.getByTag('head').appendChild(DOM);
};

Element.checkParam = (elem) => {
    let ret = false;
    if (elem && (elem != null) && (elem != '')) { ret = true; }
    return ret;
};

/* harmony default export */ __webpack_exports__["a"] = (Element);


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return RoomEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return StreamEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return PublisherEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return UserEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ClientHealthEvent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Pair__ = __webpack_require__(7);
/*
This file is to store all events in a constant property variable.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 28/11/2017 04:13 PM
*/

/* global */
 // This package is for manage console log.


/*
 * Class EventDispatcher provides event handling to sub-classes.
 * It is inherited from Publisher, Room, etc.
 */
const EventDispatcher = () => {
    const that = {};
    // Private vars
    const dispatcher = {
        eventListeners: {},
    };

    // Public functions

    // It adds an event listener attached to an event type.
    that.addEventListener = (eventType, listener) => {
        if (dispatcher.eventListeners[eventType] === undefined) {
            dispatcher.eventListeners[eventType] = [];
        }
        dispatcher.eventListeners[eventType].push(listener);
    };

    // It removes an available event listener.
    that.removeEventListener = (eventType, listener) => {
        if (!dispatcher.eventListeners[eventType]) {
            return;
        }
        const index = dispatcher.eventListeners[eventType].indexOf(listener);
        if (index !== -1) {
            dispatcher.eventListeners[eventType].splice(index, 1);
        }
    };

    // It dispatch a new event to the event listeners, based on the type
    // of event. All events are intended to be Events.
    if (__WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].browserEngineCheck() !== 'IE') {
        that.dispatchEvent = (event) => {
            if (!event || !event.type) { // Checking : If EventDispatcher is called with wrong event object or not
                throw new Error('Undefined event');
            }
            if (event.type != 'onStatSubscription' && event.type != 'genericEvents' &&
                event.type != 'talker-notification') {
                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug(`Event: ${event.type}`);
            }
            const listeners = dispatcher.eventListeners[event.type] || [];
            for (let i = 0; i < listeners.length; i += 1) {
                listeners[i](event);
            }
        };
    } else {
        function CustomEvent(event, params) {
            params = params || { bubbles: false, cancelable: false, detail: undefined };
            const evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            evt.data = params.detail;
            return evt;
        }
        CustomEvent.prototype = window.Event.prototype;
        window.CustomEvent = CustomEvent;
        that.dispatchEvent = (event) => {
            if (event.type != 'onStatSubscription' && event.type != 'genericEvents' &&
               event.type != 'talker-notification') {
                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug(`Event: ${event.type}`);
            }
            const evt = CustomEvent(event.type, { bubbles: false, cancelable: false, detail: event });
            const plugin = document.getElementById('WebrtcEverywherePluginId');
            plugin.dispatchEvent(evt);
        };
    }
    /*
    coping a function defination to another variable to use
    */
    that.on = that.addEventListener;
    that.off = that.removeEventListener;
    that.emit = that.dispatchEvent;
    that.eventsList = dispatcher.eventListeners;

    return that;
};

// **** EVENTS ****

/*
 * Class Event represents a generic Event in the library.
 * It handles the type of event, that is important when adding
 * event listeners to EventDispatchers and dispatching new events.
 * A Event can be initialized this way:
 * var event = Event({type: "room-connected"});
 */
const Event = (spec) => {
    const that = {};

    // Event type. Examples are: 'room-connected', 'stream-added', etc.
    that.type = spec.type;

    return that;
};

/*
 * Class RoomEvent represents an Event that happens in a Room. It is a
 * Event.
 * It is usually initialized as:
 * var roomEvent = RoomEvent({type:"room-connected", streams:[stream1, stream2]});
 * Event types:
 * 'room-connected' - points out that the user has been successfully connected to the room.
 * 'room-disconnected' - shows that the user has been already disconnected.
 */
const RoomEvent = (spec) => {
    const that = Event(spec);

    // A list with the streams that are published in the room.
    that.streams = spec.streams;
    that.message = spec.message;
    that.room = spec.room;
    that.users = spec.users;
    that.type = spec.type;
    that.bandwidth = spec.bandwidth;
    that.TalkerCount = spec.TalkerCount;
    that.me = spec.me;
    that.mediaRecord = spec.mediaRecord;
    that.error = spec.error;
    return that;
};

/*
 * Class StreamEvent represents an event related to a stream. It is a Event.
 * It is usually initialized this way:
 * var streamEvent = StreamEvent({type:"stream-added", stream:stream1});
 * Event types:
 * 'stream-added' - indicates that there is a new stream available in the room.
 * 'stream-removed' - shows that a previous available stream has been removed from the room.
 */
const StreamEvent = (spec) => {
    const that = Event(spec);

    // The stream related to this event.
    that.stream = spec.stream;

    that.msg = spec.msg;
    that.bandwidth = spec.bandwidth;
    that.attrs = spec.attrs;

    return that;
};

/*
 * Class PublisherEvent represents an event related to a publisher. It is a Event.
 * It usually initializes as:
 * var publisherEvent = PublisherEvent({})
 * Event types:
 * 'media-access-allowed' - indicates that the user has accepted to share his camera and microphone
 */
const PublisherEvent = (spec) => {
    const that = Event(spec);

    return that;
};

const UserEvent = (spec) => {
    const that = Event(spec);
    that.name = spec.name;
    that.role = spec.role;
    that.clientId = spec.clientId;
    that.permissions = spec.permission;
    if(spec.user_ref != undefined) that.user_ref = spec.user_ref;
    if(spec.data != undefined) that.data = spec.data;
    return that;
};

/*
 * Class ClientHealthEvent represents an event related to a client diagnostics.
 * It is an Event.
 * Event types:
 * 'client-diagnosis-finished' - indicates that diagnosis is compeleted
 * 'client-diagnosis-failed' - indicates that diagnosis is failed due to some error
 * 'client-diagnosis-status' - returns the status of the various test cases while execution
 * 'client-diagnosis-stopped' - indicates that the analysis is stopped deliberately
 */
const ClientHealthEvent = (spec) => {
    const that = Event(spec);
    that.message = spec.message;
    return that;
};
/*const PublishStream = (spec) => {

  const that = Event(spec);
  return that;
};*/
/*export { EventDispatcher, Event, RoomEvent, StreamEvent, PublisherEvent,PublishStream };*/



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
This file is to store all events in a constant property variable.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 27/11/2017 05:14 PM
*/

const VcxEventProperties = {};
VcxEventProperties.SocketEvent = {};
VcxEventProperties.RoomEvent = {};
VcxEventProperties.UserEvent = {};
VcxEventProperties.StreamEvent = {};

VcxEventProperties.SocketEvent.onAddStream = 'onAddStream';
VcxEventProperties.SocketEvent.onRemoveTrack = 'onRemoveTrack';
VcxEventProperties.SocketEvent.media_engine_connecting = 'media_engine_connecting';
VcxEventProperties.SocketEvent.signaling_message_peer = 'signaling_message_peer';
VcxEventProperties.SocketEvent.publish_me = 'publish_me';
VcxEventProperties.SocketEvent.unpublish_me = 'unpublish_me';
VcxEventProperties.SocketEvent.onBandwidthAlert = 'onBandwidthAlert';
VcxEventProperties.SocketEvent.onBandwidthEvents = 'bandwidthEvents';
VcxEventProperties.SocketEvent.onSelfBandwidthAlert = 'onSelfBandwidthAlert';
VcxEventProperties.SocketEvent.onDataStream = 'onDataStream';
VcxEventProperties.SocketEvent.onUpdateAttributeStream = 'onUpdateAttributeStream';
VcxEventProperties.SocketEvent.onRemoveStream = 'onRemoveStream';
VcxEventProperties.SocketEvent.disconnect = 'disconnect';
VcxEventProperties.SocketEvent.connection_failed = 'connection_failed';
VcxEventProperties.SocketEvent.error = 'error';
VcxEventProperties.SocketEvent.connect_error = 'connect_error';
VcxEventProperties.SocketEvent.connect_timeout = 'connect_timeout';
VcxEventProperties.SocketEvent.reconnecting = 'reconnecting';
VcxEventProperties.SocketEvent.reconnect = 'reconnect';
VcxEventProperties.SocketEvent.reconnected = 'reconnected';
VcxEventProperties.SocketEvent.reconnect_attempt = 'reconnect_attempt';
VcxEventProperties.SocketEvent.reconnect_error = 'reconnect_error';
VcxEventProperties.SocketEvent.reconnect_failed = 'reconnect_failed';
VcxEventProperties.SocketEvent.user_connected = 'user-connected';
VcxEventProperties.SocketEvent.user_updated = 'user-updated';
VcxEventProperties.SocketEvent.user_disconnected = 'user-disconnected';
VcxEventProperties.SocketEvent.user_subscribed = 'user-subscribed';
VcxEventProperties.SocketEvent.user_unsubscribed = 'user-unsubscribed';
VcxEventProperties.SocketEvent.dial_state_events = 'dialStateEvents';
VcxEventProperties.RoomEvent.user_role_changed = 'userRoleChanged';
// manu stats
VcxEventProperties.SocketEvent.onStatSubscription = 'onStatSubscription';
VcxEventProperties.SocketEvent.onStreamingNotification = 'onStreamingNotification';
VcxEventProperties.SocketEvent.onHlsStreamingNotification = 'onHlsStreamingNotification';
VcxEventProperties.SocketEvent.onHlsStreamingNotificationToPublisher = 'onHlsStreamingNotificationToPublisher';
VcxEventProperties.SocketEvent.onLiveRecordingNotification = 'onLiveRecordingNotification';
VcxEventProperties.SocketEvent.onRoomLiveRecordingOn = 'room-live-recording-on';
VcxEventProperties.SocketEvent.onRoomLiveRecordingOff = 'room-live-recording-off';
VcxEventProperties.SocketEvent.onRoomLiveRecordingFailed = 'room-live-recording-failed';
// end manu stats
VcxEventProperties.SocketEvent.data_stream_room = 'onDataStreamToRoom';
VcxEventProperties.RoomEvent.onStreamingNotification = 'onStreamingNotification';
VcxEventProperties.RoomEvent.onHlsStreamingNotification = 'onHlsStreamingNotification';
VcxEventProperties.RoomEvent.onHlsStreamingNotificationToPublisher = 'onHlsStreamingNotificationToPublisher';
VcxEventProperties.RoomEvent.onLiveRecordingNotification = 'onLiveRecordingNotification';

VcxEventProperties.UserEvent.user_awaited = 'user-awaited';
VcxEventProperties.UserEvent.user_joined = 'user-joined';

VcxEventProperties.RoomEvent.room_connected = 'room-connected';
VcxEventProperties.RoomEvent.room_disconnected = 'room-disconnected';
VcxEventProperties.RoomEvent.room_awaited = 'room-awaited';
VcxEventProperties.RoomEvent.room_record_on = 'room-record-on';
VcxEventProperties.RoomEvent.room_record_off = 'room-record-off';
VcxEventProperties.RoomEvent.onRoomLiveRecordingOn = 'room-live-recording-on';
VcxEventProperties.RoomEvent.onRoomLiveRecordingOff = 'room-live-recording-off';
VcxEventProperties.RoomEvent.onRoomLiveRecordingFailed = 'room-live-recording-failed';
VcxEventProperties.RoomEvent.update_layout = 'update-layout';
VcxEventProperties.RoomEvent.change_layout = 'change-layout';
VcxEventProperties.RoomEvent.new_active_talker = 'active-talkers-updated';
VcxEventProperties.RoomEvent.hard_mute_audio = 'hardmute-user-audio';
VcxEventProperties.RoomEvent.hard_unmute_audio = 'hardunmute-user-audio';
VcxEventProperties.RoomEvent.hard_mute_video = 'hardmute-user-video';
VcxEventProperties.RoomEvent.hard_unmute_video = 'hardunmute-user-video';
VcxEventProperties.RoomEvent.get_active_talker = 'getNumberOfTalker';
VcxEventProperties.RoomEvent.set_active_talker = 'setNumberOfTalker';
VcxEventProperties.RoomEvent.get_active_max_talker = 'getMaxNumberOfTalker';
VcxEventProperties.RoomEvent.set_adavanced_options = 'setAdvancedOptions';
VcxEventProperties.RoomEvent.get_adavanced_options = 'getAdvancedOptions';
VcxEventProperties.RoomEvent.client_stats = 'clientStats';
VcxEventProperties.RoomEvent.switch_user_role = 'switchUserRole';
VcxEventProperties.RoomEvent.hard_unmute_video = 'hardunmute-user-video';
VcxEventProperties.RoomEvent.auxilary_publish_events = 'auxilaryPublishEvents';
VcxEventProperties.RoomEvent.share_started = 'shareStarted';
VcxEventProperties.RoomEvent.share_stopped = 'shareStopped';
VcxEventProperties.RoomEvent.screen_share_override = 'shareOverride';
VcxEventProperties.RoomEvent.streaming_uri = 'streamingUri';

VcxEventProperties.RoomEvent.stop_sharing = 'stopSharing';
VcxEventProperties.RoomEvent.share_state_events = 'shareStateEvents';
VcxEventProperties.RoomEvent.extend_conference_duration = 'extendConferenceDuration';
VcxEventProperties.RoomEvent.lock_room = 'lockRoom';
VcxEventProperties.RoomEvent.drop = 'drop';
VcxEventProperties.RoomEvent.subscriber_video_mute = 'subscriber-video-mute';
VcxEventProperties.RoomEvent.switch_codec = 'switch-publish-media-codec';
VcxEventProperties.RoomEvent.canvas_started = 'canvasStarted';
VcxEventProperties.RoomEvent.canvas_stopped = 'canvasStopped';
VcxEventProperties.RoomEvent.canvas_state_events = 'canvasStateEvents';
VcxEventProperties.RoomEvent.custom_data_saved = 'CustomDataSaved';
VcxEventProperties.RoomEvent.custom_data_updated = 'CustomDataUpdated';
VcxEventProperties.RoomEvent.transcription_events = 'transcription-events';
VcxEventProperties.RoomEvent.analytics_events = 'meeting-summary-events';
VcxEventProperties.RoomEvent.meeting_summary_subscription_events = 'meeting-summary-subscription';

//breakout room events
VcxEventProperties.RoomEvent.invite_breakout_room = 'invite-breakout-room';
VcxEventProperties.RoomEvent.user_joined_breakout_room = 'user-joined-breakout-room';
VcxEventProperties.RoomEvent.user_left_breakout_room = 'breakout-user-disconnected';
VcxEventProperties.RoomEvent.breakout_room_destroyed = 'breakout-room-destroyed';

VcxEventProperties.RoomEvent.generic_events = 'genericEvents';
VcxEventProperties.RoomEvent.network_reconnected = 'network-reconnected';
VcxEventProperties.RoomEvent.network_disconnected = 'network-disconnected';
VcxEventProperties.RoomEvent.network_reconnectiontimeout = 'network-reconnect-timeout';
VcxEventProperties.RoomEvent.network_reconnectfailed = 'network-reconnect-failed';
// file sharing room level events
// to do remove unused file sharing events
VcxEventProperties.RoomEvent.fs_upload_started = 'fs-upload-started';
VcxEventProperties.RoomEvent.fs_file_uploaded = 'fs-file-uploaded';
VcxEventProperties.RoomEvent.fs_file_uploaded = 'fs-file-available';
VcxEventProperties.RoomEvent.fs_download_started = 'fs-download-started';
VcxEventProperties.RoomEvent.fs_file_downloaded = 'fs-file-downloaded';
VcxEventProperties.RoomEvent.fs_file_downloaded = 'fs-upload-success';
VcxEventProperties.RoomEvent.fs_file_upload_result = 'fs-upload-result';
VcxEventProperties.RoomEvent.fs_file_download_result = 'fs-download-result';


VcxEventProperties.SocketEvent.floor_management_events = 'floorManagementEvents';
VcxEventProperties.SocketEvent.room_management_events = 'roomManagementEvents';
VcxEventProperties.UserEvent.user_audio_muted = 'user-audio-muted';
VcxEventProperties.UserEvent.user_audio_unmuted = 'user-audio-unmuted';
VcxEventProperties.UserEvent.user_video_muted = 'user-video-muted';
VcxEventProperties.UserEvent.user_video_unmuted = 'user-video-unmuted';

VcxEventProperties.SocketEvent.hard_mute = 'hardMute';
VcxEventProperties.SocketEvent.hard_mute_room = 'room-muted';
VcxEventProperties.SocketEvent.hard_unmute_room = 'room-unmuted';


VcxEventProperties.SocketEvent.switched_room = 'roomSwitched';
VcxEventProperties.RoomEvent.room_transcription_on = 'room-transcription-on';
VcxEventProperties.RoomEvent.room_transcription_off = 'room-transcription-off';
VcxEventProperties.RoomEvent.self_transcription_on = 'self-transcription-on';
VcxEventProperties.RoomEvent.self_transcription_off = 'self-transcription-off';

VcxEventProperties.constant = {};
VcxEventProperties.constant.H264_CODEC = 'H264_AND_OPUS';
VcxEventProperties.constant.default = 'default';

VcxEventProperties.constant.SAFARI_VERSION_NOT_SUPPORTING_VP8 = '12.0';
VcxEventProperties.constant.SAFARI_VERSION_SUPPORTING_VP8 = '12.1';
VcxEventProperties.constant.FIREFOX_VERSION_VIDEO_MUTE_SUPPORT = '60.0';
VcxEventProperties.constant.CHROME_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT = '72.0';
VcxEventProperties.constant.FIREFOX_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT = '66.0';
VcxEventProperties.constant.SAFARI_VERSION_SCREEN_SHARE_SUPPORT = '13.0.0';
VcxEventProperties.constant.FIREFOX_VERSION_SENDER_ENCODINGS_PARAM_SUPPORT = '64.0';
VcxEventProperties.constant.SAFARI_VERSION_SENDER_ENCODINGS_PARAM_SUPPORT = '13.1.0';
VcxEventProperties.constant.SAFARI_VERSION_DEVICE_CHANGE_EVENT_SUPPORT = '11.0.0';

/* harmony default export */ __webpack_exports__["a"] = (VcxEventProperties);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const customErrors = {
    error_000: {
        result: 0,
        msg: 'success'
    },
    error_1000: {
        result: 1000,
        msg: 'Non supported browser',
    },
    error_1130: {
        result: 1130,
        error: 'Moderator not present/ wait for Moderator',
        desc: '',
    },
    error_1140: {
        result: 1140,
        error: 'Previous similar request in process',
        desc: '',
    },
    error_1141: {
        result: 1141,
        error: "Remote streams can't be muted",
        desc: '',
    },
    error_1142: {
        result: 1142,
        error: 'Invalid Device Id',
        desc: 'OverconstrainedError: Invalid device id provided',
    },
    error_1143: {
        result: 1143,
        error: 'Requested device not found',
        desc: 'NotFoundError: Requested device was not found',
    },
    error_1144: {
        result: 1144,
        error: 'Permission denied',
        desc: 'NotAllowedError: The request is not allowed by the user agent or the platform in the current context',
    },
    error_1145: {
        result: 1145,
        error: 'Could not start video source',
        desc: 'NotReadableError: Could not start video source',
    },
    error_1146: {
        result: 1146,
        error: 'Failed to execute getUserMedia on MediaDevices',
        desc: 'TypeError: At least one of audio and video must be requested',
    },
    error_1147: {
        result: 1147,
        error: 'Constraints could be not satisfied',
        desc: 'OverconstrainedError: Video width constraint could not be satisfied',
    },
    error_1148: {
        result: 1148,
        error: 'Constraints could be not satisfied',
        desc: 'OverconstrainedError: Video height constraint could not be satisfied',
    },
    error_1149: {
        result: 1149,
        error: 'Constraints could be not satisfied',
        desc: 'One of the constraints (Height, Width, DeviceId) is not satisfied.',
    },
    error_1150: {
        result: 1150,
        error: 'Reason unknown',
        desc: 'Reason unknown',
    },
    error_1151: {
        result: 1151,
        error: 'A screen share is already running',
        desc: '',
    },
    error_1152: {
        result: 1152,
        error: 'Audio only calls are allowed with your current browser version',
        desc: '',
    },
    error_1153: {
        result: 1153,
        error: 'Unsupported browser',
        desc: '',
    },
    error_1154: {
        result: 1154,
        error: 'Given frame rate is not supported',
        desc: 'Frame rate might be negative or not a number which is not accepted by captureStream method',
    },
    error_1155: {
        result: 1155,
        error: 'Invalid options/parameters /values',
        desc: 'Invalid options parameters/values ',
    },
    error_1156: {
        result: 1156,
        error: 'Invalid streamType',
        desc: ' streamType  should be set as canvas for canvas streams and talker for talker streams',
    },
    error_1157: {
        result: 1157,
        error: 'The given canvas element does not exist in the DOM',
        desc: 'The canvas element you have provided does not exist in the DOM',
    },
    error_1158: {
        result: 1158,
        error: 'This browser does not support canvas',
        desc: 'This browser does not support canvas',
    },
    error_1159: {
        result: 1159,
        error: 'Stream not found',
        desc: 'Stream not found',
    },
    error_1160: {
        result: 1160,
        error: 'Media connection failure',
        desc: 'Media connection failure',
    },
    error_1161: {
        result: 1161,
        error: 'Server connection failure',
        desc: 'Server connection failure',
    },
    error_1162: {
        result: 1162,
        error: 'The DOM element does not exist',
        desc: 'The element with DOM reference provided does not exist',
    },
    error_1163: {
        result: 1163,
        error: 'Network disconnected',
        desc: 'Socket or media connection has failed due to network error',
    },
    error_1164: {
        result: 1164,
        error: 'Network reconnected',
        desc: 'Network reconnected',
    },
    error_1165: {
        result: 1165,
        error: 'Reconnect attempt exceeded',
        desc: 'Reconnection failed',
    },
    error_1166: {
        result: 1166,
        error: 'Reconnection timed out',
        desc: 'Reconnection failed',
    },
    error_1167: {
        result: 1167,
        error: 'Publish or subscribe failed',
        desc: 'After reconnection publish or subscibe failed',
    },
    error_1168: {
        result: 1168,
        error: 'Not allowed',
        desc: 'Only moderator has rights to excercise this transaction',
    },
    error_1169: {
        result: 1169,
        msg: 'No listener for event',
        desc: '',
    },
    error_1170: {
        result: 1170,
        error: 'Not supported',
        desc: 'Feature is not enabled because of room config or no licence ',
    },
    error_1171: {
        result: 1171,
        error: 'Room not connected',
        desc: 'Room not connected',
    },
    error_1172: {
        result: 1172,
        error: 'Room connect failed',
        desc: 'Room connect failed',
    },
    error_1173: {
        result: 1173,
        error: 'Floor not granted for participant',
        desc: 'Floor not granted',
    },
    error_1174: {
        result: 1174,
        error: 'Local Recording started already',
        desc: '',
    },
    error_1175: {
        result: 1175,
        error: 'Local Recording not started /stream not having media',
        desc: '',
    },
    error_1176: {
        result: 1176,
        error: 'Moderator declined right to control media devices ',
        desc: '',
    },
    error_1177: {
        result: 1177,
        error: 'MediaDevice state is already in same state',
        desc: '',
    },
    error_1178: {
        result: 1178,
        error: 'Reconnection for a single participant in the room is not allowed',
        desc: 'Reconnection not allowed',
    },
    error_1179: {
        result: 1179,
        error: ' files to upload input array size is 0',
        desc: ' empty file transfer is not allowed',
    },
    error_1180: {
        result: 1180,
        error: ' room is disconected',
        desc: ' file sharing is not allowed on disconnected rooms',
    },
    error_1181: {
        result: 1181,
        error: ' Recieve file operation is not permitted.',
        desc: ' File which you are trying to receive  does not exist.',
    },
    error_1182: {
        result: 1182,
        error: 'file upload failed',
        desc: 'file upload failed ',
    },
    error_1183: {
        result: 1183,
        error: ' file download failed ',
        desc: ' file download failed',
    },
    error_1184: {
        result: 1184,
        error: 'user video resolution inavlid range',
        desc: 'user video resolution inavlid range',
    },
    error_1185: {
        result: 1185,
        error: 'file upload failed ',
        desc: 'file upload failed because provided file list is empty',
    },
    error_1186: {
        result: 1186,
        error: 'file upload failed ',
        desc: 'file size is zero bytes',
    },
    error_1187: {
        result: 1187,
        error: 'file upload failed ',
        desc: 'file upload failed because it exceeded max upload limit',
    },
    error_1188: {
        result: 1188,
        error: 'current and requested state / value are same',
        desc: 'current and requested state / value are same',
    },
    error_1189: {
        result: 1189,
        error: 'Media operation not allowed in mute state',
        desc: '',
    },
    error_4121: {
        result: 4121,
        error: 'room already locked / unlocked',
        desc: ' room is already locked/unlocked',
    },
    error_7000: {
        result: 7000,
        error: 'streaming error',
        desc: ' streaming error',
    },
    error_7008: {
        result: 7008,
        error: 'streaming error',
        desc: 'only moderator can start streaming',
    },
    error_7009: {
        result: 7009,
        error: 'streaming error',
        desc: 'invalid or undefined streaming configuration',
    },
    error_7101: {
        result: 7101,
        error: 'streaming error',
        desc: 'rtmpUrl should not exceed more than 3 values',
    },
    error_7102: {
        result: 7102,
        error: 'streaming error',
        desc: 'invalid rtmp or url format',
    },
    error_7103: {
        result: 7103,
        error: 'streaming error',
        desc: 'room is disconnecting, cannot start streaming',
    },
    error_7044: {
        result: 7044,
        error: 'streaming error',
        desc: 'only moderator can stop streaming',
    },
    error_7045: {
        result: 7045,
        error: 'streaming error',
        desc: 'room is disconnecting, streaming will be stopped',
    },
    error_7072: {
        result: 7072,
        error: 'streaming params change error',
        desc: 'only moderator can change streaming params',
    },
    error_7078: {
        result: 7078,
        error: 'streaming params change error',
        desc: 'room is disconnecting, cannot change streaming params',
    },
    error_7201: {
        result: 7201,
        error: 'live recording error',
        desc: 'only moderator can start live recording',
    },
    error_7202: {
        result: 7202,
        error: 'live recording error',
        desc: 'invalid url format',
    },
    error_7203: {
        result: 7203,
        error: 'live recording error',
        desc: 'room is disconnecting, cannot start live recording',
    },
    error_7204: {
        result: 7204,
        error: 'live recording error',
        desc: 'live recording error',
    },
    error_7036: {
        result: 7036,
        error: 'live recording error',
        desc: 'only moderator can stop live recording',
    },
    error_7037: {
        result: 7037,
        error: 'live recording error',
        desc: 'room is disconnecting, live recording will be stopped',
    },
    error_7079: {
        result: 7079,
        error: 'room is disconected',
        desc: 'Layout update is not allowed on disconnected rooms',
    },
    error_7071: {
        result: 7071,
        error: 'live recording error',
        desc: 'only moderator can change live recording params',
    },
    error_8000: {
        result: 8000,
        error: 'invalidate transcoding error',
        desc: 'Room is disconnecting, invalidate transcoding cannot be performed now',
    },
    error_8001: {
        result: 8001,
        error: 'Live transcription is already in progress',
        desc: 'Live transcription is already in progress',
    },
    error_8002: {
        result: 8002,
        error: 'Live transcription is not running',
        desc: 'Live transcription is not started',
    },
    error_8003: {
        result: 8003,
        error: 'Live summary is already in progress',
        desc: 'Live summary is already in progress',
    },
    error_8004: {
        result: 8004,
        error: 'Live summary is not running',
        desc: 'Live summary is not started',
    },
    CC002: {
        cause: 2002,
        msg: 'unexpected-disconnection',
    },
    CC006: {
        cause: 2006,
        msg: 'normal-disconnect',
    },
    error_1190: {
      result: 1190,
      error: 'Exception found',
      desc: 'Could not fetch video size',
  },
    error_1191: {
      result: 1191,
      error: 'Stream track ended state ',
      desc: 'Stream track is already ended',
  },
  error_1192: {
    result: 1192,
    error: 'Invalid parameters',
    desc: 'Invalid value for layout parameter',
  },
  error_1193: {
    result: 1193,
    error: 'Invalid parameters',
    desc: 'Invalid value for service parameter',
  },
  error_1194: {
    result: 1194,
    error: 'Invalid parameters',
    desc: 'Invalid value for clients parameter',
  },
  error_1195: {
    result: 1195,
    error: 'Large text Data',
    desc: 'Failed to handle larger text-data',
  },
  error_1196: {
    result: 1196,
    error: 'content-length value exceeded.',
    desc: 'Entered value of content-length exceeded the maximum allowed value.',
  },
  error_1197: {
    result: 1197,
    error: 'stream Invalid state .',
    desc: 'room not published or already stream in published.',

  },
  error_1198: {
    result: 1198,
    error: 'failed to start noise suppression',
    desc: '',
  },
  error_1199: {
    result: 1199,
    error: 'failed to stop noise suppression',
    desc: '',
  },
  error_1200: {
    result: 1200,
    error: 'share initiation timeout',
    desc: '',
  },
};

/* harmony default export */ __webpack_exports__["a"] = (customErrors);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webrtc_stacks_FirefoxStack__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__webrtc_stacks_FcStack__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_ErrorHandler__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__customErrors__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__customEvents__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__EventLogger__ = __webpack_require__(9);
/*
*Author: Sohom
*Description: class to handale RTC connection related functionality
*              Like Brwoser compatibilty and borrowing it's appropriate stack,
*              calling getUserMedia feature,screen share extension conifiguration etc.
*Version: V 1.0
 */
/*
global import RTC stack Refewrence by including file from ./webrtc-stacks/* */











let VcxRtcSessionId = 103;
let getUserMediaDelayed;
let gotMediaPermission = false;
const that = {};
that.deviceList = undefined;
const browserEngineCheck = () => {
    let browser = 'none';

    if ((typeof module !== 'undefined' && module.exports)) {
        browser = 'fake';
    } else if (window.navigator.userAgent.match('Firefox') !== null) {
        // Firefox
        browser = 'mozilla';
    } else if (window.navigator.userAgent.match('Chrome') !== null) {
        browser = 'chrome-stable';
        if (window.navigator.userAgent.match('Electron') !== null) {
            browser = 'electron';
        } else if (window.navigator.userAgent.match('Edge') !== null) {
            browser = 'edge';
        }
    } else if (window.navigator.userAgent.match('Safari') !== null) {
        browser = 'safari';
    } else if (window.navigator.userAgent.match('AppleWebKit') !== null) {
        browser = 'safari';
    } else if (window.navigator.userAgent.match('.NET') !== null) {
        browser = 'IE';
    }
    return browser;
};


const getBrowserVersion = () => {
    const { userAgent } = navigator;
    let temp;
    let Match = userAgent.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (/trident/i.test(Match[1])) {
        temp = /\brv[ :]+(\d+)/g.exec(userAgent) || [];
        return `IE ${temp[1] || ''}`;
    }
    if (Match[1] === 'Chrome') {
        temp = userAgent.match(/\b(OPR|Edge)\/(\d+)/);
        if (temp != null) return temp.slice(1).join(' ').replace('OPR', 'Opera');
    }

    Match = Match[2] ? Match[2] : navigator.appVersion;
    if ((temp = userAgent.match(/version\/([^\s]+)/i)) != null) Match = temp[1];
    return Match;
};
const isCurrentVerLess = (verToCheck) => {
    const currVer = getBrowserVersion();
    if (typeof verToCheck !== 'string') return false;
    const v1 = currVer.split('.');
    const v2 = verToCheck.split('.');
    const k = Math.min(v1.length, v2.length);
    for (let i = 0; i < k; ++i) {
        v1[i] = parseInt(v1[i], 10);
        v2[i] = parseInt(v2[i], 10);
        if (v1[i] > v2[i]) return false;
        if (v1[i] < v2[i]) return true;
    }
    return v1.length == v2.length ? false : (!(v1.length < v2.length));
};
const processDevicesList = (deviceList, requestedDevices) => {
    const devices = { cam: [], mic: [], speaker: [] };
    const defaultDevs = {mic:{}, cam: {}, speaker: {}};

    const checkProcessDevice = (inputDev, devicesArray, defDevice) => {
      if (inputDev.deviceId.toLowerCase() == "default" && inputDev.label){
        defDevice.label = inputDev.label;
      }else if (inputDev.label && defDevice.label && defDevice.label.includes(inputDev.label)){
        let deviceInfo = JSON.parse(JSON.stringify(inputDev))
        deviceInfo.label = defDevice.label;
        devicesArray.push(deviceInfo);
        defDevice.label = undefined;
      }else {
        devicesArray.push(inputDev);
      }
    }
    const checkAddDefaultDevice = (devicesArray, defDevice) => {
      if (devicesArray.length) devicesArray.unshift(defDevice);
      else devicesArray.push(defDevice);
    }
    for (let count = 0; count < deviceList.length; count++) {
        switch (deviceList[count].kind) {
            case 'audioinput':
                if (requestedDevices.mic){
                  checkProcessDevice(deviceList[count], devices.mic, defaultDevs.mic);
                }
                break;
            case 'videoinput':
                if (requestedDevices.cam){
                  checkProcessDevice(deviceList[count], devices.cam, defaultDevs.cam);
                  //devices.cam.push(deviceList[count]);
                }
                break;
            case 'audiooutput':
                if (requestedDevices.speaker)
                  checkProcessDevice(deviceList[count], devices.speaker, defaultDevs.speaker);
                  //devices.speaker.push(deviceList[count]);
                break;
            default:
                break;
        }
    }
    /*if (defaultMic != undefined){
     console.log ("inserting default mic id: " + defaultMic.deviceId + " label: " + defaultMic.label);
      if (devices.mic.length) devices.mic.unshift(defaultMic);
      else devices.mic.push(defaultMic);
    }*/
    if (defaultDevs.mic.label) checkAddDefaultDevice(devices.mic,defaultDevs.mic);
    if (defaultDevs.cam.label) checkAddDefaultDevice(devices.cam,defaultDevs.cam);
    if (defaultDevs.speaker.label) checkAddDefaultDevice(devices.speaker,defaultDevs.speaker);
    return devices;
};

const getChangedDevices = (dvcList) => {
    var newDevices = { cam: [], mic: [], speaker: [] };
    var removedDevices = { cam: [], mic: [], speaker: [] };
    var currentDevices = { cam: [], mic: [], speaker: [] };
    if (that.deviceList !== undefined) {
      removedDevices = JSON.parse (JSON.stringify(that.deviceList));
      for (const camC in dvcList.cam) {
        var chkFlag = false;
        for (const camS in removedDevices.cam) {
        //console.log ("getChangedDevices(): compare cams index first: " + camC + " deviceId: " +
         //             dvcList.cam[camC].deviceId + " second: " + camS + " deviceId: " + removedDevices.cam[camS].deviceId);
            if (dvcList.cam[camC].deviceId === removedDevices.cam[camS].deviceId) {
              currentDevices.cam.push(removedDevices.cam.splice(camS,1)[0]);
              chkFlag = true;
            }
        }
        if (chkFlag === false) {
            newDevices.cam.push(dvcList.cam[camC]);
        }
      }
      for (const micC in dvcList.mic) {
        var chkFlag = false;
        for (const micS in removedDevices.mic) {
          if (dvcList.mic[micC].deviceId === removedDevices.mic[micS].deviceId &&
                dvcList.mic[micC].label === removedDevices.mic[micS].label) {
            //if (dvcList.mic[micC].deviceId === removedDevices.mic[micS].deviceId) {
            //if (dvcList.mic[micC].groupId === removedDevices.mic[micS].groupId) {
                //console.log ("MIC~~~ indexs: " + micC + " - " + micS + " deviceId: " + removedDevices.mic[micS].deviceId + " current devices: " + JSON.stringify(currentDevices.mic));
                currentDevices.mic.push(removedDevices.mic.splice(micS,1)[0]);
                chkFlag = true;
            }
        }
        if (chkFlag === false) {
            newDevices.mic.push(dvcList.mic[micC]);
        }
      }
      for (const speakerC in dvcList.speaker) {
        var chkFlag = false;
        for (const speakerS in removedDevices.speaker) {
            if (dvcList.speaker[speakerC].deviceId === removedDevices.speaker[speakerS].deviceId &&
                dvcList.speaker[speakerC].label === removedDevices.speaker[speakerS].label) {
            //if (dvcList.speaker[speakerC].groupId === removedDevices.speaker[speakerS].groupId) {
                currentDevices.speaker.push(removedDevices.speaker.splice(speakerS,1)[0]);
                chkFlag = true;
            }
        }
        if (chkFlag === false) {
            newDevices.speaker.push(dvcList.speaker[speakerC]);
        }
      }
      that.deviceList = dvcList;
    }
    return ({current: currentDevices,added: newDevices, removed : removedDevices});
};

const mediaDeviceUpdate = (id2Reset, options, id2Set, callback) => {
    console.log ("mediaDeviceUpdate() id2Reset: " + id2Reset + " id2Set: " + id2Set + " options: " + JSON.stringify(options));
    if (id2Reset) {
      if (that.changedDevicesCallbacks != undefined && that.changedDevicesCallbacks[id2Reset])
        delete that.changedDevicesCallbacks[id2Reset];
    }
    if (options != undefined && id2Set != undefined){
      if (that.changedDevicesCallbacks != undefined){
        that.changedDevicesCallbacks[id2Set] = callback;
      }else {
        if (that.deviceList === undefined) {
          getDeviceList(options, (dvL) => {
            that.deviceList = dvL.devices;
          });
        }
        that.changedDevicesCallbacks = {};
        that.changedDevicesCallbacks[id2Set] = callback;

      //console.log ("mediaDeviceUpdate callback is pushed 1st time");

        if (browserEngineCheck() == 'safari' &&isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_DEVICE_CHANGE_EVENT_SUPPORT)) {
          setInterval(() => {
              getDeviceList(options, (dvL) => {
                if (that.deviceList === undefined) {
                    that.deviceList = dvL.devices;
                } else {
                    const changedDevices = getChangedDevices(dvL.devices);
                    //that.changedDevicesCallbacks.forEach(cback => cback(changedDevices.added,changedDevices.removed));
                    for (const [id, cback] of Object.entries(that.changedDevicesCallbacks)) { cback(changedDevices);};
                }
            });
          }, 3000);
        } else {
          navigator.mediaDevices.ondevicechange = function (event) {
            console.log ("ondevicechange() evnt : " + event);
            if (that.receivedDC != undefined && that.receivedDC == true) return;
            that.receivedDC = true;
            //added 1000 msecs delay to process since  during plug/unplug devices, event fired multiple times and
            // device list comes proper at the last event
            setTimeout(() => {
              that.receivedDC = false;
              getDeviceList(options, (dvL) => {
                if (dvL.result == 0){
                  if (that.deviceList === undefined) {
                    that.deviceList = dvL.devices;
                  } else {
                    const changedDevices = getChangedDevices(dvL.devices);
                    for (const [id, cback] of Object.entries(that.changedDevicesCallbacks)) { cback(changedDevices);};
                  }
                }else{
                  console.log ("ondevicechange() getDeviceList failed error: " + JSON.stringify(dvL));
                }
              });
            },1000);
          };
        }
      }
    }
};
const getMediaPermission = (config, callback, retry = true) => {
    //As of now, this doesnt make much sense, we do the permission checking at the stream init time.
    //callback('success', null);
    //return;
    //console.log("retry flag value: " + retry);
    if (browserEngineCheck() === 'IE' || browserEngineCheck() === 'edge') {
        __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1153 });
        callback(null, __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1153);
        return;
    }
    //calling getUserMedia() causes blank on IOS safari self video when setting tab is called
    if (gotMediaPermission && browserEngineCheck() === 'safari') {
        callback('success', null);
        return;
    }
    //navigator.mediaDevices.getUserMedia({ audio: true, video: true })
    navigator.mediaDevices.getUserMedia(config)
        .then((stream) => {
            gotMediaPermission = true;
            callback(stream, null);
        }).catch((err) => {
            err = Object(__WEBPACK_IMPORTED_MODULE_4__utils_ErrorHandler__["a" /* default */])(err);
            __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_gum_failed, { error: err });
            if (retry && (err.result === __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1143.result || err.result === __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1144.result)){
              if(config.video && config.audio) {
                let newConfig = JSON.parse(JSON.stringify(config));
                newConfig.video = false;
                newConfig.videoConfigured = config.video;
                //since cam not available or  permission denied , try audio
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].warning(`getUserMedia() failed with error: ${JSON.stringify(err)} retry with audio-only`);
                getMediaPermission(newConfig, callback);
              }else if (!config.video && config.videoConfigured != undefined){
                let newConfig = JSON.parse(JSON.stringify(config));
                newConfig.video = config.videoConfigured;
                newConfig.audio = false;
                //since mic not allowed and cam is set , try video
                console.log(`getUserMedia() failed with error: ${JSON.stringify(err)} retry with video-only`);
                getMediaPermission(newConfig, callback);
              }else {
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error(`Failed to get media devices permission: ${JSON.stringify(err)}`);
                callback(null, err);
              }
            } else {
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error(`Failed to get media devices : ${JSON.stringify(err)}`);
                callback(null, err);
            }
        });
};
const getList = (callback) => {
    navigator.mediaDevices.enumerateDevices()
        .then((dv) => {
            callback(dv);
        })
        /*.catch((err) => {
            err = GUMErrorHandler(err);
            callback(null, err);
            Logger.error(`Cannot get device list:  ${JSON.stringify(err)}`);
            EL.error('agent-event', customEvents.event_gum_failed, { error: err });
        })*/;
};
const getDeviceList = (options, callback) => {
    let mediaDeviceOptions = {};
    if (options !== undefined) {
       mediaDeviceOptions.mic = (options.mic != undefined) ? options.mic : false;
       mediaDeviceOptions.cam = (options.cam != undefined) ? options.cam : false;
       mediaDeviceOptions.speaker = (options.speaker != undefined) ? options.speaker : false;
    }else {
      mediaDeviceOptions = { mic:true, cam: true, speaker:true};
    }
    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug("getDeviceList ops: " + JSON.stringify(options) + " media ops: " + JSON.stringify(mediaDeviceOptions));
    if (mediaDeviceOptions.mic || mediaDeviceOptions.cam){
      getMediaPermission({ audio: mediaDeviceOptions.mic, video: mediaDeviceOptions.cam}, (stream, error) => {
        if (stream || (error && (error.result === __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1145.result))) {
          getList((deviceList, errorList) => {
            if (deviceList) {
            console.log ("getDeviceList() getList() devices: " + JSON.stringify(deviceList));
                const dvc = processDevicesList(deviceList, mediaDeviceOptions);
                callback({ result: 0, devices: dvc });
            } else {
                callback(((error && (error.result === __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1145.result)) ? error : errorList));
            }
          });
        }else {
          callback(error);
        }
      });
    }else if (mediaDeviceOptions.speaker){
      getList((deviceList, errorList) => {
        if (deviceList) {
          const dvc = processDevicesList(deviceList, mediaDeviceOptions);
          callback({ result: 0, devices: dvc });
        }
      });
    }else {
      callback(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1155);
    }
  };

const getSupportedDeviceConstraints = () => {
  return navigator.mediaDevices.getSupportedConstraints();
}
const buildPair = (specInput) => {
    let that = {};
    const spec = specInput;
    VcxRtcSessionId += 1;
    spec.sessionId = VcxRtcSessionId;

    // Check which WebRTC Stack is installed.
    that.browser = browserEngineCheck();
    if (that.browser === 'fake') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].warning('Publish/subscribe video/audio streams not supported in media yet');
        __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].warn('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: 'Publish/subscribe video/audio streams not supported in media yet' });
        that = Object(__WEBPACK_IMPORTED_MODULE_2__webrtc_stacks_FcStack__["a" /* default */])(spec);
    } else if (that.browser === 'mozilla') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Firefox Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_1__webrtc_stacks_FirefoxStack__["a" /* default */])(spec);
    } else if (that.browser === 'safari') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Safari using Chrome Stable Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__["a" /* default */])(spec);
    } else if (that.browser === 'chrome-stable' || that.browser === 'electron') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Chrome Stable Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__["a" /* default */])(spec);
    } else if (that.browser === 'IE') {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('IE using Chrome Stable Stack');
        that = Object(__WEBPACK_IMPORTED_MODULE_0__webrtc_stacks_ChromeStableStack__["a" /* default */])(spec);
    } else {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('No stack available for this browser');
        __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: 'No stack available for this browser' });
        throw new Error('WebRTC stack not available');
    }
    if (!that.updateSpec) {
        that.updateSpec = (newSpec, callback = () => { }) => {
            __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('Update Configuration not implemented in this browser');
            __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: 'Update Configuration not implemented in this browser' });
            callback('unimplemented');
        };
    }

    return that;
};
const getPlugin = () => document.getElementById('WebrtcEverywherePluginId');
const attachEventListener = function (video, type, listener, useCapture) {
    video.addEventListener(type, listener, useCapture);
};
const GetUserMedia = (config, callback = () => { }, error = () => { }) => {
    let screenConfig;
    let getUserMedia;
    let getDisplayMedia;
    const browser = browserEngineCheck();
    if (browser === 'chrome-stable' || browser === 'electron' || browser === 'mozilla' || browser === 'safari') {
        getUserMedia = (userMediaConfig, cb, errorCb) => {
            navigator.mediaDevices.getUserMedia(userMediaConfig).then(cb).catch(errorCb);
        };
        getDisplayMedia = (userMediaConfig, cb, errorCb) => {
            if (navigator.getDisplayMedia) {
                navigator.getDisplayMedia({ video: true }).then(cb).catch(errorCb);
            } else {
                navigator.mediaDevices.getDisplayMedia(userMediaConfig).then(cb).catch(errorCb);
            }
        };
    } else {
        getUserMedia = navigator.getUserMedia = (userMediaConfig, cb, errorCb) => {
            if (document.readyState !== 'complete') {
                if (!getUserMediaDelayed) {
                    getUserMediaDelayed = true;
                    attachEventListener(document, 'readystatechange', () => {
                        if (getUserMediaDelayed && document.readyState == 'complete') {
                            getUserMediaDelayed = false;
                            getPlugin().getUserMedia(userMediaConfig, cb, errorCb);
                        }
                    });
                }
            } else {
                getPlugin().getUserMedia(userMediaConfig, cb, errorCb);
            }
        };
    }

    /*Author:Sohom
    *Description: configure screen sharing method/extension
    * */
    const configureScreensharing = () => {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Screen access requested');
        switch (browserEngineCheck()) {
            case 'electron':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Screen sharing in Electron');
                screenConfig = {};
                screenConfig.video = config.video || {};
                screenConfig.video.mandatory = config.video.mandatory || {};
                screenConfig.video.mandatory.chromeMediaSource = 'screen';
                getUserMedia(screenConfig, callback, error);
                break;
            case 'mozilla':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug(`Screen sharing in Firefox max fps: ${5}`);
                screenConfig = {};
                if (config.video !== undefined) {
                    screenConfig.video = {};
                    screenConfig.video.mediaSource = 'window' || 'screen';
                } else {
                    screenConfig = {
                        audio: config.audio,
                        video: { mediaSource: 'window' || 'screen' },
                    };
                }
                if (isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__["a" /* default */].constant.FIREFOX_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT)) {
                    getUserMedia(screenConfig, callback, error);
                } else {
                    //screenConfig.video = true;
                    screenConfig.video = { framerate: { ideal: config.fps} };
                    getDisplayMedia(screenConfig, callback, error);
                }
                break;
            case 'safari':
                if (!isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_SCREEN_SHARE_SUPPORT)) {
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Screen sharing  Safari ');
                    getDisplayMedia({ video: true }, callback, error);
                } else {
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error(`Screen Sharing not supported for safari version: ${getBrowserVersion()}`);
                    __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error(
                        'agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser,
                        { error: 'This safari version does not support ScreenSharing' },
                    );
                }
                break;

            case 'chrome-stable':
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Screen sharing in Chrome');
                screenConfig = {};
                if (config.desktopStreamId) {
                    screenConfig.video = config.video || { mandatory: {} };
                    screenConfig.video.mandatory = screenConfig.video.mandatory || {};
                    screenConfig.video.mandatory.chromeMediaSource = 'desktop';
                    screenConfig.video.mandatory.chromeMediaSourceId = config.desktopStreamId;
                    screenConfig.video.mandatory.chromeMediaSourceId = config.desktopStreamId;
                    getUserMedia(screenConfig, callback, error);
                } else if (isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_6__vcxEventProperties__["a" /* default */].constant.CHROME_VERSION_SCREEN_SHARE_WITHOUT_EXTN_SUPPORT)) {
                    let extensionId = 'apedaiecomcfkjdjbnkfcdafaikkdkeo';
                    if (config.extensionId) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug(`extensionId supplied, using ${config.extensionId}`);
                        extensionId = config.extensionId;
                    }
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Screen access on chrome stable, looking for extension');
                    try {
                        chrome.runtime.sendMessage(extensionId, { getStream: true }, (response) => {
                            if (response === undefined) {
                                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('Access to screen denied');
                                const theError = { code: 'Access to screen denied' };
                                error(theError);
                            } else {
                                const theId = response.streamId;
                                if (config.video.mandatory !== undefined) {
                                    screenConfig.video = config.video;
                                    screenConfig.video.mandatory.chromeMediaSource = 'desktop';
                                    screenConfig.video.mandatory.chromeMediaSourceId = theId;
                                } else {
                                    screenConfig = {
                                        video: {
                                            mandatory: {
                                                maxFrameRate: config.fps,
                                                chromeMediaSource: 'desktop',
                                                chromeMediaSourceId: theId,
                                            },
                                        },
                                    };
                                }
                                getUserMedia(screenConfig, callback, error);
                            }
                        });
                    } catch (e) {
                        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Screensharing plugin is not accessible ');
                        __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: 'Screensharing plugin is not accessible' });
                        const theError = { code: 'no_plugin_present' };
                        error(theError);
                    }
                } else {
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug(`Screen sharing in Chrome without extension max Fps:: ${3}`);
                    screenConfig.video = { frameRate: { ideal: config.fps} };
                    if (config.audio != undefined && config.audio !== false) screenConfig.audio = true;
                    getDisplayMedia(screenConfig, callback, error);
                }
                break;

            default:
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('This browser does not support ScreenSharing');
                __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: 'This browser does not support ScreenSharing' });
        }
    };

    if (config.screen) {
        configureScreensharing();
    } else if (typeof module !== 'undefined' && module.exports) {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('Video/audio streams not supported in controller yet');
    } else {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].debug('Calling getUserMedia with config', JSON.stringify(config));
        getUserMedia(config, callback, error);
    }
};


const GetCanvasStream = (config, callback = () => { }, error = () => { }) => {
    let canvas = null; let
        stream = null;
    const browser = browserEngineCheck();
    let canvasFps;
    if (config.canvas) {
        if (browser === 'chrome-stable' || browser === 'mozilla' || browser === 'safari') {
            if (config.canvas.fps !== undefined && config.canvas.fps > 0) canvasFps = config.canvas.fps;
            else if (config.canvas.fps !== undefined) {
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('Framerate is invalid is: ', config.canvas.fps);
                error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1154);
                __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1154 });
                return;
            }
            const { canvasId } = config.canvas;
            try {
                canvas = document.querySelector(`#${canvasId}`);
                if (canvas && (canvas instanceof HTMLMediaElement || canvas instanceof HTMLCanvasElement)) {
                    stream = canvas.captureStream((canvas instanceof HTMLCanvasElement ? canvasFps : undefined));
                    if (stream) callback(stream);
                    else {
                        // stream not found
                        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('captureStream() failed . canvasFps : ', canvasFps);
                        error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1159);
                        __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1159 });
                    }
                } else {
                    __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('DOM Element does not exists/ not a Media Element. DomId is: ', canvasId);
                    __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1157 });
                    error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1157);
                }
            } catch (e) {
                __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error('DOM Element does not exists/ not a Media Element. DomId is: ', canvasId);
                error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1157);
                __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error(
                    'agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser,
                    { error: __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1157, exception: (`Canvas chrome err: ${JSON.stringify(e)}`) },
                );
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error(' getCanvasStream() This browser does not support canvas');
            error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1158);
            __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1154 });
        }
    } else {
        __WEBPACK_IMPORTED_MODULE_3__utils_Logger__["default"].error(' getCanvasStream() is called without canvas options');
        __WEBPACK_IMPORTED_MODULE_8__EventLogger__["a" /* default */].error('agent-event', __WEBPACK_IMPORTED_MODULE_7__customEvents__["a" /* default */].event_incompatible_browser, { error: 'Canvas called without options' });
        error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1155);
    }
};
const getAndroidVersion = () => {
  const ua = navigator.userAgent;
  if (ua.indexOf('Android') >= 0) {
    const androidversion = parseFloat(ua.slice(ua.indexOf('Android') + 8));
    return androidversion;
  }

    return false;
};
const Connection = {
    GetUserMedia,
    buildPair,
    browserEngineCheck,
    getAndroidVersion,
    mediaDeviceUpdate,
    getDeviceList,
    getBrowserVersion,
    GetCanvasStream,
    isCurrentVerLess,
    getSupportedDeviceConstraints
};

/* harmony default export */ __webpack_exports__["a"] = (Connection);

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(36)(module)))

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const customEvents = {
    event_ice_failed: {
        event_code: '4000', severity: 'critical', event_name: 'ice-failed', event_description: 'ICE failed',
    },
    event_ice_success: {
        event_code: '40001', severity: '', event_name: 'ice-success', event_description: 'ICE success',
    },
    event_stream_subscribe_failed: {
        event_code: '4001', severity: 'critical', event_name: 'stream-subscribe-failed', event_description: 'Failed to subscribe to stream',
    },
    event_stream_subscribe_success: {
        event_code: '40011', severity: '', event_name: 'stream-subscribe-success', event_description: 'Subscribe to stream successful',
    },
    event_stream_unsubscribe_failed: {
        event_code: '4002', severity: 'critical', event_name: 'stream-unsubscribe-failed', event_description: 'Failed to unsubscribe from stream',
    },
    event_stream_unsubscribe_success: {
        event_code: '40021', severity: '', event_name: 'stream-unsubscribe-success', event_description: 'Unsubscribe from stream success',
    },
    event_socket_connect_failed: {
        event_code: '4003', severity: 'critical', event_name: 'socket-connect-failed', event_description: 'Socket connection failed',
    },
    event_socket_connect_success: {
        event_code: '40031', severity: '', event_name: 'socket-connect-success', event_description: 'Socket connection successful',
    },
    event_stream_publish_failed: {
        event_code: '4004', severity: 'critical', event_name: 'stream-publish-failed', event_description: 'Failed to publish stream',
    },
    event_stream_publish_success: {
        event_code: '40041', severity: '', event_name: 'stream-publish-success', event_description: 'stream published successfully',
    },
    event_stream_unpublish_failed: {
        event_code: '4005', severity: 'critical', event_name: 'stream-unpublish-failed', event_description: 'Failed to unpublish stream',
    },
    event_stream_unpublish_success: {
        event_code: '40051', severity: '', event_name: 'stream-unpublish-success', event_description: 'Unpublish stream success',
    },
    event_start_recording_failed: {
        event_code: '4006', severity: 'critical', event_name: 'start-recording-failed', event_description: 'Failed to start recording',
    },
    event_start_recording_success: {
        event_code: '40061', severity: '', event_name: 'start-recording-success', event_description: 'Start recording success',
    },
    event_start_local_recording_failed: {
        event_code: '40062', severity: 'critical', event_name: 'start-local-recording-failed', event_description: 'Failed to start local recording',
    },
    event_start_local_recording_success: {
        event_code: '40063', severity: '', event_name: 'start-local-recording-success', event_description: 'Start local recording success',
    },
    event_stop_recording_failed: {
        event_code: '4007', severity: 'critical', event_name: 'stop-recording-failed', event_description: 'Failed to stop recording',
    },
    event_stop_recording_success: {
        event_code: '40071', severity: '', event_name: 'stop-recording-success', event_description: 'Stop recording success',
    },
    event_stop_local_recording_failed: {
        event_code: '40072', severity: 'critical', event_name: 'stop-local-recording-failed', event_description: 'Failed to stop local recording',
    },
    event_stop_local_recording_success: {
        event_code: '40073', severity: '', event_name: 'stop-local-recording-success', event_description: 'Stop local recording success',
    },
    event_start_screenshare_failed: {
        event_code: '4008', severity: 'critical', event_name: 'start-screenshare-failed', event_description: 'Failed to start screenshare',
    },
    event_start_screenshare_success: {
        event_code: '40081', severity: '', event_name: 'start-screenshare-success', event_description: 'Screenshare Start successfully',
    },
    event_stop_screenshare_failed: {
        event_code: '4009', severity: 'critical', event_name: 'stop-screenshare-failed', event_description: 'Failed to stop screenshare',
    },
    event_stop_screenshare_success: {
        event_code: '40091', severity: '', event_name: 'stop-screenshare-success', event_description: 'Screenshare stopped successfully',
    },
    event_start_canvas_failed: {
        event_code: '4010', severity: 'critical', event_name: 'start-canvas-failed', event_description: 'Failed to start canvas',
    },
    event_start_canvas_success: {
        event_code: '40101', severity: '', event_name: 'start-canvas-success', event_description: 'Canvas started successfully',
    },
    event_stop_canvas_failed: {
        event_code: '4011', severity: 'critical', event_name: 'stop-canvas-failed', event_description: 'Failed to stop canvas',
    },
    event_stop_canvas_success: {
        event_code: '40111', severity: '', event_name: 'stop-canvas-success', event_description: 'Canvas stopped successfully',
    },
    event_network_reconnect_timeout: {
        event_code: '4012', severity: 'high', event_name: 'network-reconnect-timeout', event_description: 'Reconnection timed out',
    },
    event_start_annotation_failed: {
        event_code: '4012', severity: 'high', event_name: 'start-annotation-failed', event_description: 'Start Annotation Failed',
    },
    event_start_annotation_success: {
        event_code: '40121', severity: 'high', event_name: 'start-annotation-success', event_description: 'Start Annotation successful',
    },
    event_stop_annotation_failed: {
        event_code: '4013', severity: 'high', event_name: 'stop-annotation-failed', event_description: 'Stop Annotation Failed',
    },
    event_stop_annotation_success: {
        event_code: '40131', severity: 'high', event_name: 'stop-annotation-success', event_description: 'Stop Annotation successful',
    },
    event_send_message_failed: {
        event_code: '4013', severity: 'high', event_name: 'send-message-failed', event_description: 'Failed to send message',
    },
    event_send_message_success: {
        event_code: '40131', severity: '', event_name: 'send-message-success', event_description: 'Send message success',
    },
    event_reconnect_socket_failed: {
        event_code: '4014', severity: 'high', event_name: 'reconnect-socket-failed', event_description: 'Failed to reconnect socket',
    },
    event_reconnect_socket_success: {
        event_code: '40141', severity: '', event_name: 'reconnect-socket-success', event_description: 'Socket reconnection success',
    },
    event_send_data_failed: {
        event_code: '4018', severity: 'high', event_name: 'send-data-failed', event_description: 'Failed to send data',
    },
    event_send_data_success: {
        event_code: '40181', severity: '', event_name: 'send-data-success', event_description: 'Send data success',
    },
    event_media_access_denied: {
        event_code: '4019', severity: 'critical', event_name: 'media-access-denied', event_description: 'Access to media denied',
    },
    event_media_access_success: {
        event_code: '40191', severity: '', event_name: 'media-access-allowed-success', event_description: 'User has granted access to local media.',
    },
    event_agent_media_access_denied: {
        event_code: '40192', severity: 'critical', event_name: 'agent-media-access-denied-failed', event_description: 'Access to media denied (Agent)',
    },
    event_gum_failed: {
        event_code: '4020', severity: 'critical', event_name: 'gum-failed', event_description: 'Get User Media failed',
    },
    event_gum_success: {
        event_code: '40201', severity: '', event_name: 'gum-success', event_description: 'Get User Media success',
    },
    event_agent_gum_failed: {
        event_code: '40201', severity: 'critical', event_name: 'agent-gum-failed', event_description: 'Get User Media failed (Agent)',
    },
    event_audio_device_access_failed: {
        event_code: '4021', severity: 'critical', event_name: 'audio-device-access-failed', event_description: 'Failed to access Audio device',
    },
    event_agent_audio_device_access_failed: {
        event_code: '40211', severity: 'critical', event_name: 'agent-audio-device-access-failed', event_description: 'Failed to access Audio device (Agent)',
    },
    event_video_device_access_failed: {
        event_code: '4022', severity: 'critical', event_name: 'video-device-access-failed', event_description: 'Failed to access Video device',
    },
    event_agent_video_device_access_failed: {
        event_code: '40221', severity: 'critical', event_name: 'agent-video-device-access-failed', event_description: 'Failed to access Video device (Agent)',
    },
    event_remote_canvas_stream_failed: {
        event_code: '4023', severity: 'high', event_name: 'remote-canvas-stream-failed', event_description: 'Remote canvas stream failed',
    },
    event_capture_canvas_stream_failed: {
        event_code: '4024', severity: 'critical', event_name: 'capture-canvas-stream-failed', event_description: 'Failed to capture canvas stream',
    },
    event_set_local_description: {
        event_code: '4025', severity: 'none', event_name: 'set-local-description', event_description: 'Local SDP description is set',
    },
    event_set_remote_description: {
        event_code: '4026', severity: 'none', event_name: 'set-remote-description', event_description: 'Remote SDP description is set',
    },
    event_reconnect_subscribe_failed: {
        event_code: '4027', severity: 'high', event_name: 'reconnect-subscribe-failed', event_description: 'Failed to subscribe while reconnecting',
    },
    event_reconnect_publish_failed: {
        event_code: '4028', severity: 'high', event_name: 'reconnect-publish-failed', event_description: 'Failed to publish while reconnecting',
    },
    event_incompatible_browser: {
        event_code: '4029', severity: 'high', event_name: 'incompatible-browser', event_description: 'Browser is incompatible',
    },
    event_connect_socket_failed: {
        event_code: '4030', severity: 'high', event_name: 'connect-socket-failed', event_description: 'Socket connection failed',
    },
    event_connect_socket_success: {
        event_code: '40301', severity: '', event_name: 'connect-socket-success', event_description: 'Socket connection successful',
    },
    event_room_reconnection_failed: {
        event_code: '4031', severity: 'high', event_name: 'room-reconnection-failed', event_description: 'Room reconnection failed',
    },
    event_room_reconnection_success: {
        event_code: '40311', severity: '', event_name: 'room-reconnection- success', event_description: 'Room reconnection success',
    },
    event_room_disconnection_failed: {
        event_code: '4032', severity: 'high', event_name: 'room-disconnection-failed', event_description: 'Room disconnection failed',
    },
    event_room_disconnection_success: {
        event_code: '40321', severity: '', event_name: 'room-disconnection-success', event_description: 'Room disconnection success',
    },
    event_mute_self_audio_failed: {
        event_code: '4033', severity: 'high', event_name: 'mute-self-audio-failed', event_description: 'mute self audio failed',
    },
    event_mute_self_audio_success: {
        event_code: '40331', severity: '', event_name: 'mute-self-audio-success', event_description: 'mute self audio success',
    },
    event_unmute_self_audio_failed: {
        event_code: '4034', severity: 'high', event_name: 'unmute-self-audio-failed', event_description: 'unmute self audio failed',
    },
    event_unmute_self_audio_success: {
        event_code: '40341', severity: '', event_name: 'unmute-self-audio-success', event_description: 'unmute self audio success',
    },
    event_room_mute_failed: {
        event_code: '4035', severity: 'high', event_name: 'room-mute-failed', event_description: 'room mute failed',
    },
    event_room_mute_success: {
        event_code: '40351', severity: '', event_name: 'room-mute-success', event_description: 'room mute success',
    },
    event_room_unmute_failed: {
        event_code: '4036', severity: 'high', event_name: 'room-unmute-failed', event_description: 'room unmute failed',
    },
    event_room_unmute_success: {
        event_code: '40361', severity: '', event_name: 'room-unmute-success', event_description: 'room unmute success',
    },
    event_file_shared_failed: {
        event_code: '4037', severity: 'high', event_name: 'file-shared-failed', event_description: 'file shared failed',
    },
    event_file_shared_success: {
        event_code: '40371', severity: '', event_name: 'file-shared-success', event_description: 'file shared success',
    },
    event_file_download_failed: {
        event_code: '4038', severity: 'high', event_name: 'file-downlod-failed', event_description: 'file download failed',
    },
    event_file_download_success: {
        event_code: '40381', severity: '', event_name: 'file-downlod-success', event_description: 'file downlod success',
    },
    event_mute_self_video_failed: {
        event_code: '4039', severity: 'high', event_name: 'mute-self-video-failed', event_description: 'mute self video failed',
    },
    event_mute_self_video_success: {
        event_code: '40391', severity: '', event_name: 'mute-self-video-success', event_description: 'mute self video success',
    },
    event_unmute_self_video_failed: {
        event_code: '4040', severity: 'high', event_name: 'unmute-self-video-failed', event_description: 'unmute self video failed',
    },
    event_unmute_self_video_success: {
        event_code: '40401', severity: '', event_name: 'unmute-self-video-success', event_description: 'unmute self video failed',
    },
    event_low_bandwidth_update: {
        event_code: '4041', severity: '', event_name: 'low-bandwidth-update', event_description: 'low bandwidth update',
    },
    event_network_change: {
        event_code: '4042', severity: '', event_name: 'network-change', event_description: 'network change',
    },
    event_connection_lost: {
        event_code: '4043', severity: '', event_name: 'connection-lost', event_description: 'connection lost',
    },
    event_make_outbound_call_failed: {
        event_code: '4044', severity: 'high', event_name: 'make-outbound-call-failed', event_description: 'Outbound call failed',
    },
    event_make_outbound_call_success: {
        event_code: '40441', severity: '', event_name: 'make-outbound-call-success', event_description: 'Outbound call success',
    },
    event_make_outbound_call_state: {
        event_code: '4045', severity: '', event_name: 'make-outbound-call-state', event_description: 'Outbound call state',
    },
    event_abwd_mute_video_success: {
        event_code: '4101', severity: '', event_name: 'mute-publisher-video-success', event_description: 'Publisher video muted due to low bandwidth',
    },
    event_fs_upload_started_success: {
        event_code: '4102', severity: '', event_name: 'fs-upload-started-success', event_description: 'File is being shared',
    },
    event_fs_file_available_success: {
        event_code: '4103', severity: '', event_name: 'fs-file-available-success', event_description: 'File is being shared',
    },
    event_room_user_connect_failed: {
        event_code: '4104', severity: '', event_name: 'room-user-connect-failed', event_description: 'User connection to the Room failed',
    },
    event_room_user_connect_success: {
        event_code: '41041', severity: '', event_name: 'room-user-connect-success', event_description: 'A new user is connected to the Room',
    },
    event_room_user_disconnect_failed: {
        event_code: '4105', severity: '', event_name: 'room-user-disconnect-failed', event_description: 'User disconnection to the Room failed',
    },
    event_room_user_disconnect_success: {
        event_code: '41051', severity: '', event_name: 'room-user-disconnect-success', event_description: 'User is disconnected to the Room',
    },
    event_start_live_recording_failed: {
        event_code: '4046', severity: 'critical', event_name: 'start-live-recording-failed', event_description: 'Failed to start live recording',
    },
    event_start_live_recording_success: {
        event_code: '40461', severity: '', event_name: 'start-live-recording-success', event_description: 'Start live recording success',
    },
    event_stop_live_recording_failed: {
        event_code: '4047', severity: 'critical', event_name: 'stop-live-recording-failed', event_description: 'Failed to stop live recording',
    },
    event_stop_live_recording_success: {
        event_code: '40471', severity: '', event_name: 'stop-live-recording-success', event_description: 'Stop live recording success',
    },
    event_live_recording_param_change_failed: {
        event_code: '40472', severity: '', event_name: 'live-recording-param-change-failed', event_description: 'live recording params change failed',
    },
    event_live_recording_param_change_success: {
        event_code: '40473', severity: '', event_name: 'live-recording-param-change-success', event_description: 'live recording params change success',
    },
    event_streaming_param_change_failed: {
        event_code: '40474', severity: '', event_name: 'Streaming-param-change-failed', event_description: 'Streaming params change failed',
    },
    event_streaming_param_change_success: {
        event_code: '40475', severity: '', event_name: 'Streaming-param-change-success', event_description: 'Streaming params change success',
    },
    event_general_failed: {
        event_code: '4106', severity: 'critical', event_name: 'general-failed', event_description: 'General error',
    },
    event_general_success: {
        event_code: '41061', severity: '', event_name: 'general-success', event_description: 'General success',
    },
    event_stream_player_failed: {
        event_code: '4107', severity: 'critical', event_name: 'player-play-failed', event_description: 'player div is not playing the video',
    },
    event_media_connection_failed: {
        event_code: '4108', severity: 'critical', event_name: 'media-connection-failed', event_description: 'media connection/s failed',
    },
};

/* harmony default export */ __webpack_exports__["a"] = (customEvents);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__Common_config__);
/* Import Global Libraries */



/**************************************
 * Class: EventLogger
 * Description: This class represents EventLogger.
 * Author: Gagandeep
 * Las Edit Date: 24/09/2019
 * Relase Version: 1.0
 **************************************/

const EventLogger = () => {
    const DEBUG = 1;
    const TRACE = 2;
    const INFO = 3;
    const WARNING = 4;
    const ERROR = 5;
    const NONE = 6;

    const that = {};
    that.eventLoggerToken = undefined;
    that.eventServer = {};
    that.logID = undefined;
    that.eventBuffer = new Array();
    that.uniqueSequence = 1;
    that.clientId = undefined;
    switch (__WEBPACK_IMPORTED_MODULE_1__Common_config___default.a.eventLogLevel){
    case "trace":
      that.logLevel = TRACE;
    break;
    case "debug":
      that.logLevel = DEBUG;
    break;
    case "info":
      that.logLevel = INFO;
    break;
    case "warn":
      that.logLevel = WARNING;
    break;
    case "error":
      that.logLevel = ERROR;
    break;
    case "none":
    default:
      that.logLevel = NONE;
    break;
    }

    // ************************************
    // Public function: init()
    // Intializes EventLogger
    // ************************************

    that.init = (token) => {
        // conference token will be short lived and not persist here, as after validation, its life will expire
        // So this token will only passthrough for validation
        try {
            // let tokenObj = JSON.parse(window.atob(token));
            const tokenObj = token;

            // If server sent back Event Server details(url and port) with token, logging is turned ON else it is turned OFF
            if (tokenObj.eventServer && tokenObj.eventServer.url) {
                that.eventServer.url = tokenObj.eventServer.url;
                that.logID = tokenObj.logId;
                /*
                if(tokenObj.eventServer.url && tokenObj.eventServer.port){

                    xhttp.onreadystatechange = function() {
                        //console.log("readystate: " + this.readyState + " status: " + this.status + " responseText: " + this.responseText );
                        if (this.readyState == 4 && this.status == 200) {
                            //Logger.info(this.responseText);
                            that.eventLoggerToken = JSON.parse(this.responseText).eventLoggerToken;

                            //console.log('that.eventLoggerToken = ' + that.eventLoggerToken);
                            //config.setLocalStorageItem('eventToken', that.eventLoggerToken);
                            that.processBufferEvents();

                        } else {
                            //Logger.error('Connection to Event Server did not establish. Status: ' + this.status + ' responseText' + this.responseText);
                        }
                    }
                    xhttp.open("POST", "https://" + tokenObj.eventServer.url + ":" + tokenObj.eventServer.port + "/init", true);

                    //xhttp.setRequestHeader("authorization", "123");
                    //xhttp.setRequestHeader("content-type", "application/json");
                    xhttp.setRequestHeader("token", window.btoa(JSON.stringify(token)));

                    xhttp.send();
                }
                */
            }
        } catch (e) {
            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error(`Error! Failed to send auth request to Event Server. Error: ${e}.`);
        }
        // console.log("EVENT SERVER URL: " + that.eventServer.url + " Port: " + that.eventServer.port);
    };


    that.log = (level0, logEvent) => {
        try {
            // If server sent back Event Server details(url and port), logging is turned ON else it is turned OFF
            // console.log('EventLogger.log event ' + JSON.stringify(logEvent));
            if (level0 < that.logLevel) return;
             __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug('EventLogger.log event SENT' + JSON.stringify(logEvent));
            // Create Event Object
            const sourceTimeStamp = new Date().toISOString();
            let level0Label = 'info';
            const eventObj = {};

            switch (level0) {
                case DEBUG:
                    level0Label = 'debug';
                    break;

                case TRACE:
                    level0Label = 'trace';
                    break;

                case INFO:
                    level0Label = 'info';
                    break;

                case WARNING:
                    level0Label = 'warning';
                    break;

                case ERROR:
                    level0Label = 'error';
                    break;

                default:
                    level0Label = 'info';
            }

            // Event Object structure that will eventually be published to the event server
            // Caution: If you are modifying this object's prototype (members),
            //    take care of the filtering and structuring of the information at the backend (event server and further) as well

            eventObj.key = {
                logID: that.logID,
                endpointType: 'client',
                instanceID: that.logID, // ToDo - TBD, This field is for Servers, TBD for clients, for now keep it as logID
                uniqueSequence: that.uniqueSequence++,
                //clientId: that.clientId? that.clientId: "undef"
            };

            if (logEvent.event) {
                eventObj.severity = logEvent.event.severity; // ToDo - Devise logic to auto determine severity. E.g. Critical, high, medium, low, none
            } else {
                eventObj.severity = 'none'; // default severity if no severity is available
            }

            eventObj.eventLevel = [];
            eventObj.eventLevel.push(level0Label);
            eventObj.eventLevel.push(logEvent.source);

            // eventMeta is a generic object, structure of which is left to the client and end-consumer of event logs
            // eventObj.eventMeta = logEvent;
            eventObj.eventMeta = {};
            eventObj.eventMeta.event = logEvent.event;
            eventObj.eventMeta.meta = logEvent.meta;

            eventObj.isAnonymousInfo = true;
            eventObj.sourceTimeStamp = sourceTimeStamp;

            if (that.eventServer.url && that.eventLoggerToken) {
                // POST event object to Event server if event server url port and Eventlogger token in available
                const xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    if (this.readyState === 4 && this.status === 200) {
                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info(this.responseText);
                    } else {
                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error(`Connection to Event Server did not establish. readyState: ${this.readyState} Status: ${this.status}`);
                    }
                };
                xhttp.open('POST', `https://${that.eventServer.url}/event`, true);
                xhttp.setRequestHeader('Content-Type', 'application/json');
                xhttp.setRequestHeader('eventToken', that.eventLoggerToken);

                xhttp.send(JSON.stringify(eventObj));
            } else {
                // Else, store the log in a buffer till the time the token is available and POST once event server responds
                that.eventBuffer.push(eventObj);
            }
        } catch (e) {
            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error(`Error! Failed to post log event to Event Server. Error: ${e}.`);
        }
    };

    that.debug = (source, event, meta) => {
        const logEvent = { source, event, meta };
        that.log(DEBUG, logEvent);
    };

    that.trace = (source, event, meta) => {
        const logEvent = { source, event, meta };
        that.log(TRACE, logEvent);
    };

    that.info = (source, event, meta) => {
        const logEvent = { source, event, meta };
        that.log(INFO, logEvent);
    };

    that.warn = (source, event, meta) => {
        const logEvent = { source, event, meta };
        that.log(WARNING, logEvent);
    };

    that.error = (source, event, meta) => {
        if(meta.error != undefined && typeof(meta.error) != 'object'){
            var message = meta.error;
            meta.error = { "errorDesc" : message }
        }
        const logEvent = { source, event, meta };
        that.log(ERROR, logEvent);
    };

    // ************************************
    // Public function: close()
    // Closes the logger. No use case of this yet, but need to check.
    // ************************************

    that.close = () => {
        // ToDO TBD - reset all event logger properties such as eventLoggerToken, logID(risks?), uniqueSequence. Check risks.
    };

    that.revalidate = () => {
        // ToDO TBD - revalidate the eventLoggerToken by either reissuing another token or extending the current token validity
        // Need to check if logId and uniqueSequence should be preserved
    };

    that.processBufferEvents = () => {
        for (let i = 0; i < that.eventBuffer.length; i++) {
            const postEvent = that.eventBuffer[i];
            /*
            if(that.clientId && postEvent && postEvent.key){
               postEvent.key.clientId = that.clientId;
            }
            */
            const xhttpBuffer = new XMLHttpRequest();
            xhttpBuffer.onreadystatechange = function () {
                if (this.readyState == 4 && this.status == 200) {
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info(this.responseText);
                } else {
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error(`Connection to Event Server did not establish. Status: ${this.status}`);
                }
            };
            xhttpBuffer.open('POST', `https://${that.eventServer.url}/event`, true);
            xhttpBuffer.setRequestHeader('Content-Type', 'application/json');
            xhttpBuffer.setRequestHeader('eventToken', that.eventLoggerToken);
            xhttpBuffer.send(JSON.stringify(postEvent));
        }
    };

    that.setClientId = (clientId) => {
        that.clientId = clientId;
    };

    that.setEventLoggerToken = (token) => {
        if (token) {
            that.eventLoggerToken = token;
            if (that.eventLoggerToken && that.eventServer && that.eventServer.url) {
                that.processBufferEvents();
            }
        }
    };

    return that;
};

const EL = EventLogger();

/* harmony default export */ __webpack_exports__["a"] = (EL);


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const defaultSkin = {
    vcx_player: {
        width: 'inherit',
        height: 'inherit',
        position: 'relative',
        'background-color': 'black',
        overflow: 'hidden',

    },
    vcx_player_loader: {
        width: '100%',
        height: '100%',
        position: 'absolute',
    },
    vcx_player_screen_saver: {
        width: '100%',
        height: '100%',
        position: 'absolute',
        'z-index': '1',
    },
    vcx_stream: {
        width: 'inherit !important',
        height: 'inherit !important',
        position: 'absolute',
        'object-fit': 'cover',
    },
    default_vcx_bar: {
        height: '100%',
        width: '100%',
        position: 'absolute',
    },
    vcx_subbar_bottom: {
        width: '100%',
        height: '15%',
        'max-height': '33px',
        color: '#aaa',
        position: 'absolute',
        bottom: 0,
        'background-repeat': 'repeat-x;',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'bottom',
        'padding-top': '50px',
        'z-index': 2,
    },
    vcx_subbar_top: {
        width: '100%',
        height: '15%',
        'max-height': '30px',
        color: '#aaa',
        position: 'absolute',
        top: 0,
        'background-repeat': 'repeat-x',
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'top !important',
        'padding-bottom': '50px',
        'z-index': 2,
        //'background-position': 'bottom',
    },
    vcx_subbar_left: {
        width: '15%',
        height: '100%',
        'max-width': '30px',
        color: '#aaa',
        position: 'absolute',
        left: 0,
        'background-repeat': 'repeat-x',
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'bottom',
    },
    vcx_subbar_right: {
        width: '15%',
        height: '100%',
        'max-width': '30px',
        color: '#aaa',
        position: 'absolute',
        right: 0,
        transition: 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-webkit-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        '-moz-transition': 'opacity .25s cubic-bezier(0.0,0.0,0.2,1)',
        'background-position': 'bottom',
    },
    brand_logo: {
        'max-width': '30px',
        'max-height': '30px',
        cursor: 'pointer',
        position: 'absolute',
        right: '0px',
        margin: '5px',
    },
    theater_view: {
        width: '100% !important',
        height: '80% !important',
    },
    full_view: {
        width: '100% !important',
        height: '100% !important',
        top: '0px',
        left: '0px',
        position: 'fixed !important',
        'z-index': 3,
    },
    icon: {
        margin: '7px',
        'max-width': '30px',
        cursor: 'pointer',
    },
    icon_record: {
        color: '#f00',
    },
    icon_volume: {
        color: '#aaa',
    },
    icon_play: { color: '#aaa' },
    icon_mic: { color: '#aaa' },
    icon_zoom: { color: '#aaa' },
    icon_share: { color: '#aaa' },
};

/* harmony default export */ __webpack_exports__["a"] = (defaultSkin);


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Pair__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Socket__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Stream__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__BreakOutRoom__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__views_Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__utils_Base64__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__customErrors__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__Common_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__customEvents__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__EventLogger__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__fileShare_app_api__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__fileShare_app_fileSender__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__fileShare_app_archive__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__fileShare_app_fileReceiver__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__annotate__ = __webpack_require__(67);
/*
*Author: Sohom
*Description: Class Room represents a VCX Room. It will handle the connection, local stream publication and
 *            remote stream subscription.
 * Typical Room shall initilized: var room = Client.Room({token:'213h8012hwduahd-321ueiwqewq'});
 * It also handles RoomEvents and StreamEvents. For example:
 * Event 'room-connected' refers that the user has been successfully connected to the room.
 * Event 'room-disconnected' refers that the user has been already disconnected.
 * Event 'stream-added' refers that there is a new stream available in the room.
 * Event 'stream-removed' refers that a previous available stream has been removed from the room.
 *Version: V 1.0
 */














// file sharing






const lowBwIcon = `<svg id="icon_low_bw" height="20" viewBox="0 0 24 24" width="20" title="Low Bandwidth"><path d="m16.155 13.799-5.284 7.908c-.43.665.048 1.542.84 1.542h10.507c.789 0 1.268-.872.843-1.538l-5.223-7.908c-.392-.613-1.288-.616-1.683-.004z" fill="#ffc107"/><path fill="#f44236" d="m22.288 24.031h-10.576c-.944 0-1.712-.747-1.712-1.665 0-.333.098-.647.281-.908l5.271-8.206c.294-.479.852-.784 1.448-.784s1.154.305 1.456.796l5.28 8.221c.166.235.264.549.264.882 0 .918-.768 1.664-1.712 1.664zm-5.288-10.062c-.088 0-.154.042-.179.082l-5.296 8.245c-.025.148.062.235.187.235h10.576c.125 0 .212-.087.212-.165 0-.027-.006-.042-.008-.044l-5.306-8.26c-.032-.051-.098-.093-.186-.093z"/><path fill="#f44236" d="m17 19.719c-.414 0-.75-.336-.75-.75v-1.917c0-.414.336-.75.75-.75s.75.336.75.75v1.917c0 .414-.336.75-.75.75z"/><ellipse cx="17" cy="21.365" rx=".75" ry=".719"/><path fill="#f44236" d="m.75 24c-.414 0-.75-.336-.75-.75v-7.5c0-.414.336-.75.75-.75s.75.336.75.75v7.5c0 .414-.336.75-.75.75z"/><path fill="#f44236" d="m6.75 24c-.414 0-.75-.336-.75-.75v-11.5c0-.414.336-.75.75-.75s.75.336.75.75v11.5c0 .414-.336.75-.75.75z"/><path fill="#f44236" d="m12.75 13.74c-.414 0-.75-.336-.75-.75v-7.24c0-.414.336-.75.75-.75s.75.336.75.75v7.24c0 .414-.336.75-.75.75z"/><path fill="#f44236" d="m18.75 11.11c-.414 0-.75-.336-.75-.75v-9.61c0-.414.336-.75.75-.75s.75.336.75.75v9.61c0 .414-.336.75-.75.75z"/></svg>`;

const statsIcon = '<svg  viewBox="0 0 16 16" width="16" height="16" xml:space="preserve" fill="green"><rect height="6" width="4" y="10"/><rect height="10" width="4" x="6" y="6"/><rect height="16" width="4" x="12"/></svg>';

const analytics_operation = ['meeting_agenda','abstract_summary', 'key_points', 'action_items', 'sentiment_analysis'];

const USER = "user";
const OWNER = "owner";
const ROOM = "room";
const SESSION = "session";
const ALL = "all";
const NONE = "none";
const SCOPE = [USER,OWNER, ROOM, SESSION];
const BROADCAST = [ALL, NONE];
let localMediaStreamInUse = true;
let localVideoStreamATStateBw;

window.statsIcon = statsIcon;
window.lowBwIcon = lowBwIcon;

const Room = (altIo, altConnection, specInput) => {
    if (!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.is_supported()) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Failed - Webrtc support is missing ');
        return undefined;
    }
    const that = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["c" /* EventDispatcher */])(specInput);
    const DISCONNECTED = 0;
    const CONNECTING = 1;
    const CONNECTED = 2;
    const DISCONNECTING = 3;
    const RECONNECTING = 4;
    let detectInternet = {timer: undefined, intervalSecs: 1, timeoutSecs :10, disconnectedDurationSecs:0};
    // default reconnectInfo parameters
    const defReconnectInfo = {
        allow_reconnect: true, number_of_attempts: 3, timeout_interval: 45000,
    };
    // file receive test
    that.filesToUpload = [];
    that.f2rec = {};
    that.availableFiles = [];
    const uploadsInProgress = new Map();
    const downloadsInProgress = new Map();
    const playerATList = new Map();

    let  shFileList = [];
    let maxFileSize = 10 * 1024 * 1024;
    const fileShareUI = {
        enable: false,
        uploadElToAppend: '',
        recvElToAppend: '',
    };
    that.showFsUi = false;
    // end ft test
    const spec = specInput;
    that.internetDetectionUrl = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.internetDetectionUrl; // ajax resource url to detect the network
    that.remoteStreams = Object(__WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__["a" /* default */])();
    that.remotePendingStreams = Object(__WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__["a" /* default */])();
    that.remoteStreamsInfo = Object(__WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__["a" /* default */])();
    that.numATSubscribersAdded = 0;
    that.localStreams = Object(__WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__["a" /* default */])();
    that.roomID = '';
    that.talkerCount = 0;
    that.userAudioTalkerCount = 0;
    that.userVideoTalkerCount = 0;
    that.state = DISCONNECTED;
    that.allStreamsActive = false;
    that.streamsHealthTimerId = 0;
    that.Connection = altConnection === undefined ? __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */] : altConnection;
    that.receiveVideoQuality = new Map();
    that.receiveVideoQuality.set('talker', 'Auto');
    that.receiveVideoQuality.set('canvas', 'HD');
    that.mediaStatsMode = 'disable';
    that.liveTranscription= false;
    that.liveRoomTranscription= false;
    that.transcriptionLanguage = '';
    that.liveMeetingAnalytics = false;

    let socket = Object(__WEBPACK_IMPORTED_MODULE_2__Socket__["a" /* Socket */])(altIo);
    that.socket = socket;
    that.userList = new Map();
    that.dialOutList = new Map();
    that.cControlReq = undefined;
    that.cCrequest = [];
    that.awaitedParticipants = new Map();
    that.floorGranted = false;
    that.floorInvited = false;
    that.floorAccepted = false;
    that.roomJson = undefined;
    that.clientId = undefined;
    that.mode = undefined;
    that.activeTalker = false;
    that.shareStatus = false;
    that.shareDisplayWaitTimeoutSecs = 0;
    that.shareEventInfo;
    that.ScreenSharelocalStream = null;
    that.isSharingClient = false;
    that.forcedStopSharing = false;
    that.isCanvasSharing = false;
    that.isCanvasSharingClient = false;
    that.canvasStatus = false;
    that.activeTalkerList = new Map();
    that.audioOnlyMode = false;
    that.roomMuted = false;
    const token = JSON.parse(__WEBPACK_IMPORTED_MODULE_7__utils_Base64__["a" /* default */].decodeBase64(spec.token));
    that.reconnectionState = false; //  reconnection
    that.reconnectAttempt = 0;
    that.connectAttempt = 0;
    that.isFirstConnect = true;
    let MAXRECONNECTIONATTEMPT = 3;//  kept high value for testing it needs to be changed
    let MAXCONNECTIONATTEMPT = 7;//  kept high value for testing it needs to be changed
    that.isStreamingClient = false;
    that.sendRecvBitrateStats = false;
    that.speakerInfo = {id: (spec && spec.speakerId ? spec.speakerId: undefined), volume: 1};
    let localRecord = 'none';
    let numStreamsReconnecting = 0;
    const avOptions = {
        publish: { forceTurn: false },
        subscribe: { forceTurn: false, imageOnVideoMute: false },
    };
    const sharePublishOptions = { forceTurn: false };
    const canvasPublishOptions = { forceTurn: false };
    if (spec.hasOwnProperty('reconnectInfo')) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnect parameter', spec.reconnectInfo);
        that.reconnectionAllowed = spec.reconnectInfo.allow_reconnect;
        that.reconnectionTimeOutInterval = spec.reconnectInfo.timeout_interval;
        MAXRECONNECTIONATTEMPT = spec.reconnectInfo.number_of_attempts;
    } else {
        //  if reconnect params are not  present in the spec info
        that.reconnectionAllowed = defReconnectInfo.allow_reconnect;
        that.reconnectionTimeOutInterval = defReconnectInfo.timeout_interval;
        MAXRECONNECTIONATTEMPT = defReconnectInfo.number_of_attempts;
    }
    __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.alertNotifyInfo = {mode:'image'};
    if (spec.alertNotifyInfo && typeof spec.alertNotifyInfo === 'object'){
      if (spec.alertNotifyInfo.mode && (spec.alertNotifyInfo.mode == 'text' || spec.alertNotifyInfo.mode == 'image' ||
          spec.alertNotifyInfo.mode == 'none')){
        __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.alertNotifyInfo = Object.assign (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.alertNotifyInfo, spec.alertNotifyInfo);
      }
    }
    const reconStartTime = 0;
    let roomRecordStatus = false;
    let prefNumTakler = -1;
    that.localStreamsBeforeReconnect = Object(__WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__["a" /* default */])();// store all local streams in this before reconnect
    that.oldSpecInfo = undefined;
    that.mediaConfiguration = token.roomMeta.settings.media_configuration ?
        token.roomMeta.settings.media_configuration : 'Default';
    that.maxVideoLayers = 0;
    that.defaultBandwidth = new Map();
    that.defaultBandwidth.set(1, 200000);
    that.defaultBandwidth.set(2, 300000);
    that.defaultBandwidth.set(3, 400000);
    that.defaultBandwidth.set(4, 600000);
    that.defaultBandwidth.set(5, 800000);
    that.defaultBandwidth.set(6, 1000000);
    that.defaultBandwidth.set(7, 1200000);

    that.videoMutedUsers = {};
    let socketErrorTimer, mediaConnectionTimer, mediaActivationDelayTimer;
    that.mediaActivationDelaySecs = 0;
    let statsTimer;
    let remoteStreams = that.remoteStreams;
    let remotePendingStreams = that.remotePendingStreams;
    let numATSubscribersAdded = that.numATSubscribersAdded;
    let localStreams = that.localStreams;
    let locStrm;
    let reconnectStreamIds = {local: {}, remote :{}};
    that.hardMuteRoom = false;
    const breakOutRoom = Object(__WEBPACK_IMPORTED_MODULE_4__BreakOutRoom__["a" /* default */])(null, null);
    that.breakOutRoom = breakOutRoom;
    that.me = {};
    that.roomSettings = {};
    that.mute = false;
    that.muteInfo = {room: {audio: false, video:false}, stream: {hard: {audio:false, video:false}}};
    that.muteAudioOnJoin = false;
    that.muteVideoOnJoin = false;
    //that.mute = {room: false, audioOnJoin: false, videoOnJoin: false};
    that.cCapprovedHands = [];
    that.externalIp = '';
    let peerStatsInterval;
    that.subscribeSessionStats = false; // session stats display

    that.canvasOptions = { width: 1280, height: 720, domHandle: '' };
    that.inputContext = null;
    that.canvasVideoPlayer = '';
    const videoResolutionRange = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_resolution_range[token.roomMeta.settings.quality];
    const statsStyle = document.createElement('style');
    const statsCss = `.stats-container{
                         position: absolute;
                         z-index: 5;
                         padding: 2px;
                         top: 2px;
                         right: 2px;
                         font-size: 12px;
                         width: 22px;
                         height: 22px;
                         text-align: center;
                         background: white;
                         border-radius: 10px;
                     }
                     .stats-button{
                         cursor:pointer;
                         width: 15px;
                         height: 15px;
                         padding: 0 0 0 2px;
                     }
                     .stats-detail{ height: 100%;}
                     .stats-overlay-inner{
                         display: flex;
                         flex-direction: row;
                         justify-content: space-between;
                         padding: 8px 2px 6px 10px;
                     }
                     .stats-right-partition, .stats-left-partition {}
                     .stats-left-partition {margin-right: 10px;}
                     .stats-button svg {width: 12px;height: 12px;}
                         `;
    statsStyle.innerHTML = statsCss;

    const bwNotificationStyle = document.createElement('style');
    const bwNotificationCSS = `.bw-notification{
                                 position: absolute;
                                 //z-index: 5;
                                 top:1%;
                                 left:50%;
                                 //bottom: 5px;
                                 //right: 5px;
                                 //margin-top:-50px;
                                 //margin-left:-100px;
                                 padding: 5px;
                                 color: #fff;
                                 //background: rgba(50,50,50,0.5);
                                 }`;
    bwNotificationStyle.innerHTML = bwNotificationCSS;
    let isAnnotationStarted = false;
    let isCaptchaStarted = false;
    let isIceSuccess = false;
    let videoPlaying = true;
    let timeIntervalforCanvas = 0;
    let setTime = 0.3;

    /*Descirption: Private functions removeStream used to release a strem from a socket
      * Used in: socketOnRemoveStream
      * */
    const removeStream = (streamInput) => {
        const stream = streamInput;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(" in Remove stream : id: " + stream.getID() + " stream.stream : " + stream.stream);
        if (stream.stream) {
            // Remove HTML element
            stream.hide();

            stream.stop();
            stream.close();
            delete stream.stream;
        }

        // Close PC stream
        if (stream.pc) {
            stream.pc.close();
            delete stream.pc;
        }
    };

    const onStreamFailed = (streamInput, message) => {
      checkWaitReconnectStream(streamInput, 'add', (result)=> {});
    };

    /*
     *Descirption: Private functions dispatchStreamSubscribed used
     * to notify when stream get subscribed
     * Used in: createRemoteStreamConnection
     * */
    const dispatchStreamSubscribed = (streamInput, evt) => {
        const stream = streamInput;
        let peerStatsIntervalSubs;
        // Draw on html
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stream subscribed');
        if (evt.stream) {
            stream.initRemoteStream(evt.stream);
            that.remoteStreams.remove(stream.getID());
            that.remoteStreams.add(stream.getID(), stream);
        }

        const evt2 = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])({ type: 'stream-subscribed', stream });
        that.dispatchEvent(evt2);

        // put reconnect condition
        // Play the stream if player is available but stream is paused
        stream.room = that;
        //if (stream.screen === true || stream.canvas === true) {
            let info = that.remoteStreamsInfo.get(stream.getID());
            stream.updateVideo(stream.getID(), (info ? info.player: undefined));
        //}

        const getPeerData = (result) => {
            if (result) {
                //    clearInterval(peerStatsIntervalSubs);
                const additionalOptions = {
                    streamType: stream.ifScreen() ? 'share' : 'main',
                    streamId: stream.getID(),
                    selectedCandidates: result.selectedCandidates,
                    negotiatedCodecs: {
                        video: {
                            codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration,
                        },
                        audio: {
                            codec: 'OPUS',
                        },
                    },
                    externalIp: that.externalIp,
                };
                that.createEventLog('clientStreamSubscribeSuccess', additionalOptions);
            }
        };
        /*   if(stream.pc) {
               peerStatsIntervalSubs = setInterval(() => {
                   getPeerStats(stream.pc.peerConnection, getPeerData);
               }, 1000);
           } */
    };

    /*
          *Descirption: Private functions removeLocalStreamConnection used
          * to release local stream connection i.e socket
          * Used in: socketOnUnpublishMe
          * */

    const getVcxRtcConnectionOptions = (stream, options, isRemote) => {
        const connectionOpts = {
            callback(message) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('Sending message', message);
                that.socket.sendSDP('signaling_message', {
                    streamId: stream.getID(),
                    msg: message,
                    browser: stream.pc.browser,
                }, undefined, () => { });
            },
            nop2p: true,
            audio: options.audio && stream.ifAudio(),
            video: options.video && stream.ifVideo(),
            maxAudioBW: options.maxAudioBW,
            maxVideoBW: options.maxVideoBW,
            limitMaxAudioBW: spec.maxAudioBW,
            limitMaxVideoBW: spec.maxVideoBW,
            iceServers: that.iceServers,
            forceTurn: stream.forceTurn,
        };
        if (!isRemote) {
            connectionOpts.simulcast = options.simulcast;
        }
        return connectionOpts;
    };
    const checkAndProcessStreamsHealth = () => {
      if (that.state != CONNECTED || !that.allStreamsActive){
        return;
      }
      remoteStreams.forEach((stream, id) => {
        if (that.state == CONNECTED && stream.state == 'connected'){
          let health = checkStreamState(stream);
          if (!health.audio || !health.video) checkWaitReconnectStream(stream, 'add', (result)=> { });
        }
      });
      localStreams.forEach((stream, id) => {
        if (that.state == CONNECTED && stream.state == 'connected'){
          //console.log (" checking stream state: id " + stream.getID());
          let health = checkStreamState(stream);
          if (!health.audio  || !health.video){
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream state: id " + stream.getID() + " health: " + JSON.stringify(health));
            if (!stream.ifScreen() && !stream.ifCanvas()){
              if (!health.audio){
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream state: id " + stream.getID() + "  mute/unmute audio track " );
                stream.muteAudio( (resp) => {stream.unmuteAudio((resp) => {
                  if (resp.result !== __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                      that.dispatchEvent({ type: 'stream-audio failed', stream });}},false);
                }, false);
              }
              if (!health.video){
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream video health bad : id " + id + "  mute/unmute video track " );
                stream.muteVideo((resp) => {
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream id " + id + " mute callback resp: " + JSON.stringify(resp));
                  stream.unmuteVideo((umuteResp) => {
                    if (umuteResp.result !== __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream id " + id + " unmute callback resp: " + JSON.stringify(umuteResp));
                      that.dispatchEvent({ type: 'stream-video failed', stream });}},false);
                }, false);
              }
            }else {
              let eventType = stream.ifScreen()  ? " stream-screen failed " : " stream-canvas failed";
              that.dispatchEvent({ type: eventType, stream });
            }
          }else {
            //console.log (" stream state check true : id " + stream.getID());
          }
        }
      });
    }

    const checkStreamState = (stream) => {
      let result = {audio: true, video:true};
      if(stream){
        const checkTrackState = (mediaStream, audioTrack, checkMutedField, mutedTimeoutSecs) => {
          let tracks, tracksInfo;
          if (stream.tracksInfo == undefined) stream.tracksInfo = {audio:{numSecsMuted:0},video:{numSecsMuted:0}};
          if(audioTrack){
            tracks =  mediaStream.getAudioTracks();
            tracksInfo = stream.tracksInfo.audio;
          }else {
            tracks = mediaStream.getVideoTracks();
            tracksInfo = stream.tracksInfo.video;
          }
          let trackState = "NA";
          for(const track of tracks) {
            if(track.enabled === true){
              if (track.readyState === 'live'){
                if(!checkMutedField || !track.muted){
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug("Track ready  id: " + stream.getID() + " - " + track.kind );
                  if (tracksInfo.numSecsMuted) tracksInfo.numSecsMuted = 0;
                  trackState = "ACTIVE";
                }else if (++tracksInfo.numSecsMuted < mutedTimeoutSecs){
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("Track ready but muted ,wait timeout id: " + stream.getID() + " - " + track.kind +
                               "num secs muted: " + tracksInfo.numSecsMuted);
                }else {
                  trackState = "INACTIVE";
                  tracksInfo.numSecsMuted = 0;
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("Track not ready - muted with timeout restarting id: " + stream.getID() + " - " + track.kind +
                               " num secs muted: " + tracksInfo.numSecsMuted);
                }
              } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("Track not ready id : " + stream.getID() + " - " + track.kind + " state: " + track.readyState);
                tracksInfo.numSecsMuted = 0;
                trackState = "INACTIVE";
              }
            }else {
              __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug("Track not ready  and not enabled : id " + stream.getID() + " - " + track.kind );
            }
          }
          return trackState;
        }
        let checkVideoMuted = false;
        let checkAudioMuted = false;
        let checkPlayerPause = false;
        let streamTrackState, mutedTimeoutSecs = stream.ifScreen() ? 10 : 3;
        if (!stream.local ){
          if (!stream.ifCanvas() && !stream.ifScreen()){
            let at = that.activeTalkerList.get(stream.getID());
            if (at){
              switch(at.mediatype){
              case 'audiovideo':
                checkAudioMuted = true; checkVideoMuted = true; checkPlayerPause = true;
              break;
              case 'video':
                checkVideoMuted = true; checkPlayerPause = true;
              break;
              case 'audio':
              case 'audioOnly':
                checkAudioMuted = true; checkPlayerPause = true;
              break;
              }
            }
          }else if (stream.ifScreen()){
            if(that.shareStatus && !that.isSharingClient){
               checkVideoMuted = true;
              let shareDisplay = false, reason = 'stream miss';
              if (stream.player && stream.player.video && stream.player.video.srcObject && stream.stream){
                const vidPlayerStrmTracks =  stream.player.video.srcObject.getVideoTracks();
                const vidStreamTracks = stream.stream.getVideoTracks();
                if (vidPlayerStrmTracks[0].id == vidStreamTracks[0].id) shareDisplay = true;
                else reason = 'mismatch';
              }else if (!stream.player || ! stream.player.video || !stream.player.video.srcObject) reason = 'player missing';
              if (!shareDisplay ){
                if (that.shareDisplayWaitTimeoutSecs >= 3 ) {
                  result.video = false;
                  that.shareDisplayWaitTimeoutSecs = 0;
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("checkStreamState() failed shareDisplayTimeoutSecs: " +
                                 that.shareDisplayWaitTimeoutSecs + reason);
                  return result;
                }
                that.shareDisplayWaitTimeoutSecs++;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("checkStreamState() shareDisplayTimeoutSecs: " + that.shareDisplayWaitTimeoutSecs + reason);
              }else if (that.shareDisplayWaitTimeoutSecs) that.shareDisplayWaitTimeoutSecs = 0;
            }
          }
          //else if (that.canvasStatus && !that.isCanvasSharingClient) checkVideoMuted = true;
          if (stream.stream) {
            if (checkPlayerPause && (!stream.player || !stream.player.video || stream.player.video.paused)){
              if (++stream.numSecsPlayerPaused < 5){
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("stream player paused wait timeout id: " + stream.getID() +
                         "num secs track player paused: " + stream.numSecsPlayerPaused);
              }else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("stream player paused timeout restarting id: " + stream.getID() +
                             "num secs track player paused: " + stream.numSecsPlayerPaused);
                result.audio = false; result.video = false;
                stream.numSecsPlayerPaused = 0;
                return result;
              }
            }else if (stream.numSecsPlayerPaused) stream.numSecsPlayerPaused =0;

            result.audio =
              checkTrackState(stream.stream, true, checkAudioMuted, mutedTimeoutSecs) != "INACTIVE";
            result.video =
              (checkTrackState(stream.stream, false, checkVideoMuted, mutedTimeoutSecs)) != "INACTIVE";
            if (result.video && that.isStreamingClient){
              if (stream.player && stream.player.video){
                let elm = stream.player.video;
                if (elm.player_stats){
                  if ((elm.getVideoPlaybackQuality().creationTime - elm.player_stats.creationTime) > 3000){
                    if (elm.getVideoPlaybackQuality().totalVideoFrames > elm.player_stats.totalVideoFrames){
                      //console.log ( );
                    }else {
                      console.error(" video player stats stopped : frames prev: " + elm.player_stats.totalVideoFrames +
                                    " new: " + elm.getVideoPlaybackQuality().totalVideoFrames );
                      let err =  { streamId: stream.getID(), currTotalFrames: elm.getVideoPlaybackQuality().totalVideoFrames,
                                    prevTotalFrames: elm.player_stats.totalVideoFrames};
                      __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_player_failed, { error: err });
                    }
                  }
                }
              }
            }
          }
        }else {
          if (stream.audioStream)
            result.audio = checkTrackState(stream.audioStream, true, (!stream.ifCanvas() && !stream.ifScreen()),
                                           mutedTimeoutSecs);
          if (stream.videoStream)
            result.video = checkTrackState(stream.videoStream,false, (!stream.ifCanvas()),mutedTimeoutSecs);
        }
      }
      return result;
    };

    const createRemoteStreamVcxRtcConnection = (streamInput, options) => {
        const stream = streamInput;
        stream.pc = that.Connection.buildPair(getVcxRtcConnectionOptions(stream, options, true));
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Create remote connection for subscribe:-${JSON.stringify(options)}`);
        stream.pc.onaddstream = dispatchStreamSubscribed.bind(null, stream);
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("Registering the peer connection timer for the subscriber stream " + stream.getID());
        //setTimeout(checkStreamState, 10000, stream);
        const handleConnectionStateChange = (state, source) => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug (" stream state ICE remote id - " + stream.getID() + " : " + state + " source: " + source);
           // if (state === 'failed' || (state === 'disconnected' && source == "pc")) {
            if (state === 'failed') {
                stream.reconnect = false;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(source + " connection state failed - streamId: " + stream.getID());
                onStreamFailed(stream);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_ice_failed, { error: {} });
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('stream ID', stream.getID());
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('ice connection state', state);
                if (state === 'connected') {
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("ice connection state connected - streamId : " + stream.getID());
                  __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_ice_success, { message: 'ICE connected successfully' });
                  if (stream.reconnect){
                    stream.reconnect = false;
                    stream.reconnectAttempt = 0;
                    let atEntry = playerATList.get(stream.getID());
                    if (atEntry){
                      if (atEntry.mediatype != 'none'){
                        let atInfo = JSON.parse(JSON.stringify(atEntry));
                        atInfo.mediatype = 'none'
                        stream.reloadPlayer(atInfo, avOptions.subscribe.imageOnVideoMute);
                      }
                      stream.reloadPlayer(atEntry, avOptions.subscribe.imageOnVideoMute);
                    }else {
                      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream state ICE remote id - " + stream.getID() + " : ICE reconnected ");
                    }
                  }
                }
            }
        };
        stream.pc.oniceconnectionstatechange = (state) => { handleConnectionStateChange(state,"ice");};
        stream.pc.onconnectionstatechange = (state) => {handleConnectionStateChange(state, "pc")};

        stream.pc.createOffer(true);
    };
    const checkWaitReconnectStream = (stream, op, callback =()=>{}) => {
      if ((that.socket.state == DISCONNECTED) || (that.reconnectionState === true)) {
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("checkWaitReconnectStream() room/socket not connected id : " + stream.getID() +
                         " recon state: " + that.reconnectionState);
          callback (false);
      }
      if (op == 'add'){
        if (stream.state !== 'connected') {
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("checkWaitReconnectStream() invalid state - stream id : " + stream.getID() + " state: " + stream.state);
          callback (false);
          return;
        }
        if (stream.reconnectAttempt >= MAXRECONNECTIONATTEMPT){
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("checkWaitReconnectStream() reconnect retries exceed - global reconnect stream id: " + stream.getID());
          if (that.state == CONNECTED) that.socket.disconnect();
          callback (false);
          return;
        }
        stream.reconnect = true;
        stream.state = 'wait_for_reconnect';
        if (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.device_type == 'mobile'){
          let queueReq = Object.keys(reconnectStreamIds.local).length || Object.keys(reconnectStreamIds.remote).length;
          if (stream.local){
            if (!stream.ifCanvas() && !stream.ifScreen()) reconnectStreamIds.local.main = stream;
            else if (stream.ifScreen()) reconnectStreamIds.local.screen = stream;
            else if (stream.ifCanvas()) reconnectStreamIds.local.canvas = stream;
          }else reconnectStreamIds.remote[stream.getID().toString()] = stream;
          if (queueReq){
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning ("reconnectStream() queue > 1 waiting id: " + stream.getID() +
                            " len loc: " + Object.keys(reconnectStreamIds.local).length + ' rem: ' +
                            Object.keys(reconnectStreamIds.remote).length);
            callback (true);
            return;
          }
        }
        if (!numStreamsReconnecting){
          numStreamsReconnecting ++;
          that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({type: 'network-reconnecting',message:'Connection issues - reconnecting, please wait'}));
        }
        reconnectStream(stream, (result)=> {
          if (result === false){
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("checkWaitReconnectStream () failed streamId: " + stream.getID(),
                          (that.state == CONNECTED ? " global reconnect" : "room not connected ignoring "));
            if (that.state == CONNECTED) that.socket.disconnect();
          }
          callback (result);
        });
      }else if (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.device_type == 'mobile'){
        if (stream.local) {
          if (!stream.ifCanvas() && !stream.ifScreen()){
            if (reconnectStreamIds.local.main) delete reconnectStreamIds.local.main;
          }else if (stream.ifScreen()){
            if (reconnectStreamIds.local.screen) delete reconnectStreamIds.local.screen;
          }else {
            if (reconnectStreamIds.local.canvas) delete reconnectStreamIds.local.canvas;
          }
        }else {
          if (reconnectStreamIds.remote[stream.getID().toString()]) delete reconnectStreamIds.remote[stream.getID().toString()];
        }
        let reconnects =0;
        for(let key in reconnectStreamIds.local){
          if (reconnectStreamIds.local[key].state == 'wait_for_reconnect'){
            reconnectStream(reconnectStreamIds.local[key], callback);
            reconnects++;
            break;
          }
        }
        if (!reconnects){
          for(let key in reconnectStreamIds.remote){
            if (reconnectStreamIds.remote[key].state == 'wait_for_reconnect'){
              reconnectStream(reconnectStreamIds.remote[key], callback);
              reconnects++;
              break;
            }
          }
        }
        if (!reconnects) {
          if (numStreamsReconnecting == 1) that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({type: 'network-reconnected'}));
          callback(true);
        }
        if (numStreamsReconnecting) numStreamsReconnecting--;
      }
    }
    const reconnectStream =  (stream, callback =()=>{}) => {
      stream.state = 'reconnecting';
      stream.reconnectAttempt++;
      stream.reconnectsTotal +=1;
      let info = that.remoteStreamsInfo.get(stream.getID());
      let inputOptions = info ? info.userReqOpt: undefined;
      let cmd = "none";
      let timer = setTimeout(()=> {
       __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("reconnectStream() fail timeout stream local: " + stream.local + " id: " + stream.getID() + " cmd: " + cmd);
       callback (false);
      }, 3000);
      if (stream.local){
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnectStream()  streamId: ' + stream.getID() + ' calling unpublish()');
        cmd = "unpublish";
        that.unpublish(stream, (result, error) => {
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnectStream()  streamId: ' + stream.getID() + ' unpublish callback calling publish()');
          cmd = "publish";
          that.publish(stream, inputOptions, () => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnectStream()  streamId: ' + stream.getID() + ' publish callback');
            cmd = "publish-done";
            clearTimeout(timer);
            callback (true);
          });
        });
      }else {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnectStream()  streamId: ' + stream.getID() + ' calling unsubscribe()');
          cmd = "unsubscribe";
        that.unsubscribe(stream, (result, error) => {
          cmd = "subscribe";
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnectStream()  streamId: ' + stream.getID() + ' unsubscribe callback calling publish()');
          that.subscribe(stream,inputOptions, () => {
          cmd = "subscribe-done";
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnectStream()  streamId: ' + stream.getID() + ' subscribe callback');
            clearTimeout(timer);
            callback (true);
          });
        });
      }
    };
    that.reconnectStream = (stream, callback=()=>{}) =>{
      checkWaitReconnectStream(stream, 'add', callback);
    }

    that.notifyDeviceUpdate = () => {
        let options = {mic: true, cam:true, speaker:false};
        localStreams.forEach((stream, id) => {
          if (!stream.ifScreen() && !stream.ifCanvas()){
            options.mic = stream.audio;
            options.cam = stream.video;
          }
        });
        __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].mediaDeviceUpdate(options, 'room_notifyDeviceUpdate',(devices) => {
            that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'user-media-device-list-change', message: devices }));
        });
    };

    const createLocalStreamVcxRtcConnection = (streamInput, pubOptions) => {
        const stream = streamInput;
        let options = Object.assign(pubOptions);
        if (!stream.audio) options.audio = false;
        stream.pc = that.Connection.buildPair(getVcxRtcConnectionOptions(stream, options));
        if (stream.audioStream) {
            for (const track of stream.audioStream.getAudioTracks()) {
                stream.pc.addTrack(track);
            }
        }
        let videoSource = (stream.ifCanvas() || stream.ifScreen()) ? stream.videoStream :
                          stream.inputMediaSource.video[stream.inputMediaSource.video.selected];
        if (videoSource) {
            for (const track of videoSource.getVideoTracks()) {
                stream.pc.addTrack(track);
            }
        }

        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("Registering the peer connection timer for the subscriber stream " + stream.getID());
        //setTimeout(checkStreamState, 10000, stream);
        const handleConnectionStateChange = (state, source) => {
            let streamType = stream.ifCanvas() ? "canvas" : stream.ifScreen() ? "screen" : "main";
            //if (state === 'failed' || (state === 'disconnected' && source == "pc")) {
            if (state === 'failed') {
              stream.reconnect = false;
              __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error (" stream state  local  " + streamType + " : " + state +
                            " source: " + source + " reconnect: " + stream.reconnect);
                onStreamFailed(stream);
            }else if (state === 'connected'){
              stream.reconnect = false;
              stream.reconnectAttempt = 0;
              __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(" stream state local  " + streamType + " : " + state + " source: " + source);
            }
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('handleConnectionStateChange state:', state);
        };
        stream.pc.oniceconnectionstatechange = (state) => { handleConnectionStateChange (state, "ice");};
        stream.pc.onconnectionstatechange = (state) => { handleConnectionStateChange (state, "pc");};

        if (!options.createOffer) { stream.pc.createOffer(); }
    };

    // We receive an event with a new stream in the room.
    // type can be "media" or "data"

    const socketOnAddStream = (arg) => {
        const stream = Object(__WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */])(that.Connection, {
            streamID: arg.id,
            local: false,
            clientId: arg.clientId,
            audio: arg.audio,
            video: arg.video,
            data: arg.data,
            screen: arg.screen,
            attributes: arg.attributes,
        });
        stream.room = that;
        remoteStreams.add(arg.id, stream);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])({ type: 'stream-added', stream });
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: ('socketOnAddStream - stream added') });
        that.dispatchEvent(evt);
    };

    const socketOnRemoveTrack = (arg) => {
        const streamID = arg.id.streamId;
        const updatedSTream = Object(__WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */])(that.Connection, { streamID });
        videoStop(streamID);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'track-removed', streams: [updatedSTream], message: `tracked removed from stream: ${streamID}` });
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: ('socketOnRemoveTrack - tracked removed from stream') });
        that.dispatchEvent(evt);
    };

    const userConnect = (arg) => {
        const userName = arg.name;
        const userRole = arg.role;
        const userPermissions = arg.permissions;
        const user = {
            name: arg.name,
            permissions: arg.permissions,
            role: arg.role,
            user_ref: arg.user_ref,
            videoMuted: arg.videoMuted,
            audioMuted: arg.audioMuted,
        };
        user.audioEnabled = arg.audioEnabled != undefined ? arg.audioEnabled : true;
        user.videoEnabled = arg.videoEnabled != undefined ? arg.videoEnabled : true;
        if (arg.data != undefined) user.data = arg.data;
        if(arg.role != "audience") {
            that.userList.set(arg.clientId, user);
        }
        // Update audience count for each particupant in room on audience connection.
        if(arg.role == "audience") {
            that.audienceCount = arg.audienceCount? arg.audienceCount : 0;
        }
        let numActiveATSubs = user.numActiveATSubs ? user.numActiveATSubs : that.userList.size;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("user connected event: numActiveATSubs: " + numActiveATSubs + " user.numActiveATSubs: " +
                          user.numActiveATSubs + "userList.size: "  + that.userList.size + " numATSubscribersAdded: " +
                        numATSubscribersAdded + " remotePendingStreams: " + remotePendingStreams.size());
        if (numActiveATSubs > numATSubscribersAdded && remotePendingStreams.size() ){
          let streamId = numATSubscribersAdded+1;
          let stream = remotePendingStreams.get(streamId);
          if (stream){
            remotePendingStreams.remove(streamId);
            remoteStreams.add(streamId, stream);
            numATSubscribersAdded = streamId;
            subscribeVcxRtc(stream, stream.userRequestOptions, ()=>{});
          }else{
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("susbcribe failed user connected stream not found streams id: "  + (numATSubscribersAdded+1) +
                          " numActiveATSubs: " + numActiveATSubs + " First: " + remotePendingStreams.get(streamId) +
                        " second: " + remotePendingStreams.get(streamId.toString()));
          }
        }
        if (that.awaitedParticipants.get(arg.clientId)) {
            that.awaitedParticipants.delete(arg.clientId);
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("userConnected() user name: " + userName);
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_room_user_connect_success, { message: ('userConnect - user connected') });
        let userInfo = {type: 'user-connected' ,clientId: arg.clientId};
        if (!that.privacyModes || !that.privacyModes.userListHidden || that.me.role === 'moderator'){
          userInfo.name = userName; userInfo.role = userRole; userInfo.permission = userPermissions; userInfo.user = user; userInfo.user_ref = user.user_ref; if(user.data != undefined) { userInfo.data = user.data; }
        }
        that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])(userInfo));
    };
    const userUpdate = (arg) => {
      let user = that.userList.get(arg.clientId);
      if (user && (!that.privacyModes || !that.privacyModes.userListHidden || that.me.role === 'moderator')){
        if (arg.key == "media-modes"){
          if (arg.info != undefined && arg.info.publish != undefined){
            if (user.audioEnabled != arg.info.publish.audio){
              user.audioEnabled = arg.info.publish.audio;
              let evntType = user.audioEnabled ? 'user-audio-enabled' : 'user-audio-disabled';
              that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: evntType, clientId: arg.clientId }));
            }
            if (user.videoEnabled != arg.info.publish.video) {
              user.videoEnabled = arg.info.publish.video;
              let evntType = user.videoEnabled ? 'user-video-enabled' : 'user-video-disabled';
              that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: evntType, clientId: arg.clientId }));
            }
          }else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('userUpdate() failed - filed missing for media-modes : ' + JSON.stringify(arg));
        }else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('userUpdate() failed - invalid key : ' + JSON.stringify(arg));
      }else if (user == undefined )__WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('userUpdate() failed - user not found : ' + JSON.stringify(arg));
      else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('userUpdate() failed - privacy policy userList hidden enabled');
    };

    const userDisConnect = (arg) => {
        const userName = arg.name;
        const userRole = arg.role;
        const userPermissions = arg.permissions;
        const clientId = arg.clientId;
        const user_ref = arg.user_ref;
        const data = arg.data;
        if(userRole != "audience"){
            that.userList.delete(arg.clientId);
        }
        // Decrement audience count on audience disconnection
        if(arg.role == "audience"  && that.audienceCount && that.audienceCount > 0) {
            that.audienceCount--;
        }
        //commented to handle streaming client disconnecting issues, streaming client will be disconnected by server
        /*if ((that.isStreamingClient === true) && (that.userList.size === 0)) { // checking userList.size = 0 because streaming client won't be included in userList
            Logger.info('S.T. Client :true  and all users have disconnected');
            onRoomDisconnected('streaming-client-disconnect');
        }*/
        if (that.mode === 'lecture' && that.me.role === 'moderator'){
          checkAndRemoveGrantedFloor(clientId);
        }
        const userEvt = {
            type: 'user-disconnected', name: userName, clientId, role: userRole, permission: userPermissions,
        };
        userEvt.user_ref = user_ref;
        if(data != undefined) userEvt.data = data;
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])(userEvt);
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_room_user_disconnect_success, { message: ('userDisConnect - user disconnected') });
        that.dispatchEvent(evt);
    };

    const userSubcribe = (arg) => {
        const userName = arg.name;
        const userRef = arg.user_ref;
        const userRole = arg.role;
        const socket = arg.socket;
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* PublisherEvent */])({
            type: 'user-subscribed', name: userName, role: userRole, user_ref: userRef, socket,
        });
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: ('userSubcribe - user subscribed') });
        that.dispatchEvent(evt);
    };

    const userUnSubcribe = (arg) => {
        const userName = arg.name;
        const userRef = arg.user_ref;
        const userRole = arg.role;
        const socket = arg.socket;
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["d" /* PublisherEvent */])({
            // @todo - should not it be user-unsubscribed
            type: 'user-subscribed', name: userName, role: userRole, user_ref: userRef, socket,
        });
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: ('userUnSubcribe - user unsubscribed') });
        that.dispatchEvent(evt);
    };

    const videoStop = (id) => {
        const screenSaver = __WEBPACK_IMPORTED_MODULE_5__views_Element__["a" /* default */].getById(`screen_saver_${id}`);
        const playBtn = __WEBPACK_IMPORTED_MODULE_5__views_Element__["a" /* default */].getByClass('icon_play', screenSaver.parentNode);
        playBtn.disabled = true;
        if (screenSaver && screenSaver.style.display === 'none') {
            screenSaver.style.display = 'block';
        } else if (screenSaver && screenSaver.style.display === 'block') {
            screenSaver.style.display = 'none';
        }
    };

    const socketOnVcxRtcMessage = (arg) => {
        let stream;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug (" socketOnVcxRtcMessage() arg: " + JSON.stringify(arg));
        if (arg.peerId) {
            stream = remoteStreams.get(arg.peerId);
        } else {
            stream = localStreams.get(arg.streamId);
        }

        if (stream && !stream.failed && stream.pc) {
            stream.pc.processSignalingMessage(arg.msg, that.mediaConfiguration);
            if (arg.msg && (typeof arg.msg === 'object') && (arg.msg.type === 'ready')) {
                if (stream.local) {
                    discardLocalStreamForReconnect (stream.ifScreen(), stream.ifCanvas());
                    if (stream.ifCanvas() || stream.ifScreen()) {
                      setMediaConnectionTimer (false,stream.getID(), true);
                      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stream state local ' + (stream.ifCanvas() ? 'canvas' : 'screen') + ' ready');
                    }else{
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream state local main: ready");
                        //if (that.mute && that.me.role === 'participant') {}
                        let raiseEvent = true;
                        let audioInfo = {local: false, hard: false,eventInfo: undefined};
                        let videoInfo = {local: false, hard: false,eventInfo: undefined};

                        // hard-mute-room event not sending to app as  room mute sent in room-connected event
                        if (that.muteInfo.stream.hard.audio && !that.hardMuteInitiator) audioInfo.hard |= true;

                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("streamId: " + stream.getID() + " local cam Publish ready state");
                        if (that.videoMuteOnJoin != undefined) {
                          videoInfo.local |= that.videoMuteOnJoin.local;
                          videoInfo.hard |= that.videoMuteOnJoin.hard;
                          //raiseEvent = false;
                          delete that.videoMuteOnJoin;
                        }
                        if (that.audioMuteOnJoin != undefined) {
                          audioInfo.local |= that.audioMuteOnJoin.local;
                          audioInfo.hard |= that.audioMuteOnJoin.hard;
                          //raiseEvent = false;
                          delete that.audioMuteOnJoin;
                        }
                        audioInfo.local |= stream.config.audioMuted;
                        videoInfo.local |= stream.config.videoMuted;
                        if (stream.video == false) videoInfo = { local: false, hard: false};
                        if (stream.audio == false) audioInfo = { local: false, hard: false};
                        mediaDeviceMuteOnJoin(stream, audioInfo, videoInfo, raiseEvent);
                        if (stream.config.audioMuted ) stream.config.audioMuted = false;
                        if (stream.config.videoMuted ) stream.config.videoMuted = false;
                    }
                }else {
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" stream state remote id - " + stream.getID() + " : ready");
                }
                stream.onConnectionStateChanged(true);
                checkWaitReconnectStream(stream, 'del');
            } else if (that.speakerInfo.id != undefined) {
                stream.setSpeaker(that.speakerInfo.id);
            }
        }else {
          let errMsg = " id: " ;
          if (arg.peerId != undefined) errMsg += arg.peerId;
          else if (arg.streamId != undefined) errMsg += arg.streamId;
          else errMsg += "undefined "
          errMsg += " err: " ;
          if (!stream) errMsg += "stream not found";
          else if(stream.failed) errMsg += "stream failed true ";
          else errMsg += "stream PC  null";
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("socketOnVcxRtcMessage(), Failed " + errMsg + " arg: " + JSON.stringify(arg));
        }
    };

    const socketOnPeerMessage = (arg) => {
        let stream = localStreams.get(arg.streamId);

        if (stream && !stream.failed) {
            stream.pc.get(arg.peerSocket).processSignalingMessage(arg.msg);
        } else {
            stream = remoteStreams.get(arg.streamId);
            stream.pc.processSignalingMessage(arg.msg);
        }
    };

    const socketOnPublishMe = (arg) => {
        const myStream = localStreams.get(arg.streamId);
    };

    const socketOnUnpublishMe = (arg) => {
        const myStream = localStreams.get(arg.streamId);
    };

    const socketOnSelfBandwidthAlert = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('Received SocketOnSelfBandwidthAlert', JSON.stringify(arg));
        if (arg.message === 'SubscriberBandWidth') {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-bandwidth-alert', message: arg.bandwidth });
            that.dispatchEvent(evt);
        } else {
            localStreams.forEach((stream, id) => {
                if (arg.bandwidth === 1) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('mute publisher video due to low bandwidth');
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_low_bandwidth_update,
                        { message: ('socketOnSelfBandwidthAlert - muted publisher video due to low bandwidth') });
                    stream.muteVideo();
                } else {
                    if (arg.message === 'ShareBandwidth' && stream.screen) {
                        stream.setVideoParamsRange(arg.bandwidth, undefined, undefined, undefined, true);
                    } else if (arg.message === 'PublisherBandwidth' && !stream.screen) {
                        localVideoStreamATStateBw = arg.bandwidth;
                        stream.setVideoParamsRange(arg.bandwidth, undefined, undefined, undefined, true);
                    }
                }
            });
        }
    };


    const socketOnBandwidthEvents = (arg) => {
        if (arg.id === 'bw-alert') {
            socketOnBandwidthAlert(arg.msg);
        } else if (arg.id === 'publisher-bw' || arg.id === 'share-bw') {
            socketOnSelfBandwidthAlert(arg.msg);
        } else {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.id, message: arg.msg });
            that.dispatchEvent(evt);
        }
    }

    const socketOnBandwidthAlert = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('OnbandwidthAlert:', arg);
        for (let i = 0; i < arg.length; i++) {
            const stream = that.remoteStreams.getAll()[arg[i].streamId];
            if (stream == null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stream not found');
                continue;
            }
            stream.setBandwidthAlert(arg[i]);
        }
    };

    // We receive an event of new data in one of the streams
    const socketOnDataStream = (arg) => {
        if (!that.activeTalker) {
            const stream = remoteStreams.get(arg.id);
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])({ type: 'stream-data-in', msg: arg.msg, stream });
            stream.dispatchEvent(evt);
        } else if ((that.eventsList && that.eventsList !== undefined) && ('message-received' in that.eventsList)) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'message-received', message: arg.msg });
            that.dispatchEvent(evt);
        } else {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'active-talker-data-in', message: arg.msg });
            that.dispatchEvent(evt);
        }
    };

    // method to inject file share UI in any given element
    // to do set position , style , UI configurable
    const inFileShareUI = (dat, elToAppend, command, style) => {
        const fsInfoContainer = document.createElement('div');
        fsInfoContainer.setAttribute('id', `fs-notif-id-${Math.random()}`);
        fsInfoContainer.setAttribute('class', 'fs-notification');
        fsInfoContainer.setAttribute('style', 'display:block;position:relative;z-index:3;padding:5px 10px;top:50%;right:50%;transform:translateX(50%);background:rgba(0,0,0,0.29);border-radius:5px;color:rgb(255,255,255)');
        elToAppend.appendChild(fsInfoContainer);
        elToAppend = fsInfoContainer;
        let minfo;
        let fileInfo;
        let br;
        let text;

        switch (command) {
            case 'fs-upload-init':
                minfo = `upload started for file ${dat.data[dat.data.length - 1].name} of size ${dat.data[dat.data.length - 1].size / 1000} KB`;
                fileInfo = dat.message;
                br = document.createElement('br');
                elToAppend.appendChild(br);
                text = document.createTextNode(minfo);
                elToAppend.appendChild(text);
                elToAppend.appendChild(br);
                break;

            case 'fs-file-uploaded':
                minfo = `uploaded 100 % ${dat.name}  of size ${dat.size / 1000} KB`;
                fileInfo = dat.message;
                br = document.createElement('br');
                elToAppend.appendChild(br);
                text = document.createTextNode(minfo);
                elToAppend.appendChild(text);
                elToAppend.appendChild(br);
                break;

            case 'fs-upload-started':
                minfo = `${dat.sender} is sharing file ${dat.message.data[(dat.message.data.length - 1)].name}  of size ${dat.message.data[(dat.message.data.length - 1)].size / 1000} KB`;
                fileInfo = dat.message;
                br = document.createElement('br');
                elToAppend.appendChild(br);
                text = document.createTextNode(minfo);
                elToAppend.appendChild(text);
                elToAppend.appendChild(br);
                break;

            case 'fs-file-available':
                fileInfo = dat.message;
                br = document.createElement('br');
                elToAppend.appendChild(br);
                const btn = document.createElement('BUTTON');
                const t = document.createTextNode(fileInfo.name);
                btn.setAttribute('style', 'color:red;font-size:23px');
                btn.setAttribute('id', shFileList.length - 1);
                btn.appendChild(t);
                elToAppend.appendChild(btn);
                btn.onclick = function () {
                    //    that.recvFileWithUrl(btn.id);
                    that.recvFiles(btn.id);
                };
                elToAppend.appendChild(br);
                break;

            default:
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('random data to fantom UI ');
        }
    };

    /**
 * socketOnDataStreamToRoom method bind to socket
 */
    const socketOnDataStreamToRoom = (dat, callback) => {
        let msgType;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('socketOnDataStreamToRoom', dat.type);
        switch (dat.type) {
            case 'chat':
                msgType = 'message-received';
                break;

            case 'data-internal-in':
                msgType = dat.message.type;
                processInternalDataIn(dat, callback);
                break;

            default:
                msgType = 'user-data-received';
        }

        if (that.eventsList && (msgType in that.eventsList)) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: msgType, message: dat });
            that.dispatchEvent(evt);
            if (callback) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
            }
        } else if (callback) {
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1169);
        }
    };

    const processInternalDataIn = (dat, callback) => {
        //  Logger.info('intenral  data received', dat);
        switch (dat.message.type) {
            case 'fs-upload-started': /// file is being shared with you
                dat.message.broadcast = dat.broadcast;
                dat.message.sender = dat.sender;
                dat.message.senderId = dat.senderId;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file is being shared with you fs-upload-started', dat.message);
                if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                    inFileShareUI(dat, document.getElementById(fileShareUI.recvElToAppend), 'fs-upload-started');
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_download_success, { error: {} });
                }
                break;

            case 'fs-file-available':
                // file is available  to dowmload
                dat.message.broadcast = dat.broadcast;
                dat.message.sender = dat.sender;
                dat.message.senderId = dat.senderId;
                shFileList.push(dat.message);

                const favailable = {
                    broadcast: dat.broadcast,
                    sender: dat.sender,
                    senderId: dat.senderId,
                    name: dat.message.name,
                    size: dat.message.size,
                    speed: dat.message.speed,
                    createdAt: dat.message.createdAt,
                    dlimit: dat.message.dlimit,
                    time: dat.message.time,
                    expiresAt: dat.message.expiresAt,
                    timeLimit: dat.message.timeLimit,
                    index: shFileList.length - 1,
                };

                that.availableFiles.push(favailable);
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('file is available for download fs-file-available name: ' + favailable.name + ' id: ' + (favailable.id ? favailable.id : "undefined"));
                const fDownloadResult = {
                    messageType: 'download-available',
                    result: 0,
                    description: 'file-available',
                    response: {
                        downloadStatus: 'available',
                        jobId: favailable.index,
                        downloadInfo: favailable,
                    },
                };
                const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
                that.dispatchEvent(evt);

                if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                    inFileShareUI(dat, document.getElementById(fileShareUI.recvElToAppend), 'fs-file-available');
                }
                break;

            case 'fs-upload-cancelled':
                break;

            default:
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('unknown internal data type from signaling server ', dat.type);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_download_failed, { error: {} });
                break;
        }
    };

    // We receive an event of new data in one of the streams
    const socketOnUpdateAttributeStream = (arg) => {
        const stream = remoteStreams.get(arg.id);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])({
            type: 'stream-attributes-updated',
            attrs: arg.attrs,
            stream,
        });
        stream.updateLocalAttributes(arg.attrs);
        stream.dispatchEvent(evt);
    };

    // We receive an event of a stream removed from the room
    const socketOnRemoveStream = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('socketOnRemoveStream() stream id to remove: ' + arg.id );
        let stream = localStreams.get(arg.id);
        if (stream) {
            onStreamFailed(stream);
            return;
        }

        stream = remoteStreams.get(arg.id);
        if (stream) {
            remoteStreams.remove(arg.id);
            removeStream(stream);
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])({ type: 'stream-removed', stream });
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: ('socketOnRemoveStream - stream removed') });
            that.dispatchEvent(evt);
        }
    };

    // The socket has disconnected
    const socketOnDisconnect = () => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Socket disconnected, lost connection to Signalling Server, room state: ' + that.state);
        if (that.state !== DISCONNECTED && that.state !== DISCONNECTING) {
            that.breakOutRoom.disconnectAll();
            validateProcessNetworkTimeout(false,false);
            //clearAll();
        }
    };

    const socketOnICEConnectionFailed = (arg) => {
        let stream;
        if (!arg.streamId) {
            return;
        }
        const message = `ICE Connection Failed on ${arg.type} ${arg.streamId} ${that.state}`;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(message);
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_ice_failed, { arg });

        if (arg.type === 'publish') {
            stream = localStreams.get(arg.streamId);
        } else {
            stream = remoteStreams.get(arg.streamId);
        }
        onStreamFailed(stream, message);
    };

    const socketOnError = (e) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Cannot connect to client Controller setting timer ');
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event',__WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, {message: ('socketOnError - Cannot connect to signalling') });
        socketErrorTimer = setTimeout(()=>{
          socketErrorTimer = undefined;
          if (!that.socket || that.socket.state != that.socket.CONNECTED){
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" socket error timeout socket not connected validateProcessNetworkTimeout()");
            validateProcessNetworkTimeout(false, true);
          } else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" socket error timeout , socket connected, ignoring");
        }, __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.socketErrorTimeoutSecs*1000);
        //that.dispatchEvent(RoomEvent({ type: 'room-error', message: e }));
    };

    const sendDataSocketFromStreamEvent = (evt) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('sendDataSocketFromStreamEvent');
        const stream = evt.stream;
        const msg = evt.msg;
        if (stream.local) {
            socket.sendMessage('sendDataStream', { id: stream.getID(), msg });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('You can not send data through a remote stream');
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: ('sendDataSocketFromStreamEvent - You can not send data through a remote stream') });
        }
    };

    // msg, broadcast, clientList, 'chat', callback
    const validateSendUserData = (msg, broadcast, clients, contentLength, type, callback) => {
        if (!msg || (broadcast === undefined) || (typeof broadcast !== 'boolean') ||
            ((broadcast === false) && (!clients || (!Array.isArray(clients)) || !clients.length)) || (typeof contentLength !== 'number') ){
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('message: invalid parameter, msg/broadcast/clients/contentLength undefined or type mistmatch');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
            return;
        }
        if(contentLength > __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.senduserDataMaximumLimit) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('message: content-length must be <= 2048, entered value : ' + contentLength + ' kB');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1196);
            return;
        }
        that.socket.emitEvent('sendDataStreamToRoom', {msg: msg, broadcast: broadcast, clients: clients, type: type}, callback);
    };

    /* send user data */
    //content-length: User will enter size in kB, and default value will be 100 kB, max. user can enter is 2048 kB (2 MB).
    that.sendUserData = (msg, broadcast, clientList, callback=()=>{}) => {
        let contentLength = 100;
        if(msg['content-length']){
          contentLength = msg['content-length'];
          //Removing content_length key and it's value to prevent unnecessary size increment due to this field.
          delete msg['content-length'];
        }
        if((JSON.stringify(msg).length / 1024) > contentLength) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('message: large data, failed - larger text-data. Max allowed length is ' + contentLength + ' kB');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1195);
            return;
        }
        validateSendUserData(msg, broadcast, clientList, contentLength, 'user_data', callback);
    };

    // manu dummy FT testing
    /* send user data */
    const sendFtData = (msg, type, broadcast, clientList, callback=()=>{}) => {
        msg.type = type;
        validateSendUserData(msg, broadcast, clientList, 0, 'data-internal-in', callback);
    };
    // end

    //Records the transcription and includes this message as well.
    that.recordTranscriptMessage = (msg, callback=()=> {}) => {
        let contentLength = 0;
        if(typeof(msg) == 'string'){
            contentLength = msg.length / 1024;
        } else if(typeof(msg) == 'object'){
            contentLength = JSON.stringify(msg).length / 1024;
        }
        that.socket.emitEvent('sendDataStreamToRoom', {msg: msg, broadcast: false, clients: [], type: 'transcription'}, callback);
    };

    /**
     * Send message to room object
     */
    that.sendMessage = (msg, broadcast, clientList, callback=()=>{}) => {
        let contentLength = 0;
        if(typeof(msg) == 'string'){
            contentLength = msg.length / 1024;
        } else if(typeof(msg) == 'object'){
            contentLength = JSON.stringify(msg).length / 1024;
        }
        validateSendUserData(msg, broadcast, clientList, contentLength, 'chat', callback);
    };

    const validateLayoutData = (layoutOptions, callback = ()=>{}) => {
        var layouts = ['grid', 'talker', 'presenter'];
        var services = ['liveRecording', 'streaming', 'screenShare','all'];
        var service = layoutOptions.service;
        var layout = layoutOptions.layout;
        if(callback == undefined || typeof callback !== 'function') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('message: invalid value for callback parameter');
            return;
        }
        if (that.me.role !== 'moderator') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('User should be a moderator to change layout details.');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168);
            return;
        }

        if (that.state === DISCONNECTED) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Room is disconnected');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7079);
            return;
        }
        if(layout == undefined || typeof layout !== 'string'  || !layouts.includes(layout)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('message: invalid value for layout parameter');
            if (callback) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1192);
            }
            return;
        }
        if(service == undefined || typeof service !== 'string'  || !services.includes(service)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('message: invalid value for service parameter');
            if (callback) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1193);
            }
            return;
        }
        var layoutData = {};
        layoutData.layout = layout;
        layoutData.service = service;

        that.socket.sendParamEvent('sendLayoutData', layoutData, (result, error) => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('sending sendLayoutData');
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error in layout update: ', error);
                callback(error);
                return;
            }
            else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Layout updated successfully.');
                callback(result);
            }
        });
    };

    const displayVideoStats = (videoStats) => {
        const value = 0;
        let resHeight = 0;
        let resWidth = 0;
        let bw = 0;
        let bps = 0;
        let fps = 0;
        let loss = 0;
        let keyPair = '';

        if (videoStats) {
            Object.keys(videoStats).forEach((key) => {
                switch (key) {
                    case 'bitrateCalculated':
                        bps = Math.round((videoStats[key]) / 1000);
                        break;

                    case 'framerateCalculated':
                        fps = videoStats[key];
                        break;

                    case 'bandwidth':
                        bw = Math.round((videoStats[key]) / 1000);
                        break;

                    case 'packetsLost':
                        loss = videoStats[key];
                        break;

                    case 'frameHeight':
                        resHeight = videoStats[key];
                        break;

                    case 'frameWidth':
                        resWidth = videoStats[key];
                        break;

                    default:
                        break;
                }
            });
            if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
                keyPair += `<div> <strong style="color:black;" > ${resWidth}X${resHeight}p${fps}@${bps}Kbps</strong>:</div>`;
                if (bw || loss) {
                    keyPair += `<div> <strong style="color:black;" > AvailBw:${bw}Kbps, loss:${loss}</strong>:</div>`;
                }
            }
        }
        if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
            return {
                displayString: keyPair,
                resHeight,
                resWidth,
                packetsLost: loss,
                bandwidth: bw,
                frameRate: fps,
                bitrate: bps,
            };
        } else {
            return {
                resHeight,
                resWidth,
                packetsLost: loss,
                bandwidth: bw,
                frameRate: fps,
                bitrate: bps,
            };
        }
    };

    const socketOnStatSubscription = (arg) => {
        const statNodes = arg.statData.stats;
        const statInfo = {};
        const talkerStats = [];
        const selfPublisherStat = {};
        const canvasStat = {};
        const shareStat = {};

        statNodes.forEach((statNode) => {
            const streamType = statNode.streamType;
            // To DO : needs refactoring .. will do during QA
            if (streamType === 'actStat') {
                const publisherStat = {};
                if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
                    var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.subscriberStreamId}`);
                    if (talkerStats[statNode.subscriberStreamId] == undefined) {
                        talkerStats[statNode.subscriberStreamId] = { id: statNode.subscriberStreamId };
                    }
                    publisherStat.video = [];
                    selecterStrings.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            let keyPair = '';
                            //keyPair += `<div>Publisher bitrate</div>`;
                            Object.keys(statNode.total).forEach((key) => {
                                if (key === 'bitrateCalculated') {
                                    const value = Math.round((statNode.total[key]) / 1000);
                                    if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                        publisherStat['total-bitrate-kbps'] = value;
                                    } else if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                        keyPair += `<div> <strong>Tx Total:</strong>:  ${value}Kbps </div>`;
                                    }
                                }
                            });
                            for (let index = 0; index < statNode.videoStats.length; index++) {
                                publisherStat.video[index] = displayVideoStats(statNode.videoStats[index]);
                                if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                    keyPair += publisherStat.video[index].displayString;
                                    const totalDetails =
                                        `<div id="" class="stats-detail">
                                    ${keyPair}
                                </div>`;
                                    selecterString.innerHTML = totalDetails;
                                }
                            }
                        }
                    });
                } else {
                    if (talkerStats[statNode.subscriberStreamId] == undefined) {
                        talkerStats[statNode.subscriberStreamId] = { id: statNode.subscriberStreamId };
                    }
                    publisherStat.video = [];
                        Object.keys(statNode.total).forEach((key) => {
                            if (key === 'bitrateCalculated') {
                                const value = Math.round((statNode.total[key]) / 1000);
                                if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                    publisherStat['total-bitrate-kbps'] = value;
                                }
                            }
                        });
                        for (let index = 0; index < statNode.videoStats.length; index++) {
                            publisherStat.video[index] = displayVideoStats(statNode.videoStats[index]);
                        }
                }
                talkerStats[statNode.subscriberStreamId].publisher = publisherStat;
            } else if (streamType === 'selfPcStat') {
                if (talkerStats[statNode.subscriberStreamId] == undefined) {
                    talkerStats[statNode.subscriberStreamId] = {
                        id: statNode.subscriberStreamId,
                    };
                }
                const subscriberStat = {};
                subscriberStat.video = [];
                if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
                    const streamId = parseInt(statNode.streamId) + 1;
                    const dataOnRightParts = document.querySelectorAll(`#stats-right-part-${statNode.subscriberStreamId}`);
                    dataOnRightParts.forEach((dataOnRightPart) => {
                        if ((dataOnRightPart !== undefined) && (dataOnRightPart !== null)) {
                            let keyPair = '';
                            //keyPair += `<div> <strong>Subscriber stream ID</strong>:  ${streamId} </div>`;
                            Object.keys(statNode.total).forEach((key) => {
                                if (key === 'bitrateCalculated') {
                                    const value = Math.round((statNode.total[key]) / 1000);
                                    if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                        subscriberStat['total-bitrate-kbps'] = value;
                                    } else if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                        keyPair += `<div> <strong>Rx ID: ${streamId}, Total:</strong>:  ${value}Kbps </div>`; //   keyPair += `<div> <strong>${key}</strong>:  ${value}kbps </div>`;
                                    }
                                }
                            });
                            const totalDetails =
                                `<div id="" class="stats-detail">
                                        ${keyPair}
                                    </div>`;
                            dataOnRightPart.innerHTML = totalDetails;
                            //keyPair += `<div> Peer connection Video stream stats </div>`;
                            for (let index = 0; index < statNode.videoStats.length; index++) {
                                subscriberStat.video[index] = displayVideoStats(statNode.videoStats[index]);
                                if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                    keyPair += subscriberStat.video[index].displayString;
                                    const videoDetails =
                                        `<div id="" class="stats-detail">
                                ${keyPair}
                                </div>`;
                                    dataOnRightPart.innerHTML = videoDetails;
                                }
                            }
                        }
                    });
                } else {
                    const streamId = parseInt(statNode.streamId) + 1;
                            Object.keys(statNode.total).forEach((key) => {
                                if (key === 'bitrateCalculated') {
                                    const value = Math.round((statNode.total[key]) / 1000);
                                    if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                        subscriberStat['total-bitrate-kbps'] = value;
                                    }
                                }
                            });
                            for (let index = 0; index < statNode.videoStats.length; index++) {
                                subscriberStat.video[index] = displayVideoStats(statNode.videoStats[index]);
                            }
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(` subscriberStreamId: ${statNode.subscriberStreamId} substat: ${JSON.stringify(subscriberStat)}`);
                talkerStats[statNode.subscriberStreamId].subscriber = subscriberStat;
            } else if (streamType === 'selfPubStat') {
                if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
                    var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.streamId}`);
                    selecterStrings.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            let keyPair = '';
                            //keyPair += `<div> Self upload bitrate </div>`;
                            Object.keys(statNode.total).forEach((key) => {
                                if (key === 'bitrateCalculated') {
                                    const value = Math.round((statNode.total[key]) / 1000);
                                    if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                        selfPublisherStat['total-bitrate-kbps'] = value;
                                    } else if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                        keyPair += `<div> <strong>Tx Total</strong>: ${value}Kbps</div>`;
                                    }
                                }
                            });
                            selfPublisherStat.video = [];
                            for (let index = 0; index < statNode.videoStats.length; index++) {
                                selfPublisherStat.video[index] = displayVideoStats(statNode.videoStats[index]);
                                if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                    keyPair += selfPublisherStat.video[index].displayString;
                                    const totalDetails =
                                        `<div id="" class="stats-detail">
                                        ${keyPair}
                                    </div>`;
                                    selecterString.innerHTML = totalDetails;
                                }
                            }
                        }
                    });
                } else {
                        Object.keys(statNode.total).forEach((key) => {
                            if (key === 'bitrateCalculated') {
                                const value = Math.round((statNode.total[key]) / 1000);
                                if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                    selfPublisherStat['total-bitrate-kbps'] = value;
                                }
                            }
                        });
                        selfPublisherStat.video = [];
                        for (let index = 0; index < statNode.videoStats.length; index++) {
                            selfPublisherStat.video[index] = displayVideoStats(statNode.videoStats[index]);
                        }
                }
            } else if (streamType === 'canvasStat') {
                if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
                    //    Logger.info('Canvas stream', parseInt(statNode.streamId) + 1, 'total', statNode.total, 'statNode', statNode);
                    var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.subscriberStreamId}`);
                    selecterStrings.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            let keyPair = '';
                            //keyPair += `<div>Canvas publisher bitrate</div>`;
                            Object.keys(statNode.total).forEach((key) => {
                                if (key === 'bitrateCalculated') {
                                    const value = Math.round((statNode.total[key]) / 1000);
                                    if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                        canvasStat['total-bitrate-kbps'] = value;
                                    } else if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                        keyPair += `<div> <strong>Tx Total:</strong>:  ${value}Kbps </div>`;
                                    }
                                }
                            });
                            canvasStat.video = displayVideoStats(statNode.videoStats);
                            if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                keyPair += canvasStat.video.displayString;
                                const totalDetails =
                                    `<div id="" class="stats-detail">
                                            ${keyPair}
                                        </div>`;
                                selecterString.innerHTML = totalDetails;
                            }
                        }
                    });
                } else {
                    Object.keys(statNode.total).forEach((key) => {
                        if (key === 'bitrateCalculated') {
                            const value = Math.round((statNode.total[key]) / 1000);
                            if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                canvasStat['total-bitrate-kbps'] = value;
                            }
                        }
                    });
                    canvasStat.video = displayVideoStats(statNode.videoStats);
                }
            } else if (streamType === 'shareStat') {
                if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
                    //   Logger.info('shareStat stream', parseInt(statNode.streamId) + 1, 'total', statNode.total);
                    var selecterStrings = document.querySelectorAll(`#stats-left-part-${statNode.subscriberStreamId}`);
                    selecterStrings.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            let keyPair = '';
                            //keyPair += `<div>Share Publisher bitrate</div>`;
                            Object.keys(statNode.total).forEach((key) => {
                                if (key === 'bitrateCalculated') {
                                    const value = Math.round((statNode.total[key]) / 1000);
                                    if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                        shareStat['total-bitrate-kbps'] = value;
                                    } else if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                        keyPair += `<div> <strong>Tx Total:</strong>:  ${value}Kbps </div>`;
                                    }
                                }
                            });
                            shareStat.video = displayVideoStats(statNode.videoStats);
                            if (that.mediaStatsMode == 'display' || that.mediaStatsMode == 'notify-display') {
                                keyPair += shareStat.video.displayString;
                                const totalDetails =
                                    `<div id="" class="stats-detail">
                                            ${keyPair}
                                        </div>`;
                                selecterString.innerHTML = totalDetails;
                            }
                        }
                    });
                } else {
                    Object.keys(statNode.total).forEach((key) => {
                        if (key === 'bitrateCalculated') {
                            const value = Math.round((statNode.total[key]) / 1000);
                            if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
                                shareStat['total-bitrate-kbps'] = value;
                            }
                        }
                    });
                    shareStat.video = displayVideoStats(statNode.videoStats);
                }
            }
        });
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`that.mediaStatsMode : ${that.mediaStatsMode} talkers: ${JSON.stringify(talkerStats)} selfPublisherStat: ${JSON.stringify(selfPublisherStat)}`);
        if (that.mediaStatsMode == 'notify' || that.mediaStatsMode == 'notify-display') {
            that.dispatchEvent({
                type: 'media-stats',
                talkers: talkerStats,
                publisher: selfPublisherStat,
                share: shareStat,
                canvas: canvasStat,
            });
        }
    };

    const updateAttributesFromStreamEvent = (evt) => {
        const stream = evt.stream;
        const attrs = evt.attrs;
        if (stream.local) {
            stream.updateLocalAttributes(attrs);
            socket.sendMessage('updateStreamAttributes', { id: stream.getID(), attrs });
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: ('updateAttributesFromStreamEvent - updateStreamAttributes - success') });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('You can not update attributes in a remote stream');
        }
    };

    const socketEventToArgs = (func, event) => {
        if (event.args) {
            func(...event.args);
        } else {
            func();
        }
    };

    const createSdpConstraints = (type, stream, options) => ({
        state: type,
        data: stream.ifData(),
        audio: stream.ifAudio(),
        video: stream.ifVideo(),
        screen: stream.ifScreen(),
        canvas: stream.ifCanvas(),
        canvasType: options.canvasType, // applicable only incase of canvas else its undefined
        attributes: stream.getAttributes(),
        metadata: options.metadata,
        createOffer: options.createOffer,
        muteStream: options.muteStream,
        shareMetadata: options.shareMetadata,
    });

    const populateStreamFunctions = (id, streamInput, error, callback = () => { }) => {
        const stream = streamInput;

        if (id === null) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error when publishing the stream', error);
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_publish_failed, { error });
            // Unauth -1052488119
            // Network -5
            callback(undefined, error);
            return;
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stream published');
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_publish_success, { error: {} });
        //stream.getID = () => id;
        stream.setID (id);
        stream.on('internal-send-data', sendDataSocketFromStreamEvent);
        stream.on('internal-set-attributes', updateAttributesFromStreamEvent);
        localStreams.add(id, stream);
        stream.room = that;
        callback(id);

        const onResult = (result) => {
            if (result) {
                //         clearInterval(peerStatsInterval);
                const additionalOptions = {
                    streamId: stream.getID(),
                    selectedCandidates: result.selectedCandidates,
                    negotiatedCodecs: {
                        video: {
                            codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration,
                        },
                        audio: {
                            codec: 'OPUS',
                        },
                    },
                    selectedCam: stream.video.deviceId,
                    selectedMic: stream.audio.deviceId,
                    externalIp: that.externalIp,
                };
                that.createEventLog('clientStreamPublishSuccess', additionalOptions);
            }
        };

        /*   if(stream.pc) {
               peerStatsInterval = setInterval(() => {
                   getPeerStats(stream.pc.peerConnection, onResult);
               }, 1000);
           }*/
    };

    const publishExternal = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        let type;
        let arg;
        if (stream.url) {
            type = 'url';
            arg = stream.url;
        } else {
            type = 'recording';
            arg = stream.recording;
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Checking publish options for', stream.getID());
        stream.checkOptions(options);
        that.socket.sendSDP('publish', createSdpConstraints(type, stream, options), arg, (id, error) => {
            populateStreamFunctions(id, stream, error, callback);
        });
    };

    const publishData = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        that.socket.sendSDP('publish', createSdpConstraints('data', stream, options), undefined, (id, error) => {
            populateStreamFunctions(id, stream, error, callback);
        });
    };
    const setMediaConnectionTimer = (enable,streamId, publish)=> {
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug("setMediaConnectionTimer() "+ " enable: "+ enable + " pub: " + publish + "  streamId: " + streamId);
      if (mediaConnectionTimer != undefined ) clearTimeout(mediaConnectionTimer);
      if (enable)
        mediaConnectionTimer = setTimeout(()=>{mediaConnectionTimeout(streamId, publish);},
                                                __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.getMediaConnectionTimeoutSecs(that.isStreamingClient)*1000);
      else mediaConnectionTimer = undefined;
    };

    const publishVcxRtc = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        if (((stream.screen === undefined) || (stream.screen == false)) &&
            ((stream.canvas === undefined) || (stream.canvas == false))) {
            stream.handleMediaDeviceChangeNotify ("publisher");
            const maxVideoLayers = options.maxVideoLayers ? options.maxVideoLayers : that.maxVideoLayers;
            if ((maxVideoLayers > 1) && (maxVideoLayers <= 3)) {
                options.simulcast = {numSpatialLayers: maxVideoLayers,spatialLayerBitrates: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_layer_bitrates,};
            }
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Publishing Main, createOffer', options.createOffer, ` Max video layers: ${maxVideoLayers}`);
        } else if ((stream.canvas !== undefined) && (stream.canvas == true)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Publishing Canvas spatiallayers 3 createOffer', options.createOffer);
            //options.simulcast = { numSpatialLayers: 3 };
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Publishing Share createOffer', options.createOffer);
        }
        const constraints = createSdpConstraints('media_engine', stream, options);
        constraints.minVideoBW = options.minVideoBW;
        constraints.maxVideoBW = options.maxVideoBW;
        constraints.scheme = options.scheme;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("publish video: constraints: " + JSON.stringify(constraints) + " options: " + JSON.stringify(options));
        that.socket.sendSDP('publish', constraints, undefined, (response) => {
            if (response && response.result === 0) {
                populateStreamFunctions(response.id, stream, undefined, undefined);
                createLocalStreamVcxRtcConnection(stream, options);
                stream.clientId = that.clientId;
                stream.maxVideoBwKbpsReqByServer = options.maxVideoBW;
            }
            callback(response);
        });
        setMediaConnectionTimer (true, stream.getID(), true);
    };
    const getVideoConstraints = (stream, video) => {
        const ifVideo = video && stream.ifVideo();
        const width = video && video.width;
        const height = video && video.height;
        const frameRate = video && video.frameRate;
        if (width || height || frameRate) {
            return {
                width,
                height,
                frameRate,
            };
        }
        return ifVideo;
    };

    const subscribeVcxRtc = (streamInput, optionsInput, callback = () => { }) => {
        const stream = streamInput;
        const options = optionsInput;
        options.maxVideoBW = options.maxVideoBW || spec.defaultVideoBW;
        if (options.maxVideoBW > spec.maxVideoBW) {
            options.maxVideoBW = spec.maxVideoBW;
        }
        options.audio = (options.audio === undefined) ? true : options.audio;
        options.video = (options.video === undefined) ? true : options.video;
        options.data = (options.data === undefined) ? true : options.data;
        options.canvas = (options.canvas === undefined) ? true : options.canvas;
        stream.checkOptions(options);
        const constraint = {
            streamId: stream.getID(),
            audio: options.audio && stream.ifAudio(),
            video: getVideoConstraints(stream, options.video),
            data: options.data && stream.ifData(),
            canvas: options.canvas && stream.ifCanvas(),
            browser: that.Connection.browserEngineCheck(),
            createOffer: options.createOffer,
            metadata: options.metadata,
            muteStream: options.muteStream,
            slideShowMode: options.slideShowMode,
        };

        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`SOCKET EVENT subscribe:- ${JSON.stringify(constraint)}`);

        that.socket.sendSDP('subscribe', constraint, undefined, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error subscribing to stream ', error);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_subscribe_failed, { error });
                callback(undefined, error);
                return;
            }
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Subscriber added');
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stream subscription result', result);
            // EL.info('room-event', customEvents.event_stream_subscribe_success, { error: {} });
            createRemoteStreamVcxRtcConnection(stream, options);

            callback(true);
        });
    };

    const subscribeData = (streamInput, options, callback = () => { }) => {
        const stream = streamInput;
        that.socket.sendSDP(
            'subscribe',
            {
                streamId: stream.getID(),
                data: options.data,
                metadata: options.metadata,
            },
            undefined,
            (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error subscribing to stream ', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_subscribe_failed, { error });
                    callback(undefined, error);
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stream subscribed');
                const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])({ type: 'stream-subscribed', stream });
                that.dispatchEvent(evt);
                callback(true);
            },
        );
    };
   const validateProcessNetworkTimeout = (forceDisconnect, rejoin, notify = true) => {
    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("validateProcessNetworkTimeout() forceDisconnect : " + forceDisconnect + " rejoin room:" + rejoin +
                 " retries: " + that.reconnectAttempt +  " state: " + that.state);
    if (!forceDisconnect && that.state != DISCONNECTED && that.state != CONNECTED) return;
    if (!forceDisconnect && that.reconnectAttempt < MAXRECONNECTIONATTEMPT) {
      if (that.isStreamingClient) that.reconnectionAllowed = false;
      else that.reconnectionAllowed = true;
      if (rejoin) {
        if (notify)
          that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({type: 'network-reconnecting', message: 'Network issues - reconnecting, please wait'}));
        that.rejoinRoom((resp) => {
          if (resp.result != __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) validateProcessNetworkTimeout(false, true, notify);
        });
      }else {
        clearAll(notify);
      }
    }else {
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info( true ? 'force disconnect' :
                  'reconnectAttempt(' + reconnectAttempt + ') > max allowed limit');
      that.reconnectionAllowed = false;
      clearAll(notify);
      if (notify) {
        // send reconnection timeout event to application
        that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({type:'network-reconnect-timeout',
                                      error: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1165.result,message:__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1165.error}));
      }
      //EL.error('room-event', customEvents.event_network_reconnect_timeout, evt);
    }
  };
    // detect internet connection
  const doesConnectionExist = () => {
    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('detect doesConnectionExist');
    if (that.state === DISCONNECTED) {
      let onlyOnce = 0;
      const xhr = new XMLHttpRequest();
      const file = (that.internetDetectionUrl !== undefined) ? that.internetDetectionUrl : __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.internetDetectionUrl;
      const randomNum = Math.round(Math.random() * 10000);
      xhr.timeout = 15000; // time in milliseconds
      xhr.open('HEAD', `${file}?rand=${randomNum}`, true);
      xhr.ontimeout = (e) => {__WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('xhr timeout---------------');};
      xhr.addEventListener('readystatechange', processRequest, false);
      function processRequest(e) {
        if (xhr.readyState === 4) {
          if (xhr.status >= 200 && xhr.status < 304) {
            onlyOnce++;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('internet is back connection exists !');
            stopInternetDetection();
            detectInternet.time= 0;
            if (onlyOnce === 1) validateProcessNetworkTimeout(false,true);
          } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("internet connection doesn't exist!");
            stopInternetDetection();
            detectInternet.disconnectedDurationSecs++;
            if (detectInternet.disconnectedDurationSecs < detectInternet.timeoutSecs)
              detectInternet.timer = setInterval(doesConnectionExist, detectInternet.intervalSecs*1000);
            else validateProcessNetworkTimeout(true,false);
          }
        } else {
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('ajax req readystate: ', xhr.readyState, 'status ', xhr.status, 'timer', detectInternet.timer);
        }
      }
     // send xhr request
      xhr.send();
    }
  };

    // stop the reconnection attempt
    const stopInternetDetection = () => {
        if (detectInternet.timer !== undefined) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stopInternetDetection kill it');

            clearInterval(detectInternet.timer);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stopInternetDetection handle is undefined', detectInternet.timer);
        }
    };
    const storeRemoteStreamPlayers = () =>{
      if (that.remoteStreams.size()) that.remoteStreamsInfo.clear();
      that.remoteStreams.forEach((stream, id) => {
        let info = {}
        if (stream.player) info.player = stream.player;
        if (stream.userRequestOptions) info.userReqOpt = stream.userRequestOptions;
        else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(" onRoomConnected() player and userRequestOptions missing, ignoring sid: " + id);
        that.remoteStreamsInfo.add(id,info);
      });
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("storeRemoteStreamPlayers() remoteStreamsInfo: " + JSON.stringify(that.remoteStreamsInfo.keys()));
    }
    const clearStreams = (reconnect, callback = ()=>{}) => {
      if (reconnect && remoteStreams.size()) that.remoteStreamsInfo.clear();
      remoteStreams.forEach((remoteStream, id) => {
        if (remoteStream !== undefined && remoteStream.stream !== undefined) {
          remoteStream.stream.getTracks().forEach((trackInput) => {
            const track = trackInput;
            track.onended = null;
            track.stop(); // Stops each track in the Stream
          });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('remote stream or media stream is undefined id: ' + id);
        }
        if (remoteStream.pc) {
            remoteStream.pc.close();
            delete remoteStream.pc;
        }
        if (reconnect){
          let info = {};
          if( remoteStream.player) info.player = remoteStream.player;
          if (remoteStream.userRequestOptions) info.userReqOpt = remoteStream.userRequestOptions;
          that.remoteStreamsInfo.add(id,info);
        }
        remoteStreams.remove(id);
      });

      localStreams.forEach((localStream, id) => {
        if (localStream.pc) {
          localStream.pc.close();
          delete localStream.pc;
        }
        if (reconnect) storeLocalStreamForReconnect(localStream);
        if (localStream && localStream.local) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stream off for internal send data');
            localStream.off('internal-send-data', sendDataSocketFromStreamEvent);
        }

        localStreams.remove(id);
      });
      that.allStreamsActive = false;
    }
    const clearAll = (notify, callback) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('clearAll() room-disconnected, reconnectionAllowed: ' + that.reconnectionAllowed);
        // Remove all streams
        if (that.reconnectionAllowed === false) {
            remoteStreams.forEach((stream, id) => {
                removeStream(stream);
                remoteStreams.remove(id);
                if (stream && !stream.failed) {
                    const evt2 = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])({ type: 'stream-removed', stream });
                    that.dispatchEvent(evt2);
                }
            });
            remoteStreams = Object(__WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__["a" /* default */])();
            // Close Peer Connections
            localStreams.forEach((stream, id) => {
                if (stream.ifCanvas()) {
                    that.stopCanvas(() => { });
                }
                removeStream(stream);
                localStreams.remove(id);
            });
            localStreams = Object(__WEBPACK_IMPORTED_MODULE_6__utils_VcxRtcMap__["a" /* default */])();

            // Close socket
            try {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`normal socket closure, disconnect socket room state:${that.state}`);
                const disconnectSocket = (initiator) => {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`disconnectSocket() room state: ${that.state} initiator: ${initiator}`);
                    if (that.state != DISCONNECTED) {
                        that.state = DISCONNECTED;
                        that.allStreamsActive = false;
                        if (that.streamsHealthTimerId !== 0) {
                          clearInterval(that.streamsHealthTimerId);
                          that.streamsHealthTimerId = 0;
                        }
                        socket.disconnect();
                        socket.state = socket.DISCONNECTED;
                        socket = undefined;
                    }
                    if (callback) {
                        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
                    }
                };

                if (that.state == CONNECTED) {
                    that.state = DISCONNECTING;
                    that.allStreamsActive = false;
                    if (that.streamsHealthTimerId !== 0) {
                      clearInterval(that.streamsHealthTimerId);
                      that.streamsHealthTimerId = 0;
                    }
                    const tempMsg = {};
                    tempMsg.self = true;
                    const timer = setTimeout(disconnectSocket, 1000, 'timer');
                    that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.drop, tempMsg, (resp) => {
                        clearTimeout(timer); disconnectSocket('disc callback');
                    });
                } else if (that.state != DISCONNECTING) {
                    disconnectSocket('direct');
                }
            } catch (error) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('Socket already disconnected');
                if (callback) {
                    //EL.error('room-event', customEvents.event_general_failed, { message: customErrors.error_1163 });
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1163);
                }
            }
        } else {
            /* unexpected socket closure caused the room disconnection
             handle the reconnection case and perform selective steps*/
            // Close PC stream
            //  that.localStreamsBeforeReconnect=localStreams; // store all existing local streams
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('in clear all - unexpected disconnection and the case for reconnect');
            clearStreams(true);

            socket.state = socket.DISCONNECTED;
            that.state = DISCONNECTED;
            that.allStreamsActive = false;
            if (that.streamsHealthTimerId !== 0) {
              clearInterval(that.streamsHealthTimerId);
              that.streamsHealthTimerId = 0;
            }
            // Send Network disconnected event
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('send network disconnected event');
            if (notify){
              const networkDisconnected = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'network-disconnected', error: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1163.result,
                                                      message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1163.error });
              that.dispatchEvent(networkDisconnected);
            }
            // end dispatching the event
            that.reconStartTime = Date.now();
            doesConnectionExist();
            //detectInternetStatus = setInterval(doesConnectionExist, 15000);
            if (callback) {
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1163 });
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1163);
            }
        }
    };

    // Public functions
    const reconnect = () => {
        clearStreams(that.reconnectionState);
        if (socket === undefined && that.reconnectionState === true) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnect creating a new socket');

            // get a new socket
            that.state = DISCONNECTED;// reconnection case , shall we use one more state at socket and room level ?
            that.allStreamsActive = false;
            if (that.streamsHealthTimerId !== 0) {
              clearInterval(that.streamsHealthTimerId);
              that.streamsHealthTimerId = 0;
            }
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnect force a new socket');
            socket = Object(__WEBPACK_IMPORTED_MODULE_2__Socket__["a" /* Socket */])(undefined);
            that.socket = socket;
            that.userList.clear();// clear up the userlist
        } else {
            that.socket.disconnect();
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('previous connection is still there or the reconnection state is false');
            that.userList.clear();// clear up the userlist
        }
    };

    // It stablishes a connection to the room.
    // Once it is done it throws a RoomEvent("room-connected")
    that.connect = (reconnectInfo = { allow_reconnect: true, number_of_attempts: 3, timeout_interval: 45000 },
                    callback=()=>{}) => {
        const token = JSON.parse(__WEBPACK_IMPORTED_MODULE_7__utils_Base64__["a" /* default */].decodeBase64(spec.token));
        //set up reconnect parameters
        that.reconnectionAllowed = reconnectInfo.allow_reconnect;
        that.reconnectionTimeOutInterval = reconnectInfo.timeout_interval;
        MAXRECONNECTIONATTEMPT = reconnectInfo.number_of_attempts;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug (" connection attempt check :" + that.connectAttempt);
        if (that.connectAttempt >= MAXCONNECTIONATTEMPT ||that.reconnectAttempt >= MAXRECONNECTIONATTEMPT) {
          validateProcessNetworkTimeout(true, false);
          callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1165);
          return;
        }
        if (that.reconnectionState === true){
          that.reconnectAttempt++; // increment reconnection attemp
          token.isReconnecting = true;
          token.reconnectAttempt = that.reconnectAttempt;
          token.oldClientIdForReconnect = that.clientId;
          if (!that.isModerator() &&
              (that.sharePermissions && that.sharePermissions.screen && that.sharePermissions.canvas &&
               (that.sharePermissions.screen.state != 'idle' || that.sharePermissions.canvas.state != 'idle'))){
            token.changedOptions = {sharePermissions : {screen:{state: that.sharePermissions.screen.state} ,
                                                        canvas: {state: that.sharePermissions.canvas.state}}};
          }
          token.room = that.roomID;
          token.role = that.me.role;
          token.name = that.me.name;
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('new token request for the reconnection: ', token);
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("room.connect() roomId: " +  that.roomID + " logId: " + token.logId);
        if (token.logId) __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.setLocalStorageItem('logID', token.logId);
        // 1- Connect to Client-Controller
        that.state = CONNECTING;
        that.me.logId = token.logId;
        that.allStreamsActive = false;
        if (that.streamsHealthTimerId !== 0) {clearInterval(that.streamsHealthTimerId);that.streamsHealthTimerId = 0;}
        /* used the following code when dynamic codec was enabled
        if(Connection.browserEngineCheck() === 'safari' ){
            token.mediaConfiguration = VcxEvent.constant.H264_CODEC;
        }else{
            token.mediaConfiguration = VcxEvent.constant.default;
        }*/
        // host type is used by server for setting audio only recording for safari publisher. (safari video MKVs are corrupts)
        token.hostType = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name;
        token.hostVersion = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.version;
        token.hostDeviceType = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.device_type;
        token.userAgent = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.user_agent;
        token.advancedOptions = spec.options;
        token.version = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.product.version;
        if (spec.maxActiveTalkers != undefined && typeof spec.maxActiveTalkers == 'number'){
          token.maxActiveTalkers = spec.maxActiveTalkers;
        }
        if (socketErrorTimer) {
          clearTimeout(socketErrorTimer);
          socketErrorTimer = undefined;
        }
        //token.advancedOptions = [{id: 'notify-video-resolution-change', enable : true}];
        that.connectAttempt++;
        let sockTimeout = 8000; //in msecs
        let sockMaxRetries = 2;
        // for streaming client set to 4 secs of two reconnect
        if (token.isStreamingClient) {sockTimeout = 4000; sockMaxRetries = 2};
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("calling socket connect that.connectAttempt: " + that.connectAttempt);
        that.socket.connect({token:token, timeoutMs: sockTimeout,retryAttempts: sockMaxRetries}, (response) => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('socket response: ', response);
            if (response.result === 0) {
                that.connectAttempt = 0;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('socket.connect token accepted');
                that.externalIp = response.connectedIP;
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('connect error', response);
                validateProcessNetworkTimeout(true, false, false);
                that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-error', error: response.result, message: response.msg }));
                const additionalOptions = {clientId: '',
                    hostType: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name,
                    hostVersion: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.version,
                    error: response.msg,
                    externalIp: that.externalIp,
                };
                that.createEventLog('clientConnFailed', additionalOptions);
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1161);
            }
        }, (error) => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Not Connected! Error: ${error}`);
            let result ;
            validateProcessNetworkTimeout (true, false);
            if (typeof error == 'object' && error.result != undefined){
              __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("socket.connect failed with error: " + JSON.stringify(error));
              result = error.result;
            }else {
              result = error;
            }
            const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-error', error: result, message: error });
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: ('clientConnFailed - error') });
            that.dispatchEvent(connectEvt);
            const additionalOptions = {
                clientId: '',
                hostType: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name,
                hostVersion: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.version,
                error,
                externalIp: that.externalIp,
            };
            that.createEventLog('clientConnFailed', additionalOptions);
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1161);
        });
    };

    ////////////////ReConnect////////////////////////
    that.rejoinRoom = (callback = ()=>{}) => {
      reconnectStreamIds = {local: {}, remote :{}};
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('=========== port of hope--- reconnect');
        // disconnect while first connecting, its not reconnection
        if (that.externalIp != ''){ // disconnect while first connecting, its not reconnection
          that.reconnectionState = true; // toDO need to handle
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" rejoinRoom() disconnect and connect after 1 sec");
        // initialize all  local streams ,including share and canvas if they were being published before reconnection
        that.state = RECONNECTING;
        reconnect();
        setTimeout((()=>{__WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" rejoinRoom() connecting11 " ); reconnect;that.connect(undefined, callback);}).bind(this),1000);
    };
    ///// End reconnect

    // It disconnects from the room, dispatching a new RoomEvent("room-disconnected")
    that.disconnect = (msg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('room.disconnect() clearing alll ');
        // 1- Disconnect from room
        that.reconnectionAllowed = false;
        clearAll(true, (result) => {
            if (msg == undefined) {
                msg = { cause: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].CC006 };
            }
            const disconnectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-disconnected', message: msg });
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('that.disconnect() sending room-disconnected event');
            that.dispatchEvent(disconnectEvt);
        });
    };

    that.removeTrack = (streamID) => {
        that.socket.sendSDP('removeTrack', {
            streamId: streamID,
            msg: 'track-removed',
        }, undefined, () => { });
    };

    that.getWaitingUserList = (callback) => {
        that.socket.sendMessage('getAwaitedUser', function (response) {
            if (response.result === 0) {
                for (const key in response.awaitedParticipants) {
                    const user_details = {
                        clientId: response.awaitedParticipants[key].clientId,
                        name: response.awaitedParticipants[key].name,
                    };
                    that.awaitedParticipants.set(response.awaitedParticipants[key].clientId, user_details);
                }
                if (callback) callback(response);
            } else {
                if (callback) callback(response);
            }
        });
    };

    that.updateLayout = (layoutOptions, callback) => {
        validateLayoutData(layoutOptions, callback);
    };

    const onParticipantFloorEvents = (eventId, eventInfo) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`event: ${eventId}:${eventInfo.clientId}::::${eventInfo.name}`);
        that.cCrequest.push({ clientId: eventInfo.clientId, name: eventInfo.name, type: "raised" });
        const floorEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: eventId, users: eventInfo });
        that.dispatchEvent(floorEvt);
    };
    const checkAndRemoveGrantedFloor = (clientId) => {
      let ret = false;
      for (let cnt=0; cnt < that.cCapprovedHands.length; cnt++) {
        if (that.cCapprovedHands[cnt].clientId == clientId){
          that.cCapprovedHands.splice(cnt,1);
          ret = true;
          break;
        }
      }
      return ret;
    }
    const checkAndRemoveRequestedFloor = (clientId) => {
      let ret = false;
      for (let cnt=0; cnt < that.cCrequest.length; cnt++) {
        if (that.cCrequest[cnt].clientId == clientId){
          that.cCrequest.splice(cnt,1);
          ret = true;
          break;
        }
      }
      return ret;
    }
    const onModeratorFloorEvents = (eventId, eventInfo) => {
            switch (eventId) {
                case 'floor-granted':
                    if (eventInfo.clientId === that.clientId) that.floorGranted = true;
                    else that.cCapprovedHands.push({clientId: eventInfo.clientId, moderatorId: eventInfo.moderatorId});
                    break;

                case 'floor-invited':
                    if (eventInfo.clientId === that.clientId) that.floorInvited = true;
                    break;

                case 'floor-denied':
                    if (eventInfo.clientId === that.clientId) that.floorGranted = false;
                    break;

                case 'floor-cancelled':
                    if (eventInfo.clientId === that.clientId) that.floorInvited = false;
                    else checkAndRemoveGrantedFloor(eventInfo.clientId);
                    break;

                case 'floor-released':
                  if (eventInfo.clientId === that.clientId) {
                    var lstrm = that.localStreams.getAll();
                    localStreams.forEach((stream, id) => {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`${stream.getID()}::::${id}`);
                        that.unpublish(stream, (arg) => {
                            if (arg == true) {
                                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stream has been un-published');
                                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unpublish_success, { error: {} });
                            } else {
                                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('error during stream un-publishing');
                                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unpublish_failed, { stream });
                            }
                            that.floorGranted = false;
                        });
                    });
                    } else {
                      checkAndRemoveGrantedFloor(eventInfo.clientId);
                    }
                    break;

                default:
                    break;
            }
         //backward compatability for app
        if (eventId == 'floor-released') that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'release-floor', users: eventInfo }));
        that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: eventId, users: eventInfo }));
    };

    const onFloorManagementEvents = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(` onFloorManagementEvents: ${JSON.stringify(arg)}`);
        switch (arg.id) {
            case 'floorRequested':
                onParticipantFloorEvents('floor-requested', arg);
                break;

            case 'floorCancelled':
                onParticipantFloorEvents('floor-cancelled', arg);
                break;

            case 'floorFinished':
                onParticipantFloorEvents('floor-finished', arg);
                break;

            case 'floorRejected':
                that.floorInvited = false;
                onParticipantFloorEvents('floor-rejected', arg);
                break;

            case 'floorAccepted':
                onParticipantFloorEvents('floor-accepted', arg);
                break;


            case 'inviteToFloor':
                onModeratorFloorEvents('floor-invited', arg);
                break;

            case 'floorGranted':
                onModeratorFloorEvents('floor-granted', arg);
                break;

            case 'floorDenied':
                onModeratorFloorEvents('floor-denied', arg);
                break;

            case 'floorReleased':
                onModeratorFloorEvents('floor-released', arg);
                break;

            case 'cancelFloorInvite':
                onModeratorFloorEvents('floor-invite-cancelled', arg);
                break;

            default:
                break;
        }
    };

    const onHardmuteOne = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(arg);
        const floorReqEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'hard-mute', users: arg });
        that.dispatchEvent(floorReqEvt);
    };

    const onHardUnmuteRoom = (arg, callback) => {
        hardMuteMediaDevices(false, true, false, true, callback, true, { type: 'hard-unmute-room', message: arg });
        that.mute = that.muteInfo.room.audio = false;
        that.hardMuteInitiator = false;
    };

    const onHardmuteRoom = (arg, callback) => {
        hardMuteMediaDevices(true, true, false, true, callback, true, { type: 'hard-mute-room', message: arg });
        that.mute = that.muteInfo.room.audio = true;
        that.hardMuteInitiator = false;
    };

    that.enableKnock = (enable, callback) => {
        if ((enable !== undefined) && (typeof enable === 'boolean')) {
            that.socket.emitEvent('enableKnock', enable, (response) => {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`enableKnock response${JSON.stringify(response)}`);
                if (response.result === 0 && enable === false) that.awaitedParticipants.clear();
                if (callback) callback(response);
            });
        } else {
            callback(false);
        }
    };

    that.openFloor = (enable, callback) => {
        if ((enable !== undefined) && (typeof enable === 'boolean')) {
            that.socket.emitEvent('openFloor', enable, (response) => {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`openFloor response${JSON.stringify(response)}`);
                if (response.result === 0) that.floorOpen = enable;
                if (callback) callback(response);
            });
        } else {
            callback(false);
        }
    };




    const onRoomAwaited = (arg) => {
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-awaited', message: 'waiting for moderator approval' });
        that.dispatchEvent(evt);
    };

    const onUserAwaited = (arg) => {
        const user_details = { clientId: arg.clientId, name: arg.name};
        if(arg.data) user_details.data = arg.data;
        that.awaitedParticipants.set(arg.clientId, user_details);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'user-awaited', message: { user: user_details } });
        that.dispatchEvent(evt);
    };

    that.approveAwaitedUser = (client, callback = () => { }) => {
        if (typeof callback === 'function') {
            that.socket.emitEvent('user-allowed', client, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on knock approve request', error);
                    return;
                }
                that.awaitedParticipants.delete(client);

                callback(result, error);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('approveAwaitedUser() invalid param - callback');
        }
    };

    that.denyAwaitedUser = (client, callback = () => { }) => {
        if (typeof callback === 'function') {
            that.socket.emitEvent('user-denied', client, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on knock deny request', error);
                    return;
                }
                that.awaitedParticipants.delete(client);

                callback(result, error);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('denyAwaitedUser() invalid param - callback');
        }
    };


    const onRoomConnected = (response) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('onRoomConnected() - reconnection: ' + that.reconnectionState);
        let stream;
        const streamList = [];
        const streams = response.streams || [];
        const roomId = response.id;
        const userList = response.userList;
        const roomJson = response.room;

        that.me = response.user || {};
        that.roomSettings = response.room.settings || {};
        that.mute = that.muteInfo.room.audio = response.room.mute;
        if (!that.reconnectionState) that.muteInfo.stream.hard.audio = that.muteInfo.room.audio;
        that.mediaRecord = response.mediaRecord;
        that.subscription = response.subscription;
        that.mode = response.room.settings.mode;
        if(!__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled) {
            document.head.append(statsStyle);
            document.head.append(bwNotificationStyle);
        }
        if (that.mode === 'lecture' && response.user.role === 'moderator') {
            if (response.raisedHands.length > 0) {
                response.raisedHands.forEach((item) => {
                    that.cCrequest.push(item);
                });
            }
            if (response.floorInvites.length > 0) {
                response.floorInvites.forEach((item) => {
                    that.cCrequest.push(item);
                });
            }
            if (response.approvedHands.length > 0) {
                response.approvedHands.forEach((item) => {
                    that.cCapprovedHands.push(item);
                });
            }
        }
        that.activeTalker = roomJson.settings.active_talker;
        for (const key in response.awaitedParticipants) {
            const user_details = {
                clientId: response.awaitedParticipants[key].clientId,
                name: response.awaitedParticipants[key].name,
            };
            that.awaitedParticipants.set(response.awaitedParticipants[key].clientId, user_details);
        }

        that.iceServers = response.iceServers;
        that.state = CONNECTED;
        that.mediaConfiguration = response.mediaConfiguration;
        if (response.nonTalkerMediaParams) that.nonTalkerMediaParams = response.nonTalkerMediaParams;
        that.videoMutedUsers = response.videoMutedUsers;
        spec.defaultVideoBW = response.defaultVideoBW;
        spec.maxVideoBW = response.maxVideoBW;
        that.clientId = response.clientId;
        that.confId = response.room.conf_num;
        that.maxVideoLayers = response.maxVideoLayers || 0;
        //if (that.maxVideoLayers > 1) that.videoLayersBWRange = response.videoLayersBWRange
        that.maxCanvasRefreshRate = response.maxCanvasRefreshRate || 0;
        that.share = response.room.share;
        that.locked = response.room.locked || false;
        that.waitRoom = response.room.waitRoom || false;
        that.knockEnabled = response.room.knockEnabled || false;
        that.userAudioTalkerCount = response.numAudioTalkers || 0;
        that.userVideoTalkerCount = response.numVideoTalkers || 0;
        spec.minVideoBW = response.minVideoBW;
        spec.maxVideoFps = response.maxVideoFps;
        that.liveRoomTranscription = response.transcription;
        that.privacyModes = response.privacyModes;
        that.remoteUserNotifications = response.remoteUserNotifications != undefined ? response.remoteUserNotifications : true;
        that.mediaActivationDelaySecs = response.mediaActivationDelaySecs || 0 ;
        if (response.room.sharePermissions){
          that.sharePermissions = response.room.sharePermissions;
        }
        if(response.transcription === true)
          that.transcriptionLanguage = response.transcriptionLanguage;
        if (response.internetDetectionUrl != undefined) {
            that.internetDetectionUrl = response.internetDetectionUrl;
        } else {
            that.internetDetectionUrl = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.internetDetectionUrl;
        }
        if (response.room.openFloor !== undefined)
            that.floorOpen = response.room.openFloor;
        else
            that.floorOpen = true;
        __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.setVideoBwQualityMapper(response.videoBitrateQualityMap);
        if (response.uploadedFileInfos) {
          that.availableFiles = JSON.parse(JSON.stringify(response.uploadedFileInfos));
          shFileList = response.uploadedFileInfos;
        }
        // Set clientId and utilToken in event logger if token is received
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].setClientId(response.clientId);
        if (response.utilToken) {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].setEventLoggerToken(response.utilToken);
        }

        // if file sharing service and subscription is enabled then populate and setup file sharing service
        // ToDO  refactor ;- set completed object from signalling server itself , insted of manipulating here
        if (response.room.fileShareService !== undefined) {
            let fileShareService = {};
            fileShareService = response.room.fileShareService;
            const fsCallInfo = {};
            fsCallInfo.call_num = response.clientId;
            fsCallInfo.room_id = response.id;
            fsCallInfo.service_id = response.room.service_id;
            fsCallInfo.conf_num = response.room.conf_num;
            fsCallInfo.userName = response.user.name || '';
            maxFileSize = response.room.fileShareService.maxSize;
            fileShareService.callInfo = fsCallInfo;
            Object(__WEBPACK_IMPORTED_MODULE_14__fileShare_app_api__["f" /* setFileShareServiceEndPoint */])(fileShareService);
        }
        // is a streaming client
        if (response.isStreamingClient != undefined) {
            if (response.isStreamingClient === true) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('is a streaming client setting log level to debug');
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].setLogLevel(__WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].DEBUG);
                that.isStreamingClient = true;
                that.getStats (true, {intervalSecs: 2, log: true});
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('NOT A S T Client');
                that.isStreamingClient = false;
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' server does not support file sharing ', response.room.fileShareService);
        }

	//Analytics :
        if(response.room !== undefined && response.room.isAnalyticsStarted) {
          that.isAnalyticsStarted = response.room.isAnalyticsStarted;
        }

        //HLS
        if (response.room.hls != undefined) {
            that.hls = response.room.hls;
        }
        that.audienceCount = response.audienceCount ? response.audienceCount : 0;
        if (response.room.customRoomData ) that.customRoomData = response.room.customRoomData;
        if (response.room.customSessionData ) that.customSessionData = response.room.customSessionData;

        let numATStreams2Activate = response.initialNumATs? parseInt (response.initialNumATs): 1;
        if (that.reconnectionState) storeRemoteStreamPlayers();
        remotePendingStreams.clear();
        remoteStreams.clear();
        // 2- Retrieve list of streams
        const streamIndices = Object.keys(streams);
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(" onRoomConnected() num subs streams: " + streamIndices.length + " activate: " + numATStreams2Activate);
        for (let index = 0; index < streamIndices.length; index += 1) {
            const arg = streams[streamIndices[index]];
            stream = Object(__WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */])(that.Connection, {
                streamID: arg.id,
                local: false,
                audio: arg.audio,
                video: arg.video,
                data: arg.data,
                screen: arg.screen,
                canvas: (!(typeof arg.canvas === 'undefined' || arg.canvas === false)),
                attributes: arg.attributes,
            });
            streamList.push(stream);
            if (stream.screen || stream.canvas || parseInt(arg.id) <= numATStreams2Activate || that.isStreamingClient) {
              remoteStreams.add(arg.id, stream);
            }else {
              remotePendingStreams.add(arg.id, stream);
            }
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(" onRoomConnected() ids remoteStreams: " + JSON.stringify(remoteStreams.keys()) +
                    " remotePendingStreams: " + JSON.stringify(remotePendingStreams.keys()));
        numATSubscribersAdded = numATStreams2Activate;
        // 3 - Update RoomID
        that.roomID = roomId;
        that.confID = roomJson.conf_num;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Connected to room ${that.roomID}`);
        for (const user in userList) {
            that.userList.set(userList[user].clientId, userList[user]);
        }
        that.getMaxTalkers((callback) => {
            that.talkerCount = callback.maxTalkers;
        });


        const roomMeta = {
            conf_num: roomJson.conf_num,
            name: roomJson.name,
            owner_ref: roomJson.owner_ref,
            mode: roomJson.settings.mode,
            moderators: roomJson.settings.moderators,
            participants: roomJson.settings.participants,
            auto_recording: roomJson.settings.auto_recording,
            canvas: roomJson.settings.canvas,
            description: roomJson.settings.description,
            created: roomJson.created,
            mute: roomJson.mute,
            quality: roomJson.settings.quality,
            screen_share: roomJson.share,
            locked: roomJson.locked,
            wait_room: roomJson.wait_room,
            duration: roomJson.remainingDuration,
            analyzer: roomJson.analyzer,
            screen_share_override: roomJson.settings.screen_share_override,
            privacy_modes: roomJson.privacyModes,
            remote_user_notifications: that.remoteUserNotifications
        };
        if (that.sharePermissions) roomMeta.share_permissions = that.sharePermissions;
        that.screenResolutionRange = (response.room.screenResolutionRange != null) ?
                                      response.room.screenResolutionRange : __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.screen_resolution_range[roomMeta.quality];
        if (that.speakerInfo.id != undefined) {
            validSpeakerDevice(that.speakerInfo.id, (valid) => {
                if (!valid) that.speakerInfo.id = undefined;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`selected speaker id valid : ${valid}`);
            });
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`room-connected event - room Info : ${JSON.stringify(roomMeta)}`);
        let connInfo = {streams: streamList, users: userList, room: roomMeta, me: that.me, mediaRecord: that.mediaRecord,};
        if (!that.reconnectionState || that.isFirstConnect){
          connInfo.type = 'room-connected';
          that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])(connInfo));
        }else restoreStateAfterReconnect(connInfo);
        that.isFirstConnect = false;
        if (response.room.shareOn != undefined ){
          if (response.room.shareOn != that.shareStatus){
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("onRoomConnected() share state mismatch srvr: " +response.room.shareOn + " clnt: " +that.shareStatus);
            if (that.shareStatus && that.shareEventInfo) {
              onShareStopped(that.shareEventInfo);
              that.shareEventInfo = undefined;
            }
            //if (that.shareStatus) that.dispatchEvent({ type: 'share-stopped', message:{clientId: 'unknown'}});
            that.shareStatus = response.room.shareOn ?  false : true;
          }else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("onRoomConnected() shareOn" +response.room.shareOn );
          }
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('onRoomConnected() that.externalIp: ' + that.externalIp);
        that.reconnectClientName = response.user.name;
        const additionalOptions = {
            clientId: response.clientId,
            clientName: response.user.name,
            hostType: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name,
            hostVersion: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.version,
            externalIp: that.externalIp,
        };
        that.createEventLog('clientConnSuccess', additionalOptions);
    };
    const restoreStateAfterReconnect = (connInfo) => {
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('handle reconnection: for room-connected ');
      // subcribe all remote streams and show them accrodingly in player
      let success = {streams: connInfo.streams, room:that, roomData: connInfo.room};
      for (let i = 0; i < success.streams.length; i++) {
        let info = that.remoteStreamsInfo.get(success.streams[i].getID());
        const optionsInput = info ? info.userReqOpt: undefined;
        that.subscribe(success.streams[i], optionsInput, (res) => {
          // check if all the streams subscribed properly and flag that subscribed streams are fine
          if (res === true || typeof res === 'object' && res.result == 0) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnect subscriber callback success id: ' + success.streams[i].getID());
          } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnect subscriber callback failed, could not reconnect', res);
            that.reconPubSubFailed(res);
            that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-error', message: res }));
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('api-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_reconnect_subscribe_failed,
                     { error: 'reconnect subscriber callback failed, couldnt reconnect', message: res },);
          }
        });
      }
      that.manageLiveTranscription();

        // publish all local streams
      const publishAllStreams = () => {
        // for all previous published local streams publish them and update the localstreams map
        that.localStreamsBeforeReconnect.forEach((localStream, id) => {
          if ((localStream.canvas === undefined) && (localStream.screen === undefined)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' reconnect publish, audio video data stream');
            that.localStreamsBeforeReconnect.remove(id);
            let pubOps = localStream.userRequestOptions;
            that.publish(localStream, pubOps, (response) => {
              if (response.result === 0) {
                success.publishId = response.id;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnected and stream published successfully');
                that.manageStatsSubscription(localStream);
                that.manageRecordingStatus();

                if (connInfo.mediaRecord) that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-record-on', message: {} }));
                if (that.muteInfo.room.audio) that.dispatchEvent({ type: 'room-muted', message: {} });
                if (localStream.selfMuteAudio === true) localStream.sendEvent('user-audio-muted');
                if (localStream.selfMuteVideo == true) localStream.sendEvent('user-video-muted');

                      // ugly hack for fixing ATVAV restriction at server side
                      // server says first published stream can not be canvas or share
                that.localStreamsBeforeReconnect.forEach((localStream, id) => {
                  const processAuxilaryRequest = (pubType, pubOptions) => {
                    that.localStreamsBeforeReconnect.remove(id);
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' reconnect publish, ' + pubType + ' stream');
                    that.socket.emitEvent ('auxilaryPublishRequests', {req:'start', pubType:pubType, override:true},(resp) => {
                      if (resp.result == __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result){
                        that.publish(localStream, pubOptions, (response) => {
                          if (response.result === 0) success.publishId = response.id;
                          else {
                            let errMsg = 'reconnect publish failed ' + pubType + '  stream failed';
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(errMsg +  " resp: " + JSON.stringify(response));
                            that.reconPubSubFailed(response);
                            that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-error', message: response }));
                            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('api-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_reconnect_publish_failed,
                                     {error: errMsg, message: response });
                          }
                        });
                      }else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warn('reconnect auxilaryPublishRequests() failed ' +pubType+ ' resp: '+JSON.stringify(resp));
                    });
                  };
                  if (localStream.canvas === true) processAuxilaryRequest('canvas', {canvas:true});
                  else if (localStream.screen === true) processAuxilaryRequest('screen', {screen:true});
                  else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(' unknown stream type ????????????');
                });
              } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' reconnect publishing failed, response for publish', response);
                that.reconPubSubFailed(response);
                that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-error', message: response }));
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('api-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_reconnect_publish_failed,
                     { error: 'reconnect publishing failed, response for publish', message: response },);
              }
            });
          }
        });
      };
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(" reconnect pub waitRoom: " +that.waitRoom+ " role: "+that.me.role+ " mode: " + that.mode);
      if (that.waitRoom === false && that.me.role != 'viewer' &&  that.me.role != 'audience' &&
                (that.mode !== 'lecture' || that.me.role === 'moderator')) {
        publishAllStreams();
      } else if ((that.me.role != 'viewer' &&  that.me.role != 'audience') && that.waitRoom) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Reconnect WaitRoom on no publish');
        that.addEventListener('wait-room-disabled', (arg) => {
          if (that.mode !== 'lecture') publishAllStreams();
        });
      } else if ((that.me.role != 'viewer' &&  that.me.role != 'audience') ||
                  (that.mode === 'lecture' && that.me.role !== 'moderator')) {
        if ((that.me.role != 'viewer' &&  that.me.role != 'audience'))
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' No publish - participant is viewer/audience');
        else __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' reconnection:: No publish - participant in lecture mode');
        if (that.floorGranted) {
          that.floorGranted = false;
          that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'release-floor', users: { clientId: that.clientId } }));
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info( true ?
                    'no audio&video' : 'lecture mode publisher');
      }
            // consider reconnection successfull , handle only when all subscribed and published
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(' setting reconnection state as false ');
      that.reconnectionState = false;
      that.manageNumTalker();
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('send network reconnected event');
      const networkReconnected = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'network-reconnected', error: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1164.result,
                                            message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1164.error });
      that.dispatchEvent(networkReconnected);
    };
    const mediaConnectionTimeout = (streamId, publisher) => {
      let info = {streams: [] };
      that.localStreams.forEach((stream, id) => { if (stream.state != 'connected') {
            info.streams.push({id: id, "type": "pub", state: stream.state});
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error (" pub stream not connected id: " + id); }});
      that.remoteStreams.forEach((stream, id) => { if (stream.state != 'connected'){
            info.streams.push({id: id, "type": "sub", state: stream.state});
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(" sub stream not connected id: " + id); }});
      if (info.streams.length) {
        info.client = { mode : that.isStreamingClient ? "streamer" : "regular",role : that.me.role,
                                device_type: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.device_type, sdk_version: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.product.version,
                                browser: {version: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.version, name: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name}
                              };
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("mediaConnectionTimeout () stream disc info: " + JSON.stringify(info));
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_media_connection_failed, info);
        validateProcessNetworkTimeout(false,true);
      }else {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("mediaConnectionTimeout ():  All streams in active state - Ignoring the event");
      }
      return;
    };

    const onRoomDisconnected = (msg) => {
        //that.reconnectionAllowed = false;
        //clearAll();
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(` onRoomDisconnected() : calling that.disconnect  with msg : ${JSON.stringify(msg)}`);
        if (msg == undefined) {
            msg = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].CC002;
        }
        that.disconnect(msg);
    };

    const hardMuteMic = (stream, muteOn, raiseEvent, delay, callback) => {
        if (stream.hardAudioMuted != muteOn) {
            const muteMicCallback = (resp) => {
                // if local mute happend and hardmute is set, hardmute set the preference and send user indication
                callback(((resp.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177.result) ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000 : resp));
            };
            stream.hardAudioMuted = muteOn;
            if (muteOn) {
                stream.muteAudio(muteMicCallback, raiseEvent, delay);
            } else {
                stream.unmuteAudio(muteMicCallback, raiseEvent, delay);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177.error });
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177);
        }
    };

    const hardMuteCam = (stream, muteOn, raiseEvent, delay, callback) => {
        if (stream.hardVideoMuted != muteOn) {
            const muteCamCallback = (resp) => {
                // if local mute happend and hardmute is set, hardmute set the preference and send user indication
                callback(((resp.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177.result) ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000 : resp));
            };
            stream.hardVideoMuted = muteOn;
            if (muteOn) {
                stream.muteVideo(muteCamCallback, raiseEvent, delay);
            } else {
                stream.unmuteVideo(muteCamCallback, raiseEvent, delay);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177.error });
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177);
        }
    };

    const setMediaDeviceMuteState = (muteOn, isHard, media, sendServerEvent, roomEvent, eventData, callback) => {
        if (!that.localStreams.size) {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1159.error });
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1159);
            return;
        }

        const checkAndDispatchEvent = (streamToSend, resp, eventData) => {
            if ((resp.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) && (eventData !== undefined)) {
                if (streamToSend) {
                    const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])(eventData);
                    stream.dispatchEvent(evt);
                } else {
                    const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])(eventData);
                    that.dispatchEvent(evt);
                }
            }
        };

        that.localStreams.forEach((stream, id) => {
            if (((media === 'audio') && stream.ifAudio() && (!isHard || (stream.hardAudioMuted != muteOn))) ||
                ((media === 'video') && stream.ifVideo() && (!isHard || (stream.hardVideoMuted != muteOn)))) {
                if (media === 'audio') {
                    if (isHard) {
                        stream.hardAudioMuted = muteOn;
                    }
                } else if (isHard) {
                    stream.hardVideoMuted = muteOn;
                }

                stream.setMediaDeviceMuteState(
                    muteOn, (media === 'audio'), (media === 'video'), sendServerEvent,
                    (resp) => { checkAndDispatchEvent((roomEvent ? undefined : stream), resp, eventData); callback(resp); },
                );
                return;
            }
            if (((media === 'audio') && stream.ifAudio()) || ((media === 'video') && stream.ifVideo())) {
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177.error });
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177);
            }
        });
    };

    const hardMuteMediaDevices = (muteOn, audio, video, sendServerEvent, callback, roomEvent, eventData) => {
        let eventSent = false;
        const checkAndDispatchStreamEvent = (stream, resp, roomEvent, eventData) => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`hardMuteMediaDevices callback resp : ${JSON.stringify(resp)}`);
            if ((resp.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) && eventData) {
                if (roomEvent) that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])(eventData));
                else stream.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["f" /* StreamEvent */])(eventData));
                eventSent = true;
            }
        };
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`hardMuteMediaDevices muteOn: ${muteOn} audio: ${audio} video: ${video} sendsendServerEvent : ${sendServerEvent}`);
        that.localStreams.forEach((stream, id) => {
            if (audio && stream.ifAudio()) {
                if (muteOn) {
                    that.muteInfo.stream.hard.audio = true;
                    stream.muteAudio((resp) => {
                        checkAndDispatchStreamEvent(stream, resp, roomEvent, eventData); callback(resp);
                    }, sendServerEvent, 0, false);
                } else {
                    that.muteInfo.stream.hard.audio = false;
                    stream.unmuteAudio((resp) => {
                        checkAndDispatchStreamEvent(stream, resp, roomEvent, eventData); callback(resp);
                    }, sendServerEvent, 0, false);
                }
                return;
            }
            if (video && stream.ifVideo()) {
                if (muteOn) {
                    that.muteInfo.stream.hard.video = true;
                    stream.muteVideo((resp) => {
                        checkAndDispatchStreamEvent(stream, resp, roomEvent, eventData); callback(resp);
                    }, sendServerEvent, 0, false);
                } else {
                    that.muteInfo.stream.hard.video = false;
                    stream.unmuteVideo((resp) => {
                        checkAndDispatchStreamEvent(stream, resp, roomEvent, eventData); callback(resp);
                    }, sendServerEvent, 0, false);
                }
            }
        });
        if (!eventSent && roomEvent && eventData) {
          const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])(eventData);
          that.dispatchEvent(evt);
        }
        if (callback) {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1159.error });
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1159);
        }
    };

    const mediaDeviceMuteOnJoin = (stream, audioInfo, videoInfo, raiseEvent) => {
        const logMessage = (callingFn, resp) => {
            if (resp.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`mediaDeviceMuteOnJoin() ${callingFn} audio: ${JSON.stringify(audioInfo)} video: ${JSON.stringify(videoInfo)} success`);
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`mediaDeviceMuteOnJoin() ${callingFn} audio: ${JSON.stringify(audioInfo)} video: ${JSON.stringify(videoInfo)} failed. result: ${JSON.stringify(resp)}`);
            }
        };
        if (videoInfo.local) {
          stream.muteVideo((resp) => { logMessage('videoSelfMuteCallback', resp); }, raiseEvent, 1000, true);
        }else if (stream.selfMuteVideo){
          stream.unmuteVideo((resp) => { logMessage('videoSelfUnmuteCallback', resp); }, raiseEvent, 1000, true);
        }
        if (videoInfo.hard) {
          stream.muteVideo((resp) => { logMessage('videoHardMuteCallback', resp); },raiseEvent, 1000, false);
        }else if (stream.hardVideoMuted){
          stream.unmuteVideo((resp) => { logMessage('videoHardUnmuteCallback', resp); },raiseEvent, 1000, false);
        }
        if (audioInfo.local) {
          stream.muteAudio((resp) => { logMessage('AudioSelfMuteCallback', resp); }, raiseEvent, 1000, true);
        }else if (stream.selfMuteAudio){
          stream.unmuteAudio((resp) => { logMessage('AudioSelfUnmuteCallback', resp); }, raiseEvent, 1000, true);
        }
        if (audioInfo.hard) {
          stream.muteAudio((resp) => { logMessage('AudioHardMuteCallback', resp); },raiseEvent, 1000, false);
        }else if (stream.hardAudioMuted){
          stream.unmuteAudio((resp) => { logMessage('AudioHardUnmuteCallback', resp); },raiseEvent, 1000, false);
        }
        /*
        let audioMuteCallback = (resp) => {
            logMessage("audioMuteCallback", resp);
            //do video unmute done after 1 sec to avoid blank video on both local view and remote subscribers
            if (!videoInfo.mute) {
                setTimeout(setMediaDeviceMuteState, 1000, false, videoInfo.hard, "video", false, true, undefined,
                    (resp) => { logMessage("videoUnmuteCallback", resp); });
            }
        };
        let videoMuteCallback = (resp) => {
            logMessage("videoMuteCallback", resp);
            //do audio hard mute
            if (audioInfo.mute)
                setMediaDeviceMuteState(true, audioInfo.hard, "audio", true, true, audioInfo.eventInfo, audioMuteCallback);
        };
        // hard-mute-room event not sending to app as  room mute sent in room-connected event
        //replace track for audio causing blank on remote. so in this case enable to false
        if (audioInfo.mute || videoInfo.mute)
            setMediaDeviceMuteState(videoInfo.mute, videoInfo.hard, "video", videoInfo.hard ? false : true, true,
                (videoInfo.mute ? videoInfo.eventInfo : undefined), videoMuteCallback);*/
    };

    const onHardMuteAudio = (arg, callback) => {
      that.hardMuteInitiator = false;
      hardMuteMediaDevices(true, true, false, true, callback, true, { type: 'hardmute-user-audio', message: arg });
    };

    const onHardUnmuteAudio = (arg, callback) => {
      that.hardMuteInitiator = false;
      hardMuteMediaDevices(false, true, false, true, callback, true,{ type: 'hardunmute-user-audio', message: arg });
    };

    const onHardMuteVideo = (arg, callback) => {
      hardMuteMediaDevices(true, false, true, true, callback, true, { type: 'hardmute-user-video', message: arg });
    };

    const onHardUnmuteVideo = (arg, callback) => {
      hardMuteMediaDevices(false, false, true, true, callback, true, { type: 'hardunmute-user-video', message: arg });
    };
    const onAuxilaryPublishEvents = (arg) => {
      switch (arg.evnt){
      case 'share-permission-mode-changed':{
        that.sharePermissions[arg.params.pubType].mode = arg.params.mode;
        if (that.isModerator() && (arg.params.mode == 'all' || arg.params.mode == 'moderators')) {
          that.sharePermissions[arg.params.pubType].approved = [];
          that.sharePermissions[arg.params.pubType].pending = [];
        }
      }
      break;
      case 'share-permission-requested': {
        if (that.isModerator()){
          if (that.sharePermissions[arg.params.pubType].pending.indexOf(arg.params.clientId) == -1)
            that.sharePermissions[arg.params.pubType].pending.push(arg.params.clientId);
        }else that.sharePermissions[arg.params.pubType].state = arg.evnt;
      }
      break;
      case 'share-permission-granted': {
        if (that.isModerator()){
          if (that.sharePermissions[arg.params.pubType].approved.indexOf(arg.params.clientId) == -1)
            that.sharePermissions[arg.params.pubType].approved.push(arg.params.clientId);
          let indx = that.sharePermissions[arg.params.pubType].pending.indexOf(arg.params.clientId);
          if (indx != -1) that.sharePermissions[arg.params.pubType].pending.splice(indx,1);
        }else that.sharePermissions[arg.params.pubType].state = arg.evnt;
      }
      break;
      case 'share-permission-denied':
      case 'share-permission-released': {
        if (that.isModerator()){
          let indx = that.sharePermissions[arg.params.pubType].approved.indexOf(arg.params.clientId);
          if (indx != -1) that.sharePermissions[arg.params.pubType].approved.splice(indx,1);
          indx = that.sharePermissions[arg.params.pubType].pending.indexOf(arg.params.clientId);
          if (indx != -1) that.sharePermissions[arg.params.pubType].pending.splice(indx,1);
        }else that.sharePermissions[arg.params.pubType].state = 'idle';
      }
      break;
      case 'share-permission-cancelled': {
        if (that.isModerator()){
          let indx = that.sharePermissions[arg.params.pubType].pending.indexOf(arg.params.clientId);
          if (indx != -1) that.sharePermissions[arg.params.pubType].pending.splice(indx,1);
        }
      }
      break;
      }
      that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.evnt, message: arg.params}));
    };

    const onShareStarted = (arg) => {
      that.shareDisplayWaitTimeoutSecs = 0;
      if (that.allStreamsActive){
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("onShareStarted() event : " + JSON.stringify(arg));
        adjustMainVideoQuality(true, that.canvasStatus);
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'share-started', message: { clientId: arg.clientId, name: arg.name, streamId: arg.streamId, layout: arg.layout } });
        that.shareStatus = true;
        if (that.clientId == arg.clientId) {
            that.isSharingClient = true;
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(` share-started event : ${JSON.stringify(evt)}`);
        that.dispatchEvent(evt);
      }else {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("onShareStarted() , all streams not active , storing event: " + JSON.stringify(arg));
        that.shareStatus = true;
        that.shareEventInfo = JSON.parse(JSON.stringify(arg));
      }
    };

    const onSwitchCodec = (arg) => {
        if (arg.result === 0 && arg.mediaConfiguration !== that.mediaConfiguration) {
            that.mediaConfiguration = arg.mediaConfiguration;
            that.localStreams.forEach((stream, streamID) => {
                stream.resetMediaConfiguration(arg.mediaConfiguration);
            });
        }
    };

    const onStopSharing = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stop sharing requested by client: ', arg.clientId);
        that.forcedStopSharing = true;
        console.log('that.forcedStopSharing: ', that.forcedStopSharing);
        if (that.isSharingClient) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stopScreenShare for current client');
            that.stopScreenShare(function (res) {
                if (res.result == 0) {
                }
            });
        }
        if (that.isCanvasSharingClient == true) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stopCanvasShare for current client');
            that.stopAnnotation(function (res) {
                if (res.result == 0) {
                }
            });
        }
    };

    const onUpdateLayout = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Update Layout requested by client: ', arg.clientId);
        if(that.clientId != arg.clientId) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'layout-updated', message: arg });
            that.dispatchEvent(evt);
        }
    };

    const onShareStopped = (arg) => {
        adjustMainVideoQuality(false, that.canvasStatus);
        const additionalOptions = {
            streamType: 'share',
            streamId: arg.streamId,
            negotiatedCodecs: {video: {codec: 'VP8' },audio: {codec: 'OPUS'},},
            externalIp: that.externalIp,
        };
        let evtMsg = { clientId: arg.clientId, name: arg.name, streamId: arg.streamId };
        console.log('that.forcedStopSharing: ', that.forcedStopSharing);
        if(that.forcedStopSharing) evtMsg.stoppedBy = 'moderator';
        that.forcedStopSharing = false;
        that.shareStatus = false;
        if (that.shareEventInfo) that.shareEventInfo = undefined;
        console.log(` share-stopped eventMsg : ${JSON.stringify(evtMsg)}`);
        that.dispatchEvent({ type: 'share-stopped', message:evtMsg});
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('additionalOptions: ', additionalOptions);
        that.createEventLog('clientStreamShareStopped', additionalOptions);
        that.isSharingClient = false;

    };


    const onScreenShareOverride = (arg) => {
        console.log('onScreenShareOverride');
        if(that.isSharingClient) {
            that.stopScreenShare(function (res) {
                console.log('stopScreenShare response: ', res);
                if (res.result == 0) {
                }
            });

            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'stop-old-screen-share', message: { clientId: that.clientId } });
            that.dispatchEvent(evt);

        }
    };

    const onUserAudioMuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-audio-muted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/
        const user = that.userList.get(arg.clientId);
        user.audioMuted = arg.user.audioMuted;
        that.userList.set(arg.clientId, arg.user);
        if (arg.clientId != that.clientId)
          that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: 'user-audio-muted', clientId: arg.clientId }));
        if (arg.clientId == that.clientId){
          that.localStreams.forEach((stream) => {
            if (!stream.ifCanvas() && !stream.ifScreen()  && stream.local && stream.isAudioMuted())
              that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: 'user-audio-muted', clientId: arg.clientId }));
          });
        }else
          that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: 'user-audio-muted', clientId: arg.clientId }));
    };

    const onUserAudioUnmuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-audio-unmuted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/
        const user = that.userList.get(arg.clientId);
        user.audioMuted = arg.user.audioMuted;
        that.userList.set(arg.clientId, arg.user);
        if (arg.clientId == that.clientId){
          that.localStreams.forEach((stream) => {
            if (!stream.ifCanvas() && !stream.ifScreen()  && stream.local && !stream.isAudioMuted())
              that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: 'user-audio-unmuted', clientId: arg.clientId }));
          });
        }else
          that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: 'user-audio-unmuted', clientId: arg.clientId }));
    };

    const onUserVideoMuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-video-muted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/
        const user = that.userList.get(arg.clientId);
        user.videoMuted = arg.user.videoMuted;
        that.userList.set(arg.clientId, arg.user);

        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: 'user-video-muted', clientId: arg.clientId });
        that.dispatchEvent(evt);
    };

    const onUserVideoUnmuted = (arg) => {
        /*that.remoteStreams.forEach(function(value,key){
            if(value.clientId === arg.clientId){
                const evt2 = StreamEvent({ type: 'user-video-unmuted', stream: value});
                value.dispatchEvent(evt2);
            }
        });*/

        const user = that.userList.get(arg.clientId);
        user.videoMuted = arg.user.videoMuted;
        that.userList.set(arg.clientId, arg.user);

        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["g" /* UserEvent */])({ type: 'user-video-unmuted', clientId: arg.clientId });
        that.dispatchEvent(evt);
    };

    const adjustMainVideoQuality = (shareOn, canvasOn) => {
        that.localStreams.forEach((stream) => {
            if (!stream.ifCanvas() && !stream.ifScreen() && stream.video && stream.local) {
                if (that.maxVideoLayers > 1) {
                    const quality = (shareOn || canvasOn) ? 'ND' : token.roomMeta.settings.quality;
                    const maxVideoBitrates = {
                        0: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_bandwidth_range[quality][2].max * 1000,
                        1: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_bandwidth_range[quality][1].max * 1000,
                        2: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_bandwidth_range[quality][0].max * 1000,
                    };
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`updating main video simulcast bps: ${JSON.stringify(maxVideoBitrates)}`);
                    stream.updateSimulcastLayersBitrate(maxVideoBitrates);
                }
            }
        });
    };
    // It publishes the stream provided as argument. Once it is added it throws a
    // StreamEvent("stream-added").
    that.publish = (streamInput, optionsInput = {}, callback = () => { }) => {
        if (typeof callback === 'function') {
            const stream = streamInput;
            const options = optionsInput;
            if (that.subscription && ((!that.subscription.audio_video && streamInput.video) ||
                (!that.subscription.audio_only && !that.subscription.audio_video && streamInput.audio) ||
                (!that.subscription.audio_video && streamInput.canvas) ||
                (!that.subscription.audio_video && streamInput.share))) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Licence error : feature not supported subscription - av: ${that.subscription.audio_video} audio: ${that.subscription.audio_only} canvas: ${that.subscription.audio_video} share: ${that.subscription.audio_video} req audio: ${streamInput.audio} video: ${streamInput.video} share: ${streamInput.share} canvas: ${streamInput.canvas}`);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170.error });
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
                return;
            }

            if (streamInput.video && !streamInput.canvas && !streamInput.share) {
                if (stream.videoStream == null) {
                    //streamInput.video = false;
                }
                else {
                    let configRoomVideoRes = streamInput.videoSize == undefined ? true : false;
                    const res = validateVideoResolution(streamInput, true);
                    if (res.result !== __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(` Failed : room.publish video size invalid video size req: ${streamInput.videoSize} default : ${JSON.stringify(videoResolutionRange)}`);
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: `room.publish video size invalid video size req: ${streamInput.videoSize} default : ${JSON.stringify(videoResolutionRange)}` });
                        callback(res);
                        return;
                    }
                    if ((configRoomVideoRes && streamInput.videoSize !== undefined &&
                         __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.device_type !== 'mobile') &&
                        ((streamInput.videoSize[0] != __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_resolution_range["Default"].min.wdith) ||
                         (streamInput.videoSize[1] != __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_resolution_range["Default"].min.height) ||
                         (streamInput.videoSize[2] != __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_resolution_range["Default"].min.wdith) ||
                         (streamInput.videoSize[3] != __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_resolution_range["Default"].max.height))){
                      stream.setVideoQualityParams(streamInput.videoSize[0], streamInput.videoSize[1],
                                                  streamInput.videoSize[2],streamInput.videoSize[3])
                    }
                    streamInput.maxVideoLayers = that.maxVideoLayers;
                }
            }
            if(optionsInput && optionsInput != undefined) {
              try {
                stream.userRequestOptions = JSON.parse(JSON.stringify(optionsInput));
              } catch(error) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("Not a valid json");
              }
            }

            if (streamInput.audio && !streamInput.canvas && !streamInput.share) {
                if (stream.audioStream == null)
                    streamInput.audio = false;
            }

            locStrm = streamInput;
            if (that.reconnectionState === false) {
                if (streamInput.ifScreen()) {
                    //sharePublishOptions.forceTurn =  options.forceTurn ? options.forceTurn :  false;
                    options.forceTurn = sharePublishOptions.forceTurn;
                } else if (streamInput.ifCanvas()) {
                    //canvasPublishOptions.forceTurn =  options.forceTurn ? options.forceTurn :  false;
                    options.forceTurn = canvasPublishOptions.forceTurn;
                    canvasPublishOptions.canvasType = options.canvasType;
                } else {
                    avOptions.publish.forceTurn = options.forceTurn ? options.forceTurn : false;
                    sharePublishOptions.forceTurn = avOptions.publish.forceTurn;
                    canvasPublishOptions.forceTurn = avOptions.publish.forceTurn;
                    if (options.maxVideoBW || options.minVideoBW || options.maxVideoFps) {
                        streamInput.setVideoParamsRange(options.maxVideoBW, options.minVideoBW, options.maxVideoFps, undefined, false);
                    }
                    if (spec.maxVideoBW || spec.minVideoBW || spec.maxVideoFps) {
                        streamInput.setVideoParamsRange(spec.maxVideoBW, spec.minVideoBW, spec.maxVideoFps, undefined, true);
                    }
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(` options.maxVideoBW: ${options.maxVideoBW} spec.maxVideoBW: ${spec.maxVideoBW}`);
                    if (options.maxVideoBW == undefined) {
                        options.maxVideoBW = spec.maxVideoBW;
                        options.minVideoBW = spec.minVideoBW;
                    }
                }
            } else if (streamInput.ifScreen()) {
                options.forceTurn = sharePublishOptions.forceTurn;
            } else if (streamInput.ifCanvas()) {
                options.forceTurn = canvasPublishOptions.forceTurn;
                options.canvasType = canvasPublishOptions.canvasType;
            } else {
                options.forceTurn = avOptions.publish.forceTurn;
            }
            options.maxVideoBW = options.maxVideoBW || spec.defaultVideoBW;
            if (options.maxVideoBW > spec.maxVideoBW) options.maxVideoBW = spec.maxVideoBW;
            if (options.minVideoBW === undefined) options.minVideoBW = 0;
            if (options.minVideoBW > spec.defaultVideoBW) options.minVideoBW = spec.defaultVideoBW;
            if (options.forceTurn) { stream.forceTurn = options.forceTurn; }
            options.simulcast = options.simulcast || false;
            options.muteStream = {audio: stream.ifCanvas() ? true : stream.isAudioMuted(),video: stream.isVideoMuted(),};
            that.muteAudioOnJoin = !!options.audioMuted;
            that.muteVideoOnJoin = !!options.videoMuted;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`Publish forceTurn: ( ${options.forceTurn},${avOptions.publish.forceTurn} ) reconnect state: ${that.reconnectionState}`);

            /*if(that.mute && that.me.role === 'participant' && !stream.ifScreen())
            {
                stream.muteAudioNotSelf();
            }*/

            // 1- If the stream is not local or it is a failed stream we do nothing.
            // if (stream && stream.local && !stream.failed && !localStreams.has(stream.getID())) {}
            if (stream && stream.local && !stream.failed) {
                if (that.waitRoom) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Publish() : failed Moderator not present and  waiting for moderator ');
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1130.error });
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1130);
                    return;
                }
                // 2- Publish Media Stream to Client-Controller
                if (stream.ifMedia()) {
                    if (stream.ifExternal()) {
                        publishExternal(stream, options, callback);
                    } else {
                        if (that.videoMuteOnJoin != undefined) delete that.videoMuteOnJoin;
                        if (that.audioMuteOnJoin != undefined) delete that.audioMuteOnJoin;
                        if (((that.reconnectionState || stream.reconnect ) && !stream.ifCanvas() && !stream.ifScreen())){
                          that.audioMuteOnJoin = { local: stream.selfMuteAudio, hard: stream.hardAudioMuted};
                          if(stream.selfMuteVideo || stream.hardVideoMuted) {
                            const publishVideoOnunmuteVideo = (result) => {
                                if (result.result == 0) {
                                    stream.muteVideo(() => { }, false, 0, true, true);
                                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Publish stream options after unmute video success');
                                } else {
                                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Publish stream opt after unmute video failed :${JSON.stringify(result)}`);
                                }
                                publishVcxRtc(stream, options, callback);
                            };
                            that.videoMuteOnJoin = { local: stream.selfMuteVideo, hard: stream.hardVideoMuted };
                            stream.unmuteVideo(publishVideoOnunmuteVideo, false, 0, !stream.hardVideoMuted);
                          }else{
                            if (!stream.video || stream.isVideoMuted()) that.videoMuteOnJoin = { local: true, hard: false};
                            if (!stream.audio || stream.isAudioMuted()) that.audioMuteOnJoin.local = true;
                            publishVcxRtc(stream, options, callback);
                          }
                        } else {
                          if (!stream.ifCanvas() && !stream.ifScreen()){
                            if (!stream.video || options.videoMuted || (options.muteStream && options.muteStream.video))
                              that.videoMuteOnJoin = { local: true, hard: false};
                            if (!stream.audio || options.audioMuted || (options.muteStream && options.muteStream.audio))
                              that.audioMuteOnJoin = { local: true, hard: false};
                          }
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Publish stream options : ', options);
                            publishVcxRtc(stream, options, callback);
                        }
                    }
                } else if (stream.ifData()) {
                    publishData(stream, options, callback);
                }
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Trying to publish invalid stream');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_publish_failed, { stream });
                callback(undefined, 'Invalid Stream');
                const additionalOptions = {
                    streamId: stream.getID(),
                    selectedCandidates: { local: '', remote: '' },
                    negotiatedCodecs: {
                        video: {
                            codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration,
                        },
                        audio: {
                            codec: 'OPUS',
                        },
                    },
                    selectedCam: stream.video.deviceId,
                    selectedMic: stream.audio.deviceId,
                    error: 'Invalid stream',
                    externalIp: that.externalIp,
                };
                that.createEventLog('clientStreamPublishFailed', additionalOptions);
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('publish() invalid param - callback');
        }
    };

    const onRoomRecordStarted = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-record-on', message: { moderatorId: response.moderatorId } });
        that.dispatchEvent(connectEvt);
    };

    const onRoomRecordStopped = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-record-off', message: { moderatorId: response.moderatorId } });
        that.dispatchEvent(connectEvt);
    };

    const onRoomLiveRecordStarted = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-live-recording-on', message: { message: 'live recording is running' } });
        that.dispatchEvent(connectEvt);
    };

    const onRoomLiveRecordStopped = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-live-recording-off', message: { message: '' } });
        that.dispatchEvent(connectEvt);
    };

    const onRoomLiveRecordFailed = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-live-recording-failed', message: { error: response.error } });
        that.dispatchEvent(connectEvt);
    };

    const onChangeLayout = (response) => {
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'change-layout', message: { layout: response.layout } });
        that.dispatchEvent(connectEvt);
    };

    const onRoomTranscriptionStarted = (response) => {
        that.liveRoomTranscription = true;
        that.transcriptionLanguage = response.language;
        const transcriptionEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-transcription-on', message: { language: response.language} });
        that.dispatchEvent(transcriptionEvt);
    };


    const onRoomTranscriptionStopped = (response) => {
        that.liveRoomTranscription = false;
        if(that.liveTranscription === false) that.transcriptionLanguage = '';
        const transcriptionEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-transcription-off', message: {}});
        that.dispatchEvent(transcriptionEvt);
    };


    const onSelfTranscriptionStarted = (response) => {
        that.liveTranscription = true;
        that.transcriptionLanguage = response.language;
        const transcriptionEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'self-transcription-on', message: { language: response.language} });
        that.dispatchEvent(transcriptionEvt);
    };


    const onSelfTranscriptionStopped = (response) => {
        that.liveTranscription = false;
        if(that.liveRoomTranscription === false) that.transcriptionLanguage = '';
        const transcriptionEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'self-transcription-off', message: {}});
        that.dispatchEvent(transcriptionEvt);
    };

    const processMediaActivationEvent = (reason) => {
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("processMediaActivationEvent () reason: " + reason);
      that.mediaActivationDelaySecs = 0;
      if (mediaActivationDelayTimer) {
        clearTimeout(mediaActivationDelayTimer);
        mediaActivationDelayTimer = undefined;
      };
      if (that.activeTalkersList2Process) {
        onNewActiveTalker(that.activeTalkersList2Process);
        that.activeTalkersList2Process = undefined;
      }
    }
    const onNewActiveTalker = (res) => {
        if (that.mediaActivationDelaySecs) {
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("onNewActiveTalker() mediaActivationDelaySecs : " + that.mediaActivationDelaySecs);
          if (mediaActivationDelayTimer == undefined){
            mediaActivationDelayTimer =
              setTimeout(processMediaActivationEvent.bind(this), that.mediaActivationDelaySecs*1000, 'timeout');
          }
          that.activeTalkersList2Process = JSON.parse(JSON.stringify(res));
          return;
        }
        // safari is not sending REMB for  subscriber channels.. workaround - read stats and send to server
        if ((__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'safari') && (that.sendRecvBitrateStats === false)) {
            sendSubscribersBitrate();
        }
        /*if(res.active === false){
            that.localStreams.forEach(function(value,key){
                if(value.ifVideo() && !value.ifScreen()){
                    value.muteNonATPubVideo();
                }
            });
        }else if(res.active === true){
            that.localStreams.forEach(function(value,key){
                if(value.ifVideo() && !value.ifScreen()){
                    value.unmuteNonATPubVideo();
                }
            });
        } */
        if (that.nonTalkerMediaParams && res.active != localMediaStreamInUse){
          let kbps, fps;
          if (res.active){
            if (localVideoStreamATStateBw == undefined) localVideoStreamATStateBw = spec.maxVideoBW;
            if (spec.minVideoBW != undefined ){
               kbps = {min: spec.minVideoBW, max: localVideoStreamATStateBw};
               fps = {max: spec.maxVideoFps};
            }
          } else {
              kbps = {min: that.nonTalkerMediaParams.video.bw, max: that.nonTalkerMediaParams.video.bw};
              fps =  {max:that.nonTalkerMediaParams.video.fps};
          }
          if (kbps != undefined){
            localMediaStreamInUse = res.active;
            that.localStreams.forEach(function(stream,key){
              if(stream.ifVideo() && !stream.ifScreen()&& !stream.ifCanvas()){
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug ("onActiveList (): setting video param for AT: " + res.active +
                             " kbps: "  + kbps.max + " fps:" + fps.max);
                stream.setVideoParamsRange(kbps.max, kbps.min, fps.max, undefined, true);
              }
            });
          }
        }
        const aTList = new Map();
        for (let list = 0; list < res.activeList.length; list++) {
          if (that.remoteStreams.getAll()[res.activeList[list].streamId]){
            if (res.activeList[list].mediatype === 'audio' && that.videoMutedUsers[res.activeList[list].clientId]) {
                that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly = true;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Recieved active talker list, videomuted: ${res.activeList[list].videomuted} reason: ${res.activeList[list].reason}`);
                that.remoteStreams.getAll()[res.activeList[list].streamId].setVideoMutedMessage(res.activeList[list]);
                delete that.videoMutedUsers[res.activeList[list].clientId];
            } else if (res.activeList[list].mediatype === 'audioOnly') {
                that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly = true;
            }
            if (that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly && res.activeList[list].mediatype === 'audiovideo') {
                delete that.remoteStreams.getAll()[res.activeList[list].streamId].audioOnly;
            }
            that.remoteStreams.getAll()[res.activeList[list].streamId].reloadPlayer(
                res.activeList[list],
                avOptions.subscribe.imageOnVideoMute,
            );
            aTList.set(res.activeList[list].streamId, res.activeList[list]);
            const talkerEntry = playerATList.get(res.activeList[list].streamId);
            if (talkerEntry && (talkerEntry.mediatype != res.activeList[list].mediatype)) {
                switch (res.activeList[list].mediatype) {
                    case 'audiovideo':
                    case 'video':
                        that.remoteStreams.getAll()[res.activeList[list].streamId].setVideoMutedMessage(res.activeList[list]);
                        if (that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet) {
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].muteSubscriberStreamVideo(false);
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].setBlankFrameOnSubscriberVideoStream(false);
                            delete that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet;
                        }
                        break;

                    case 'audio':
                    case 'audioOnly':
                        that.remoteStreams.getAll()[res.activeList[list].streamId].setVideoMutedMessage(res.activeList[list]);
                        if (!that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet) {
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].setBlankFrameOnSubscriberVideoStream(true);
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].setBlankFrameOnSubscriberVideoStream(false);
                            //that.remoteStreams.getAll()[res.activeList[list].streamId].muteSubscriberStreamVideo(true);
                            that.remoteStreams.getAll()[res.activeList[list].streamId].blankFrameSet = true;
                        }
                        break;

                    default:
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('mediatype not handled entry:', JSON.stringify(res.activeList[list]));
                        break;
                }
                playerATList.set(res.activeList[list].streamId, res.activeList[list]);
            } else if (!talkerEntry) {
                playerATList.set(res.activeList[list].streamId, res.activeList[list]);
            }
          }else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("onNewActiveTalker() remote stream undefined streamId: " + res.activeList[list].streamId);
          }
        }
        that.activeTalkerList = aTList;
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'active-talkers-updated', message: { activeList: res.activeList, active: res.active } });
        that.dispatchEvent(evt);
        if (!that.allStreamsActive){
          that.allStreamsActive = true;
          if (that.shareStatus && that.shareEventInfo) {
            onShareStarted(that.shareEventInfo);
            that.shareEventInfo = undefined;
          }
          if (that.streamsHealthTimerId == 0){
            setMediaConnectionTimer (false,0, false);
            that.streamsHealthTimerId = setInterval(checkAndProcessStreamsHealth, 10000);
          }
        }
    };

    that.startRecord = (callback = () => { }) => {
        if (typeof (callback) === 'function') {
            that.startRecording(undefined, callback);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('startRecord() invalid param - callback');
        }
    };

    that.stopRecord = (callback = () => { }) => {
        if (typeof (callback) === 'function') {
            that.stopRecording(undefined, callback);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('stopRecord() invalid param - callback');
        }
    };

    // streaming
    const isValidUrl = (s) => {
        const regexp = /(http|https|rtmp|rtmps):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
        return regexp.test(s);
    };

    that.startStreaming = (streamingConfig, callback = () => { }) => {
        if (typeof callback === 'function' && typeof streamingConfig === 'object' && streamingConfig.hasOwnProperty('rtmpDetails')) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('start streaming called');
            let allow = true;

            if (that.me.role !== 'moderator') {
                allow = false;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('user is trying to start streaming and he is not a moderator');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: `startStreaming - ${__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7008.desc}` });
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7008);
                return;
            }


            if (streamingConfig.rtmpDetails === undefined) {
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: `startStreaming - ${__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7009.desc}` });
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7009);
                return;
            }

            if (streamingConfig.rtmpDetails.rtmpUrl !== undefined) {
                let urlArray = streamingConfig.rtmpDetails.rtmpUrl.split(",");
                if (urlArray.length > 3) {
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7101);
                    return;
                }
            }

            // to do validate the regex and confirm if rtmpdetails and urlDetails are configured properly
            if (!isValidUrl(streamingConfig.rtmpDetails.rtmpUrl)) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' invalid rtmp or page input url');
                allow = false;
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: `startStreaming - ${__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7102.desc}` });
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7102);
                return;
            }
            //    streamingConfig.options = { confNum: '12345', roomId: '9876' };
            //    streamingConfig.rtmpDetails = { rtmpUrl: 'rtmp://a.rtmp.youtube.com/live2/4rjb-hprf-7wf5-9923' };
            //    streamingConfig.urlDetails = { url: 'https://vc-manu.vcloudx.com:9074/room/?token=', layOut: {} };
            let result = {};
            if (that.state === DISCONNECTED /*&& validate the rtmp url details*/) {
                result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7103;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' room is disconnected');
                callback(result);
                return;
            }
            if (!(callback && typeof callback === 'function')) {
                var callback = (res) => {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback streaming response ', res);
                };
            }
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('start streaming called with callback ');
            // fine send the start streaming signal
            //    let allow = (that.subscription && (that.subscription.recording === false)) ? false : true;
            if (allow) {
                socket.sendMessage('startStreaming', streamingConfig, (result, error) => {
                    if (result === null) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on start streaming', error);
                        if(error.result !== undefined){
                          callback(error);
                          return;
                        } else if(error.status !== undefined) {
                          //    EL.error('room-event', customEvents.event_stop_recording_failed, { error: error });
                          var response = {result: error.status.resultCode, error: 'streaming error', desc: error.status.error.errorDesc, status: error.status};
                          callback(response);
                          return;
                        }
                    } else {
                      var resp = {result: result.status.resultCode, error: '', desc: '', status: result.status};
                      callback(resp, error);
                    }
                });
            } else {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7000);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('startStreaming() invalid param - streamingConfig/callback');
        }
    };

    that.stopStreaming = (param1, param2) => {
        let callback, options;
        if (param1 != undefined && typeof param1 === 'function') {
          callback = param1;
        } else if(param2 != undefined  && typeof param2 === 'function') {
          if (param1 != undefined){
            options = param1;
          }
          callback = param2;
        }
        if (typeof callback === 'function') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stop streaming called');
            if (that.me.role !== 'moderator') {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('user is trying to stop streaming and he is not a moderator');
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7044);
                return;
            }
            var streamingConfig = {};
            streamingConfig.options = {
                // @todo - should be part of the config
                confNum: '12345',
                roomId: '9876',
            };
            streamingConfig.rtmpDetails = {
                // @todo - should be part of the config
                rtmpUrl: 'rtmp://a.rtmp.youtube.com/live2/4rjb-hprf-7wf5-9923',
            };
            streamingConfig.urlDetails = {
                // @todo - should be part of the config
                url: 'https://vc-manu.vcloudx.com:9074/room/?token=',
                layOut: {},
            };
            let result = {};
            if (that.state === DISCONNECTED /*&& validate the rtmp url details*/) {
                result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7045;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' room is disconnected');
                callback(result);
                return;
            }
            if (!(callback && typeof callback === 'function')) {
                callback = (res) => {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback streaming response ', res);
                };
            }
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stop called with callback ');
            // fine send the stop streaming signal
            const allow = true;
            if (allow) {
                socket.sendMessage('stopStreaming', streamingConfig, (result, error) => {
                    if (result === null) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on stop streaming', error);
                        if(error.status !== undefined) {
                          var response = {result: error.status.resultCode, error: 'streaming error', desc: error.status.error.errorDesc, status: error.status};
                          callback(response);
                          return;
                        }
                    } else {
                      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stop streaming');
                      var resp = {result: result.status.resultCode, error: '', desc: '', status: result.status};
                      callback(resp, error);
                    }
                });
            } else {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7000);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('stopStreaming() invalid param - streamingConfig/callback');
        }
    };
    that.setStreamingParams = function (config, callback) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('set Streaming Params called');
        if (that.me.role !== 'moderator') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('User should be a moderator user to change Streaming params');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7072);
            return;
        }
        let result = {};
        if (that.state === DISCONNECTED) {
            result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7078;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' room is disconnected');
            callback(result);
            return;
        }
        if (!(callback && typeof callback === 'function')) {
            var callback = (res) => { __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback Streaming params change response ', res); };
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Streaming params change called with callback ');
        // fine send the Streaming params change signal
        const allow = true;
        if (allow) {
            socket.sendMessage('setStreamingParams', config, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on Streaming param change: ', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_streaming_param_change_failed, { error, message: error.status.error });
                    callback(error);
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Streaming param change Success');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_streaming_param_change_success, { error: {} });
                callback(result, error);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7072.desc = 'Streaming param change failed';
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7072);
        }
    };
    // end streaming

    // start Live Recording
    // Room API to start Live Recording, called as room.startLiveRecording(recordingConfig, callback)
    // recordingConfig : { urlDetails: {url: 'URL of view client ex: https://rtmp.enablex.io/?token=', layOut: {} } };
    that.startLiveRecording = function (recordingConfig, callback) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('start Live Recording called');
        let allow = true;

        if (that.me.role !== 'moderator') {
            allow = false;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('User should be a moderator to start live recording');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7201);
            return;
        }

        // to do validate the regex and confirm if urlDetails are configured properly
        /*if (recordingConfig.urlDetails !== undefined && recordingConfig.urlDetails.url !== undefined && !isValidUrl(recordingConfig.urlDetails.url)) {
            Logger.info(' invalid page input url');
            allow = false;
            callback(customErrors.error_7202);
            return;
        }*/
        let result = {};
        if (that.state === DISCONNECTED) {
            result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7203;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' room is disconnected');
            callback(result);
            return;
        }
        if (!(callback && typeof callback === 'function')) {
            var callback = (res) => { __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback Live recording response ', res); };
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('start Live Recording called with callback ');
        // fine send the start live recording signal
        if (allow) {
            socket.sendMessage('startLiveRecording', recordingConfig, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on start Live Recording', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_live_recording_failed, { error, message: error.message});
                    if(error.status !== undefined) {
                      var response = {result: error.status.resultCode, error: 'live recording error', desc: error.status.error.errorDesc};
                      callback(response);
                      return;
                    }
                }
                if(result.status.resultCode === 7014){
                  roomRecordStatus = true; // Live Recording Failed, Fallback to legacy success
                }
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_live_recording_success, { error: {} });
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Start Live Recording Success');
                var resp = {result: result.status.resultCode, error: '', desc: ''};
                callback(resp, error);
            });
        } else {
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7204);
        }
    };

    that.stopLiveRecording = (callback = () => { }) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stop Live Recording called');
        if (that.me.role !== 'moderator') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('User should be a moderator user to start live recording');
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7036);
            return;
        }
        var recordingConfig = {};
        recordingConfig.urlDetails = { url: '', layOut: {} };
        let result = {};
        if (that.state === DISCONNECTED) {
            result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7037;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' room is disconnected');
            callback(result);
            return;
        }
        if (!(callback && typeof callback === 'function')) {
            var callback = (res) => { __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback Live Recording response ', res); };
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stop Live Recording called with callback ');
        // fine send the stop Live Recording signal
        const allow = true;
        if (allow) {
            socket.sendMessage('stopLiveRecording', recordingConfig, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on stop stop live recording', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_live_recording_failed, { error, message: error.message });
                    if(error.status !== undefined) {
                      var response = {result: error.status.resultCode, error: 'live recording error', desc: error.status.error.errorDesc};
                      callback(response);
                      return;
                    }
                    return;
                }
                if(result.status.resultCode === 7034) {
                  roomRecordStatus = false;
                  result.status.resultCode = 0;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stop Live Recording Success');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_live_recording_success, { error: {} });
                var resp = {result: result.status.resultCode, error: '', desc: ''};
                callback(resp, error);
            });
        } else {
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7204);
        }
    };

    that.setLiveRecordingParams = function (config, callback) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('set Live Recording Params called');
        if (that.me.role !== 'moderator') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('User should be a moderator user to change live recording params');
            __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7071.desc = 'Only moderator can change live recording params';
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7071);
            return;
        }
        let result = {};
        if (that.state === DISCONNECTED) {
            result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7079;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' room is disconnected');
            callback(result);
            return;
        }
        if (!(callback && typeof callback === 'function')) {
            var callback = (res) => { __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback Live Recording params change response ', res); };
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Live Recording params change called with callback ');
        // fine send the Live Recording param change signal
        const allow = true;
        if (allow) {
            socket.sendMessage('setLiveRecordingParams', config, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on live recording param change: ', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_live_recording_param_change_failed, { error, message: error.status.error });
                    callback(error);
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Live Recording param change Success');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_live_recording_param_change_success, { error: {} });
                callback(result, error);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7071.desc = 'live recording param change failed';
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_7071);
        }
    };
    // end Live Recording

    // API to invalidate Transcoding
    that.invalidateTranscoding = function (config, callback) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Invalidate Transcoding called');
        /*if (that.me.role !== 'moderator') {
          Logger.warning('User should be a moderator user to invalidate Transcoding');
          customErrors.error_7001.desc = 'Only moderator can invalidate Transcoding';
          callback(customErrors.error_7001);
          return;
          }*/
        let result = {};
        if (that.state === DISCONNECTED) {
            result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8000;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' room is disconnected');
            callback(result);
            return;
        }
        if (!(callback && typeof callback === 'function')) {
            var callback = (res) => { __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback Invalidate Transcoding response ', res); };
        }
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Invalidate Transcoding called with callback ');
        // fine send the Invalidate Transcoding signal
        const allow = true;
        if (allow) {
            socket.sendMessage('invalidateTranscoding', config, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on Invalidate Transcoding', error);
                    callback(error);
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Invalidate Transcoding');
                callback(result, error);
            });
        } else {
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8000);
        }
    };
    // end Invalidate Transcoding

    //request floor (old chairControl)
    that.requestFloor = (callback = () => { }) => {
        if (typeof callback === 'function') {
            processFloorRequest(that.clientId, 'requestFloor', (result, error) => {
                callback(result, error);
                if (result !== undefined) {
                    that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
                }
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('requestFloor() invalid param - callback');
        }
    };

    that.cancelFloor = (callback = () => { }) => {
        if (typeof callback === 'function') {
            processFloorRequest(that.clientId, 'cancelFloor', (result, error) => {
                callback(result, error);
                if (result !== null) {
                    that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
                }
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('cancelFloor() invalid param - callback');
        }
    };

    that.finishFloor = (callback = () => { }) => {
        if (typeof callback === 'function') {
            processFloorRequest(that.clientId, 'finishFloor', (result, error) => {
                localStreams.forEach((stream, id) => {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`finishFloor: unpulish ${stream.getID()}::::${id}`);
                    that.unpublish(stream, (arg) => { });
                });
                that.floorGranted = false;
                callback(result, error);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('finishFloor() invalid param - callback');
        }
    };

    //grant floor (grantFloor,relaseFloor,denyFloor)
    that.grantFloor = (options, callback = () => { }) => {
        if (typeof callback === 'function') {
            processFloorRequest(options, 'grantFloor', (result, error) => {
                if (result !== null) {
                  that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
                  that.cCapprovedHands.push({clientId: options, moderatorId: that.clientId});
                }
                callback(result, error);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('grantFloor() invalid param - callback');
        }
    };

    //---
    that.denyFloor = (options, callback = () => { }) => {
        if (typeof callback === 'function') {
            processFloorRequest(options, 'denyFloor', (result, error) => {
                callback(result, error);
                if (result !== null) {
                    that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
                }
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('denyFloor() invalid param - callback');
        }
    };
    //---

    that.relaseFloor = (options, callback = () => { }) => {
      that.releaseFloor(options,callback);
    };
    that.releaseFloor = (options, callback = () => { }) => {
        if (typeof callback === 'function') {
            processFloorRequest(options, 'releaseFloor', (result, error) => {
                if (result !== null) {
                  that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
                  checkAndRemoveGrantedFloor(options);
                }
                callback(result, error);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('releaseFloor() invalid param - callback');
        }
    };

    that.inviteToFloor = (client_id, callback = () => { }) => {
        let data = { clientId: client_id };
        that.socket.sendMessage('inviteToFloor', data, function (response) {
            if (response.result === 0) {
                that.cCrequest.push({ clientId: data.clientId, name: that.userList.get(client_id).name, type: "requested" });
            }
            callback(response);
        });
    };


    that.acceptInviteFloorRequest = (callback = () => { }) => {
        processFloorRequest(that.clientId, 'acceptFloor', (result, error) => {
            callback(result, error);
            if (result !== undefined) {
                that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
            }
        });
    };

    that.rejectInviteFloor = (callback = () => { }) => {
        processFloorRequest(that.clientId, 'rejectFloor', (result, error) => {
            that.floorInvited = false;
            callback(result, error);
            if (result !== undefined) {
                that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
            }
        });
    };


    that.cancelFloorInvite = (id, callback = () => { }) => {
        processFloorRequest(id, 'cancelFloorInvite', (result, error) => {
            callback(result, error);
            if (result !== undefined) {
                that.cCrequest = that.cCrequest.filter(req => req.clientId !== options);
            }
        });
    };


    //chairControl mute all
    that.chairControlMuteAll = (callback = () => { }) => {
        that.socket.sendEvent('room-muted', (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on floor request', error);
                callback(undefined, error);
                // return;
            } else {
                callback(result);
            }
        });
    };

    //chairControl un-mute all
    that.chairControlUnMuteAll = (callback = () => { }) => {
        that.socket.sendEvent('room-unmuted', (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on floor request', error);
                callback(undefined, error);
            } else {
                callback(result);
            }
        });
    };

    //chairControl mute single client (old chairControlMuteOne)
    that.muteOne = (clientId, callback = () => { }) => {
        that.socket.sendParamEvent('muteUser', clientId, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on floor request', error);
                callback(undefined, error);
            } else {
                callback(result);
            }
        });
    };

    //chairControl un-mute single client
    that.unMuteOne = (clientId, callback = () => { }) => {
        that.socket.sendParamEvent('unMuteUser', clientId, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on floor request', error);
                callback(undefined, error);
                return;
            }
            callback(result);
        });
    };

    that.muteRoom = (data, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (data === undefined || (data.audio === undefined && data.video === undefined)) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                return;
            }
            if (data.video === false && data.audio === false) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('at least one of the constraints should be false');
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                return;
            }
            localStreams.forEach((stream, id) => {
                if (!stream.screen && !stream.canvas) {
                    if (data.audio === true && stream.ifAudio() && !stream.selfMuteAudio) {
                        stream.muteAudio((response) => {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Mute Audio for the call');
                        }, true, 0, false, true);
                    }
                    //Mute the existing video, if the video is requested for breakout room.
                    if (stream.ifVideo() && data.video === true && !stream.selfMuteVideo) {
                        stream.muteVideo((response) => {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Mute Video for the call');
                        }, true, 0, false, false, true);
                    }
                }
            });

            that.socket.sendMessage('muteRoom', data, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on mute room request', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_room_mute_failed, { message: ('mute room request failed') });
                    callback(undefined, error);
                    return;
                }
                that.roomMuted = true;
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_room_mute_success, { message: ('mute room request succeeded') });
                callback(result);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('muteRoom() invalid param - callback');
        }
    };

    that.unMuteRoom = (data, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (data === undefined || (data.audio === undefined && data.video === undefined)) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                return;
            }
            if (data.video != false && data.audio != false) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('at least one of the constraints should be false');
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                return;
            }
            localStreams.forEach((stream, id) => {
                if (!stream.screen && !stream.canvas) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`SelfMuteAudio: ${stream.selfMuteAudio} hardMutedAudio: ${stream.hardAudioMuted}`);
                    if (!data.audio && stream.ifAudio() && !stream.hardAudioMuted) {
                        stream.unmuteAudio((response) => {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('UnMute Audio for the call');
                        }, true, 0, false, true);
                    }
                    //Mute the existing video, if the video is requested for breakout room.
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`SelfMuteVideo: ${stream.selfMuteVideo} hardMutedVideo: ${stream.hardVideoMuted}`);
                    if (!data.video && stream.ifVideo() && !stream.hardVideoMuted) {
                        stream.unmuteVideo((response) => {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('UnMute Video for the call');
                        }, true, 0, false, true);
                    }
                }
            });

            that.socket.sendMessage('unMuteRoom', data, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on mute room request', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_room_unmute_failed, { message: ('unmute room request failed') });
                    callback(undefined, error);
                } else {
                    that.roomMuted = false;
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_room_unmute_success, { message: ('unmute room request succeeded') });
                    callback(result);
                }
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('unMuteRoom() invalid param - callback');
        }
    };

    that.pauseRoom = (callback = () => { }) => {
        if (typeof (callback) === 'function') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Pausing the room');
            const data = { audio: true, video: true };
            that.muteRoom(data, (response) => {
                callback(response);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('pauseRoom() invalid param - callback');
        }
    };

    that.resumeRoom = (callback = () => { }) => {
        if (typeof (callback) === 'function') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Resuming the room');
            const data = { audio: false, video: false };
            that.unMuteRoom(data, (response) => {
                callback(response);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('resumeRoom() invalid param - callback');
        }
    };

    //Switch room_mode
    that.switchRoomMode = (roomMode, callback = () => { }) => {
        that.socket.sendParamEvent('switchRoomMode', roomMode, (result, error) => {
            if (result === null) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on floor request', error);
                callback(undefined, error);
            } else {
                callback(result);
            }
        });
    };

    // Returns callback(id, error)
    that.startRecording = (stream, callback = () => { }) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('Trying to start recording...');
        let streamId;
        const allow = !((that.subscription && (that.subscription.recording === false)));
        if (allow && ((stream && stream.local === false) || !stream)) {
            if (stream) {
                streamId = stream.getID();
            }
            socket.sendMessage('startRecord', { to: streamId }, (success, error) => {
                if (success === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on start recording', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_failed, { error, message: error.msg });
                    callback(error);
                    const additionalOptions = {
                        error,
                        externalIp: that.externalIp,
                    };
                    that.createEventLog('roomRecordingFailed', additionalOptions);
                    return;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Started recording');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_success, { error: {} });
                if (success.result === 0) {
                    roomRecordStatus = true;
                }
                callback(success, error);
                const additionalOptions = {
                    externalIp: that.externalIp,
                };
                that.createEventLog('roomRecordingSuccess', additionalOptions);
            });
        } else if (!allow) {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170.desc });
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
        }
    };

    that.onMediaDeviceStateChanged = (stream,deviceInfo, callback = ()=>{}) => {
      if (deviceInfo.state == 'active'){
        if (deviceInfo.type == 'cam'){
          if (stream.state == 'connected' && !stream.negotiatedMedia.video){
            let options;
            if (stream.userRequestOptions.video) options = stream.userRequestOptions.video;
            addRenegotiateVideo(options,stream, callback);
          }else callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
        }else callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
      }else if (deviceInfo.state == 'inactive'){
        //since its media device error, it required to reconnect and try
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("mediaDeviceError() errr: " + JSON.stringify(deviceInfo.error) + "reconencting");
        that.socket.disconnect();
        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
      }

    }

    that.manageLiveTranscription = function() {
      console.log("Calling startLiveTranscription", that.liveTranscription);
      if (that.liveTranscription === true  && that.reconnectAttempt > 0 && that.reconnectionAllowed === true) {
        let options = {language:that.transcriptionLanguage};
        that.socket.sendMessage('startLiveTranscription', options, (response) => {
          if(response && response.result === 0) {
            that.liveTranscription = true;
          } else {
            that.liveTranscription = false;
          }
        });
      }
    };
    // reconnection case - manage recording status
    that.manageRecordingStatus = (recordStatus) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnected manage recording status ', recordStatus);
        if (that.me.role === 'moderator' && roomRecordStatus == true && that.reconnectAttempt > 0 && that.reconnectionAllowed === true) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('room recording was enabled before reconnect');
            that.startRecord((success, error) => {
                if (success !== null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnected manage recording success ');
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_success, { message: 'reconnected manage recording success' });
                } else {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Failed to restart recording after reconnection.');
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_failed, { message: 'Failed to restart recording after reconnection.' });
                }
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reenbling recording for this role is not allowed ', that.me.role);
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_failed, { message: `reenbling recording for role ${that.me.role} is not allowed` });
        }
    };

    // Returns callback(id, error)
    that.stopRecording = (recordingId, callback = () => { }) => {
        const allow = !((that.subscription && (that.subscription.recording === false)));
        if (allow) {
            socket.sendMessage('stopRecord', { id: recordingId }, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error on stop recording', error);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_recording_failed, { error });
                    callback(error);
                    return;
                }
                roomRecordStatus = false;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stop recording', recordingId);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_recording_success, { error: {} });
                callback(result, error);
                const additionalOptions = {
                    externalIp: that.externalIp,
                };
                that.createEventLog('roomRecordingStopped', additionalOptions);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_recording_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170.desc });
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
        }
    };
    const discardLocalStreamForReconnect = (screen, canvas) => {
        let prevStreams = [];
        that.localStreamsBeforeReconnect.forEach((localStream, id) => {
          if ((localStream.canvas && canvas) ||(localStream.screen && screen) ||
            (!localStream.canvas && !canvas && !localStream.screen && !screen))
            prevStreams.push(localStream);
        });
        for (let index = 0; index < prevStreams.length; index++) {
          that.localStreamsBeforeReconnect.remove(prevStreams[index].getID());
        }
    }

    const storeLocalStreamForReconnect = (stream2Add ) => {
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug("Inside storeLocalStreamForReconnect() reconnect: " + stream2Add.reconnect + " that.reconnectionState: " +
                    that.reconnectionState + " that.reconnectionAllowed: " + that.reconnectionAllowed +
                    " streamId: " + stream2Add.getID() + " canvas: " + stream2Add.canvas + " screen: " + stream2Add.screen);
      if (stream2Add.reconnect || that.reconnectionState || that.reconnectionAllowed){
        discardLocalStreamForReconnect(stream2Add.screen, stream2Add.canvas);
        that.localStreamsBeforeReconnect.add(stream2Add.getID(), stream2Add);
        return true;
      }
      return false;
    }
    // It unpublishes the local stream in the room, dispatching a StreamEvent("stream-removed")
    that.unpublish = (streamInput, callback = () => { }) => {
        if (typeof callback === 'function') {
            const stream = streamInput;
            // Unpublish stream from Client-Controller
            if (stream && stream.local) {
                // Media stream

                socket.sendMessage('unpublish', stream.getID(), (result, error) => {
                    if (result === null) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error unpublishing stream', error);
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unpublish_failed, { error });
                        callback(undefined, error);
                        return;
                    }

                    delete stream.failed;
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unpublish_success, { error: {} });
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stream unpublished');
                    callback(true);
                });
                if (stream.state == 'connected') stream.state = 'inited';
                stream.room = undefined;

                const streamTobeDeleted = localStreams.get(stream.getID());
                if (streamTobeDeleted !== undefined) {
                    //if its hardmuted while unpublishing, unmute the same. It will get hardmuted when next publish happens
                  if (streamTobeDeleted.hardVideoMuted){
                    streamTobeDeleted.unmuteVideo((resp) => { __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('videoHardUnmuteCallback: ' + JSON.stringify(resp));},
                                                  false, 0, false);
                  }
                  if (streamTobeDeleted.hardAudioMuted){
                    streamTobeDeleted.unmuteAudio((resp) => { __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('audioHardUnmuteCallback: '+ JSON.stringify(resp)); },
                                                  false, 0, false);
                  }
                  if (streamTobeDeleted.pc){
                    streamTobeDeleted.pc.close();
                    streamTobeDeleted.pc = null;
                  }
                    // populate the streams for reconnection
                    if (streamTobeDeleted.reconnect)
                      storeLocalStreamForReconnect(streamTobeDeleted);
                }

                localStreams.remove(stream.getID());
                //stream.getID = () => { };
                stream.setID (0);
                stream.off('internal-send-data', sendDataSocketFromStreamEvent);
                stream.off('internal-set-attributes', updateAttributesFromStreamEvent);
            } else {
                const error = 'Cannot unpublish, stream does not exist or is not local';
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unpublish_failed, { error });
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(error);
                callback(undefined, error);
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('unpublish() invalid param - callback');
        }
    };

    that.sendControlMessage = (stream, type, action) => {
        if (stream && stream.getID()) {
            const msg = { type: 'control', action };
            that.socket.sendSDP('signaling_message', { streamId: stream.getID(), msg });
        }
    };

    // It subscribe to a remote stream and draws it inside the HTML tag given by the ID='elementID'
    that.subscribe = (streamInput, optionsInput = {}, callback = () => { }) => {
        const stream = streamInput;
        const options = JSON.parse(JSON.stringify(optionsInput));
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug("room.subscribe streamId: " + stream.getID() + " options: " + JSON.stringify(options));
        if (stream && !stream.local && !stream.failed) {
            if (stream.ifMedia()) {
                if (!stream.ifVideo() && !stream.ifScreen()) options.video = false;
                if (!stream.ifAudio()) options.audio = false;
                if (stream.ifCanvas()) options.data = false;
                if (!stream.ifCanvas()) options.canvas = false;
                if(__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name === 'safari')
                  options.video = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.version >= __WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_SUPPORTING_VP8 ? true : false;

                options.muteStream = {
                    audio: stream.ifCanvas() ? true : stream.audioMuted != undefined ? stream.audioMuted : false,
                    video: stream.videoMuted,
                };

                if (that.reconnectionState === false) {
                    avOptions.subscribe.forceTurn = options.forceTurn ? options.forceTurn : false;
                    avOptions.subscribe.imageOnVideoMute = options.imageOnVideoMute ? options.imageOnVideoMute : false;
                } else {
                    options.forceTurn = avOptions.subscribe.forceTurn;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Stream for subscribe in room.subscribe:- options:: ${JSON.stringify(options)}`);
                stream.forceTurn = options.forceTurn;
                stream.userRequestOptions = JSON.parse(JSON.stringify(optionsInput));
                if (!remotePendingStreams.get(stream.getID())){
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('subscribe() subscribing streamId: ' , stream.getID(),  ' options  ', JSON.stringify(options));
                  subscribeVcxRtc(stream, options, callback);
                }else {
                  __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('subscribe() pending, not subscribing now streamId: ' , stream.getID(),
                              ' remotePendingStreams keys' + JSON.stringify(remotePendingStreams.keys()));
                  callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
                }
            } else if (stream.ifData() && options.data !== false) {
                subscribeData(stream, options, callback);
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('There\'s nothing to subscribe to');
                callback(undefined, 'Nothing to subscribe to');
                return;
            }
            // Subscribe to stream stream
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`Subscribing to: ${stream.getID()}`);
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_subscribe_success, {message: `Subscribing to: ${stream.getID()}`});
            setMediaConnectionTimer (true, stream.getID(), false);
        } else {
            let error = 'Error on subscribe';
            if (!stream) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('Cannot subscribe to invalid stream');
                error = 'Invalid or undefined stream';
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_subscribe_failed, { error });
            } else if (stream.local) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('Cannot subscribe to local stream, you should subscribe to the remote version of your local stream');
                error = 'Local copy of stream';
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_subscribe_failed, { error, stream });
            } else if (stream.failed) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].warning('Cannot subscribe to failed stream.');
                error = 'Failed stream';
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_subscribe_failed, { error, stream });
            }
            callback(undefined, error);

            const additionalOptions = {
                streamType: stream.ifScreen() ? 'share' : 'main',
                streamId: stream.getID(),
                selectedCandidates: {
                    local: '',
                    remote: '',
                },
                negotiatedCodecs: {
                    video: { codec: (that.mediaConfiguration === 'default' || that.mediaConfiguration === 'Default') ? 'VP8' : that.mediaConfiguration },
                    audio: { codec: 'OPUS' },
                },
                error,
                externalIp: that.externalIp,
            };
            that.createEventLog('clientStreamSubscribeFailed', additionalOptions);
        }
    };

    // It unsubscribes from the stream, removing the HTML element.
    that.unsubscribe = (streamInput, callback = () => { }) => {
        const stream = streamInput;
        // Unsubscribe from stream stream
        if (socket !== undefined) {
            if (stream && !stream.local) {
              if (stream.reconnect){
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(" in that.unsubscribe() remove stream");
                removeStream(stream);
                delete stream.failed;
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
              }else {
                socket.sendMessage('unsubscribe', stream.getID(), (result, error) => {
                    if (result === null) {
                        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1167);
                        return;
                    }
                    removeStream(stream);
                    delete stream.failed;
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unsubscribe_success, { message: 'Unsubscribe from stream - success' });
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
                }, () => {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('Error calling unsubscribe.');
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unsubscribe_failed, { stream });
                });
              }
            }else {
              callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1156);
            }
        }else {
          callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1163);
        }
    };

    that.hardMute = (callback = () => { }) => {
        if (typeof callback === 'function') {
            sendRemoteMediaDeviceControlRequest('room-muted', true, false, true, undefined, (resp)=>{
              if (resp.result == 0) that.hardMuteInitiator = true;
              callback(resp);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('hardMute() invalid param - callback');
        }
    };

    that.hardUnmute = (callback = () => { }) => {
        if (typeof callback === 'function') {
            sendRemoteMediaDeviceControlRequest('room-unmuted', true, false, true, undefined, (resp)=>{
              if (resp.result == 0) that.hardMuteInitiator = false;
              callback(resp);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('hardUnmute() invalid param - callback');
        }
    };

    that.hardMuteUserAudio = (clientId, callback = () => { }) => {
        if (typeof callback === 'function') {
            sendRemoteMediaDeviceControlRequest('hardmute-user-audio', true, false, false, clientId, callback);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('hardMuteUserAudio() invalid param - callback');
        }
    };

    that.hardUnmuteUserAudio = (clientId, callback = () => { }) => {
        if (typeof callback === 'function') {
            sendRemoteMediaDeviceControlRequest('hardunmute-user-audio', true, false, false, clientId, callback);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('hardUnmuteUserAudio() invalid param - callback');
        }
    };

    that.hardMuteUserVideo = (clientId, callback = () => { }) => {
        if (typeof callback === 'function') {
            sendRemoteMediaDeviceControlRequest('hardmute-user-video', false, true, false, clientId, callback);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('hardMuteUserVideo() invalid param - callback');
        }
    };

    that.hardUnmuteUserVideo = (clientId, callback = () => { }) => {
        if (typeof callback === 'function') {
            sendRemoteMediaDeviceControlRequest('hardunmute-user-video', false, true, false, clientId, callback);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('hardUnmuteUserVideo() invalid param - callback');
        }
    };

    that.subscriberVideoMute = (streamId, callback) => {
        that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.subscriber_video_mute, { streamId }, (result) => {
            if (result.result == 0) { callback(result); }
        });
    };

    that.setTalkerCount = (numTalker, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (typeof numTalker != 'undefined' && typeof numTalker === 'number' && numTalker >= 0 && numTalker === parseInt(numTalker)) {
                prefNumTakler = numTalker;
                const numAudio = numTalker <= 3 ? 3 : numTalker;
                const numVideo = that.audioOnlyMode ? 0 : numTalker;
                const talkerInfo = { numTalkers: numTalker, numAudioTalkers: numAudio, numVideoTalkers: numVideo };
                that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.set_active_talker, talkerInfo, (result) => {
                    if (result.result == 0) {
                        that.userAudioTalkerCount = result.numAudioTalkers;
                        if (that.audioOnlyMode === false) { that.userVideoTalkerCount = result.numVideoTalkers; }
                    }
                    callback(result);
                });
            } else {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('setTalkerCount() invalid param - callback');
        }
    };

    that.getTalkerCount = (callback) => {
        if (typeof callback === 'function') {
            that.socket.sendEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.get_active_talker, (result) => {
                callback(result);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('getTalkerCount() invalid param - callback');
        }
    };

    that.getMaxTalkers = (callback) => {
        if (typeof callback === 'function') {
            that.socket.sendEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.get_active_max_talker, (result) => {
                callback(result);
            });
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('getMaxTalkers() invalid param - callback');
        }
    };

    that.setAdvancedOptions = (options, callback =(resp) =>{}) => {
      if (options && Array.isArray(options) && options.length && typeof callback == 'function')
        that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.set_adavanced_options, options, callback);
      else callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
    };

    that.getAdvancedOptions = (callback =(resp) =>{}) => {
      if (typeof callback == 'function')
        that.socket.sendEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.get_adavanced_options, (result) => {callback(result);});
      else callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
    };

    that.switchUserRole = (newModeratorId, callback = () => { }) => {
        if (typeof (callback) === 'function') {
            if ((that.me.role === 'moderator') && newModeratorId && that.clientId && (newModeratorId != that.clientId)) {
                that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.switch_user_role, newModeratorId, (result) => {
                    callback(result);
                });
            } else {
                const error = (that.me.role !== 'moderator') ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168 :
                              !that.clientId ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1171 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155;
                callback(error);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('switchUserRole() invalid param - callback');
        }
    };

    that.setSpeakerVolume = (volume, callback = () => { }) => {
      if (volume != undefined && (typeof volume == 'number' || typeof volume == 'boolean') && typeof callback == 'function'){
        let vol = typeof volume == 'boolean' ? Number(volume) : volume;
        if (vol >= 0 && vol <= 1 && that.speakerInfo.volume != volume) {
          that.remoteStreams.forEach((stream) => {stream.setSpeaker(undefined, volume);});
          if (!volume) that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'speaker-muted',message: {}}));
          else if (!that.speakerInfo.volume) that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'speaker-unmuted',message: {}}));
          that.speakerInfo.volume = volume;
          callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
        }else callback(that.speakerInfo.volume != volume ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1188: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
      }else callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
    };
    that.switchSpeaker = (speakerId, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (speakerId != undefined && (that.speakerInfo.id == undefined || speakerId != that.speakerInfo.id) &&
                (callback == undefined || typeof callback === 'function') &&
                (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() !== 'safari')) {
                validSpeakerDevice(speakerId, (valid) => {
                    if (valid) {
                        remoteStreams.forEach((stream) => {
                            stream.setSpeaker(speakerId);
                        });
                        that.speakerInfo.id = speakerId;
                        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
                    } else {
                        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1142);
                    }
                });
            } else if (typeof callback === 'function') {
                callback(__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'safari' ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1153 : speakerId == undefined ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177);
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('switchSpeaker() invalid param - callback');
        }
    };

    that.startLocalRecord = (type = 'remote', timeoutSecs = 10, callback) => {
        if (localRecord === 'none') {
            const promises = [];
            let index = 0;
            if ((type === 'remote') || (type === 'all')) {
                remoteStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.startLocalRecord(respCallback = (status) => {
                            resolve({ id: stream.getID(), status });
                        });
                    });
                    index++;
                });
                localRecord = type;
            }

            if ((type === 'local') || (type === 'all')) {
                localStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.startLocalRecord(respCallback = (status) => {
                            resolve({ id: stream.getID(), status });
                        });
                    });
                    index++;
                });
                localRecord = type;
            }

            if (localRecord !== 'none') {
                if (timeoutSecs !== 0) {
                    promises[index] = new Promise((resolve, reject) => {
                        setTimeout(() => {
                            that.stopLocalRecord(respCallback = (status, info) => {
                                resolve(info);
                            });
                        }, timeoutSecs * 1000);
                    });
                }
                Promise.all(promises).then((values) => {
                    if (callback) {
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_success, { error: {} });
                        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000, values);
                    }
                });
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('invalid param type');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_failed, { error: 'invalid param type' });
                if (callback) callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('recording already in progress');
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_recording_failed, { error: 'recording already in progress' });
            if (callback) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1174);
            }
        }
    };

    that.stopLocalRecord = (callback) => {
        if (localRecord !== 'none') {
            const promises = [];
            let index = 0;
            if ((localRecord === 'remote') || (localRecord === 'all')) {
                remoteStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.stopLocalRecord(respCallback = (status) => {
                            resolve({ id: stream.getID(), status });
                        });
                    });
                    index++;
                });
            }
            if ((localRecord === 'local') || (localRecord === 'all')) {
                localStreams.forEach((stream) => {
                    promises[index] = new Promise((resolve, reject) => {
                        stream.stopLocalRecord(respCallback = (status) => {
                            resolve({ id: stream.getID(), status });
                        });
                    });
                    index++;
                });
            }
            localRecord = 'none';
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_recording_success, { error: {} });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('recoding not stopped');
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_recording_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1175.desc });
            if (callback) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1175);
            }
        }
    };

    that.setReceiveVideoQuality = (opts, callback) => {
        const isObject = (obj) => {
            return Object.prototype.toString.call(obj) === '[object Object]';
        };
        if (isObject(opts) && typeof callback === "function") {
            const config = {};
            const video = {};
            let res = {};
            let videoQuality = opts.videoQuality;
            let streamType = opts.streamType;
            if (videoQuality === undefined) {
                videoQuality = 'Auto';
            }
            if (streamType === undefined) {
                streamType = 'talker';
            }
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Dumping opts in setReceiveVideoQuality${JSON.stringify(opts)} streamType${streamType}`);
            if ((streamType != 'talker') && (streamType != 'canvas')) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`setReceiveVideoQuality Failed Invalid Param -StreamType: ${streamType}`);
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                return;
            }
            switch (videoQuality) {
                case 'HD':
                    video.width = 1280;
                    video.height = 720;
                    break;

                case 'SD':
                    video.width = 960;
                    video.height = 540;
                    break;

                case 'LD':
                    video.width = 640;
                    video.height = 360;
                    break;

                case 'Auto':
                    // leave width and height undefined
                    break;

                default:
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`setReceiveVideoQuality for ${streamType}. Failed Invalid Param -videoQuality: ${videoQuality}`);
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                    return;
            }
            video.frameRate = 30;
            config.video = video;
            if (((streamType == 'talker') && (that.receiveVideoQuality.get('talker') !== videoQuality)) ||
                ((streamType == 'canvas') && (that.receiveVideoQuality.get('canvas') !== videoQuality))) {
                remoteStreams.forEach((stream) => {
                    if ((streamType === 'talker') && (stream.canvas === false) && (stream.screen === false)) {
                        stream.updateConfiguration(config, (result) => {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`stream.updateConfiguration for talker stream result : ${result}`);
                        });
                    } else if ((streamType === 'canvas') && (stream.canvas === true)) {
                        stream.updateConfiguration(config, (result) => {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`stream.updateConfiguration for canvas stream result : ${result}`);
                        });
                    }
                });
                that.receiveVideoQuality.set(streamType, videoQuality);
            }
            res = { result: 0, msg: 'Video quality successfully updated.' };
            callback(res);
        }
        else {
            if (typeof callback !== 'function') {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('setReceiveVideoQuality() invalid param - callback() ');
            }
            else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('setReceiveVideoQuality() invalid param - QualityOpt ');
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                return;
            }
        }
    };


    /**
     * Function to Get Receive Video Quality
     */
    that.getReceiveVideoQuality = (streamType) => {
        let res = {};
        if ((streamType === 'talker') || (streamType === 'canvas')) {
            const quality = that.receiveVideoQuality.get(streamType);
            res = {
                result: 0,
                videoQuality: quality,
            };
        } else {
            res = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1156;
        }
        return res;
    };
    that.getStats = (enable, options = {intervalSecs: 2, log: true}, callback = ()=>{}) => {
      if (enable != undefined && typeof enable == 'boolean' && typeof callback == 'function'){
        if (enable) {
          const getRtpStreamStats  = (report,stream, publisher, rtpFmt, rtpRaw) =>{
            rtpFmt.ssrc = report.ssrc;
            rtpFmt.id = stream.getID();
            rtpFmt.reconnects = stream.reconnectsTotal;
            if (!publisher){
              rtpFmt.type = 'sub';
              rtpFmt.bps = rtpRaw.bytes? ((report.bytesReceived - rtpRaw.bytes)*8)/(options.intervalSecs) : 0;
              rtpFmt.kbps = rtpFmt.bps/1000;
              rtpRaw.bytes = report.bytesReceived;
              rtpFmt.packetsLost= report.packetsLost;
            }else {
              rtpFmt.type = 'pub';
              rtpFmt.bps = rtpRaw.bytes ? ((report.bytesSent - rtpRaw.bytes)*8)/(options.intervalSecs) : 0;
              rtpFmt.kbps = rtpFmt.bps/1000;
              rtpFmt.targetkbps = report.targetBitrate/1000;
              rtpRaw.bytes = report.bytesSent;
              //console.log ("PUBLISHER RECORD: " + JSON.stringify(report));
            }
            if (report.kind == 'video'){
              rtpFmt.id = 'vid:' + stream.getID();
              if (!publisher){
                rtpFmt.fps = rtpRaw.framesDecoded ? (report.framesDecoded - rtpRaw.framesDecoded)/options.intervalSecs : 0 ;
                rtpRaw.framesDecoded = report.framesDecoded;
                rtpFmt.recivedfps = rtpRaw.frames ?
                                    (report.framesReceived - rtpRaw.frames)/options.intervalSecs : 0 ;
                rtpRaw.frames  = report.framesReceived;
                rtpFmt.droppedfps = rtpRaw.framesDropped ?
                                    (report.framesDropped - rtpRaw.framesDropped)/options.intervalSecs : 0 ;
                rtpRaw.framesDropped  = report.framesDropped;
                //console.log (" SUBSCRIBER REPORT: " + JSON.stringify(report));
              }else {
                rtpFmt.fps = rtpRaw.framesEncoded ? (report.framesEncoded - rtpRaw.frames)/options.intervalSecs : 0 ;
                rtpRaw.frames = report.framesEncoded;
                rtpFmt.fps = report.framesPerSecond;
                rtpFmt.retransmitKbps = rtpRaw.retransmittedBytesSent  ?
                         ((report.retransmittedBytesSent - rtpRaw.retransmittedBytesSent)*8)/(options.intervalSecs*1000) : 0 ;
                rtpRaw.retransmittedBytesSent = report.retransmittedBytesSent;
                rtpFmt.keyFrames = report.keyFramesEncoded;
                rtpFmt.targetFps = report.framesPerSecond;
              }
              rtpFmt.resH = report.frameHeight;
              rtpFmt.resW = report.frameWidth;
              rtpFmt.resoln = report.frameWidth + 'X' + report.frameHeight;
              rtpFmt.firs = report.firCount;
              rtpFmt.plis = report.pliCount;
              rtpFmt.nacks = report.nackCount;
              //if (!publisher) console.log (" FMT SUBSCRIBER INFO: " + JSON.stringify(rtpFmt));
              //rtpFmt.frameHeight = report.frameHeight;
            }else {
              rtpFmt.id = 'aud:' + stream.getID();
            }
            if (!publisher){
            }else {
            }
            rtpFmt.type += (!stream.ifScreen() ? !stream.ifCanvas() ? 'mn' : 'cn' : 'sh');
            //rtpRaw = Object.assign(rtpRaw, report);
          };

          const processStreamStats  = (stream, publisher, fmtStats, rawStats ,callback = ()=>{}) => {
            let result = {};
            const checkCalculateTotalBytes = (fmtStat, rawStat, bytes) => {
              if (fmtStat && rawStat && bytes){
                fmtStat.totalBytes = bytes - rawStat.totalBytes;
                rawStat.totalBytes = bytes;
                return true;
              }
              return false;
            };
            if (stream.pc && stream.pc.peerConnection){
              let availKbps, totalBytes={};
              let id = stream.getID();
              stream.pc.peerConnection.getStats(null)
              .then((stats) => {
                let candReport;
                stats.forEach((report) => {
                  switch (report.type){
                  case 'candidate-pair':
                    if (report.nominated) {
                      availKbps = (publisher ? report.availableOutgoingBitrate : report.availableIncomingBitrate)/1000;
                      let bytes = publisher ? report.bytesSent : report.bytesReceived;
                      if (!checkCalculateTotalBytes (fmtStats[id+'-'+ 'audio'], rawStats[id+'-'+ 'audio'], bytes)){
                        totalBytes[id+'-'+ 'audio'] = bytes;
                      }
                      if (!checkCalculateTotalBytes (fmtStats[id+'-'+ 'video'], rawStats[id+'-'+ 'video'], bytes)){
                        totalBytes[id+'-'+ 'video'] = bytes;
                      }
                    }
                  break;
                  case 'outbound-rtp':
                  case 'inbound-rtp':
                    if ((stream.local && report.type == 'inbound-rtp') || (!stream.local && report.type == 'outbound-rtp')) {
                     break;
                    }
                    let key = id +'-'+ report.kind;
                    if (fmtStats[key] == undefined) {
                      fmtStats[key] = {id: id, ssrc: 0,reconnects:0, availKbps:0};
                      rawStats[key] = {totalBytes:0 };

                    }
                    getRtpStreamStats (report,stream, (report.type === 'outbound-rtp'),
                                       fmtStats[key], rawStats[key]);
                    fmtStats[key].sId = id;
                    result[report.kind] = fmtStats[key];
                    if (checkCalculateTotalBytes (fmtStats[key], rawStats[key], totalBytes[key])) totalBytes[key] =0;
                    if (availKbps) fmtStats[id +'-'+ report.kind].availKbps = availKbps;
                  break;
                  }
                });
                callback (result);
              }, err => console.log(" peerconnection getStats failed err : " + err));
            }
            return result;
          };
          const processNotifyDisplayStreamStat = (publisher, media, notifyStat, display) => {
            let stat = media.stat;
            let totalBps = (stat.totalBytes*8)/options.intervalSecs;
            if (notifyStat == undefined) notifyStat = { id: stat.sId, 'total-bitrate-kbps': 0, video :[], audio: {}};
            notifyStat['total-bitrate-kbps'] =  Math.round(totalBps/1000);
            if (media.kind == 'video'){
              notifyStat.video[0] = { resHeight: stat.resH, resWidth: stat.resW, frameRate: stat.fps, bitrate :stat.bps,
                                      packetsLost: stat.packetsLost,bandwidth: totalBps};
            }else {
              notifyStat.audio[0] = {bitrate :stat.bps, bandwidth: totalBps};
            }
            if (display){
              let selectorStrings = document.querySelectorAll(`#stats-right-part-${stat.sId}`);
              selectorStrings.forEach((selectorString)=> {
                if (selectorString && selectorString !== null){
                  let keyPair = `<div> <strong>`;
                  if(!publisher) keyPair += `Rx ID: ${stat.sId},`;
                  else keyPair += `Tx ,`;
                  keyPair += `Total:</strong>:  ${notifyStat['total-bitrate-kbps']}Kbps </div>`;
                  keyPair += `<div> <strong style="color:black;" >`;
                  if (media.kind == 'video') keyPair += `${stat.resW}X${stat.resH}p${stat.fps}@`;
                  else keyPair += `  `;
                  keyPair += `${Math.round(stat.bps/1000)}Kbps</strong>:</div>`;
                  selectorString.innerHTML = `<div id="" class="stats-detail"> ${keyPair} </div>`;
                }
              });
            }
          };
          let streamStats = {fmt: {} , raw: {}};
          statsTimer = setInterval(() => {
            if (that.state != CONNECTED) return;
            const talkerStats = [];
            const selfPublisherStat = {video:[], audio:[]};
            const canvasStat = {video:[], audio:[]};
            const shareStat = {video:[], audio:[]};
            let promises = [];
            let notify = (that.mediaStatsMode == 'notify-display' || that.mediaStatsMode == 'notify');
            let display= !__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.csp_enabled && (that.mediaStatsMode == 'notify-display' || that.mediaStatsMode == 'display');
            localStreams.forEach((stream, id) => {
              if (stream.state =='connected'){
                promises.push ( new Promise((resolve, reject) => {
                  processStreamStats(stream, true, streamStats.fmt, streamStats.raw, (result)=> {
                    if (notify || display) {
                      let media = result.video ? {stat: result.video, kind: 'video'} :
                                      result.audio  ? {stat: result.audio, kind: 'audio'} : undefined;
                      if (media){
                        processNotifyDisplayStreamStat (true, media, selfPublisherStat, display);
                      }
                      resolve(true);
                    }
                  });
                })
                );
              }else if (streamStats.fmt[stream.getID()+'-'+'video']) {
                delete streamStats.fmt[stream.getID()+'-'+'audio'];
                delete streamStats.fmt[stream.getID()+'-'+'video'];
                delete streamStats.raw[stream.getID()+'-'+'audio'];
                delete streamStats.raw[stream.getID()+'-'+'video'];
              }
            });
            remoteStreams.forEach((stream, id) => {
              if (stream.state == 'connected'){
                if(that.activeTalkerList.get(parseInt(id)) || (parseInt(id) > 100 && (that.shareStatus || that.canvasStatus))){
                  promises.push ( new Promise((resolve, reject) => {
                    processStreamStats(stream, false, streamStats.fmt, streamStats.raw, (result) => {
                      if (notify || display) {
                        let media = result.video ? {stat: result.video, kind: 'video'} :
                                        result.audio  ? {stat: result.audio, kind: 'audio'} : undefined;
                        if (media){
                          let notifyStat = that.activeTalkerList.get(parseInt(id)) ? talkerStats[parseInt(id)] :
                                            stream.ifScreen() ? shareStat : canvasStat;
                          processNotifyDisplayStreamStat (false, media, notifyStat, display);
                        }
                      }
                      resolve(true);
                    });
                  })
                  );
                }
              }else if (streamStats.fmt[stream.getID()+'-'+'video']) {
                delete streamStats.fmt[stream.getID()+'-'+'audio'];
                delete streamStats.fmt[stream.getID()+'-'+'video'];
                delete streamStats.raw[stream.getID()+'-'+'audio'];
                delete streamStats.raw[stream.getID()+'-'+'video'];
              }
            });
            Promise.all(promises).then((values) => {
              if (options.log){
                console.table (Object.values(streamStats.fmt));
              }
              if (notify) {
                that.dispatchEvent({ type: 'media-stats', talkers: talkerStats,publisher: selfPublisherStat,
                                    share: shareStat,canvas: canvasStat,});
              }
            });
        }, options.intervalSecs*1000);
      }else if (statsTimer) {
        clearTimeout(statsTimer);
        statsTimer = undefined;
      }
    }else {
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("Invalid paramaters ");
      if (callback && typeof callback == 'function') callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
    }
  }
    that.getStreamStats = (stream, callback = () => { }) => {
        if (!socket) {
            return 'Error getting stats - no socket';
        }
        if (!stream) {
            return 'Error getting stats - no stream';
        }

        socket.sendMessage('getStreamStats', stream.getID(), (result) => {
            if (result) {
                callback(result);
            }
        });
        return undefined;
    };

    // It searchs the streams that have "name" attribute with "value" value
    that.getStreamsByAttribute = (name, value) => {
        const streams = [];

        remoteStreams.forEach((stream) => {
            if (stream.getAttributes() !== undefined && stream.getAttributes()[name] === value) {
                streams.push(stream);
            }
        });

        return streams;
    };

    that.installPlugin = () => {
        if (document.getElementById('WebrtcEverywherePluginId')) {
            return;
        }
        let isInternetExplorer = !!((Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(window, 'ActiveXObject')) || ('ActiveXObject' in window));
        const isSafari = !!navigator.userAgent.indexOf('Safari');
        const pluginObj = document.createElement('object');
        if (isInternetExplorer) {
            pluginObj.setAttribute('classid', 'CLSID:7FD49E23-C8D7-4C4F-93A1-F7EACFA1EC53');
            isInternetExplorer = true;
        } else {
            pluginObj.setAttribute('type', 'application/webrtc-everywhere');
        }
        pluginObj.setAttribute('id', 'WebrtcEverywherePluginId');
        document.body.appendChild(pluginObj);
        pluginObj.setAttribute('width', '0');
        pluginObj.setAttribute('height', '0');

        if (pluginObj.isWebRtcPlugin || (typeof navigator.plugins !== 'undefined' && (!!navigator.plugins['WebRTC Everywhere'] || navigator.plugins['WebRTC Everywhere Plug-in for Safari']))) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Installed WEBRTC plugin for IE');
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: 'Installed WEBRTC plugin for IE' });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Browser does not appear to be WebRTC-capable');
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].warn('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_incompatible_browser, { message: 'Browser does not appear to be WebRTC-capable' });
            window.open('/assets/plugin/VCXIE_PLUGINS.exe', 'new');
        }
    };
    that.sendStoredLogs = (logId, callback) => {
        that.socket.sendSDP('clientLogPosted', logId, __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].storedBuff, (result, error) => {
            if (result) {
                if (result) {
                    var res = {
                        result: 0,
                        message: 'Log posted successfully',
                    };
                    callback(res);
                }
            } else {
                var res = {
                    result: 1340,
                    message: 'Error in posing log',
                };
                callback(res);
            }
        });
    };
    //processes log
    that.postClientLogs = (tokenRef, callback = () => { }) => {
        /* */
        if (typeof callback === 'function') {
            const token = __WEBPACK_IMPORTED_MODULE_7__utils_Base64__["a" /* default */].decodeBase64(tokenRef);
            const myData = __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.getLocalStorageItem('vcxRTCLib-log');
            if (myData != null) {
                const logId = JSON.parse(token).logId;
                const dat = JSON.parse(myData);

                const s = JSON.stringify(myData).replace(',', ', ').replace('{', '').replace('}', '');
                that.sendStoredLogs(logId, callback);
                return;
                that.socket.sendSDP('clientLogPosted', logId, myData, (result, error) => {
                    if (result) {
                        if (result) {
                            var res = {
                                result: 0,
                                message: 'Log posted successfully',
                            };
                            callback(res);
                        }
                    } else {
                        var res = {
                            result: 1340,
                            message: 'Error in posing log',
                        };
                        callback(res);
                    }
                });
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('postClientLogs() invalid param - callback');
        }
    };

    //get the loacl(calling) user detail
    that.whoAmI = (callback = (arg) => { }) => {
        let currntUserDetails;
        that.userList.forEach(findMe);
        function findMe(item, index) {
            if (index === that.clientId) {
                currntUserDetails = item;
            }
        }
        callback(currntUserDetails);
    };
    const addRenegotiateVideo = (options, stream, callback) =>{
      stream.userRequestOptions.video = options != undefined ? options : true;
      if (!stream.config.video) stream.config.video = stream.video = true;
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("addRenegotiateVideo() : caling reconnectStream");
      checkWaitReconnectStream(stream, 'add', (result)=>{callback(result ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1167);});
    };
    that.addVideo = (options, callback = ()=>{}) => {
      if (options != undefined &&  options != null && typeof options != 'object'){
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("addVideo() failed Invalid params");
        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
        return;
      }
      if (that.subscription && !that.subscription.audio_video ){
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Licence error : feature not supported subscription - av: ${that.subscription.audio_video}`);
        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170.error });
        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
        return;
      }
      let localStream;
      localStreams.forEach((stream, id) => {if (!stream.ifCanvas() && !stream.ifScreen()) localStream = stream;});
      if (localStream && !localStream.isVideoMuted() &&
          localStream.state == 'connected' && !localStream.negotiatedMedia.video){
        const reconnectStreamOnUnmuteVideo = (resp)=> {
          console.log ("reconnectStreamOnUnmuteVideo resp:: " + JSON.stringify(resp));
          if (resp.result == 0) addRenegotiateVideo(options, localStream, callback);
          else callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1145);
        };
        if (options) {
          if (!localStream.config.video || typeof localStream.config.video != 'object') localStream.config.video = {};
          if (options.deviceId) localStream.config.video.deviceId = options.deviceId;
          if (options.facingMode)localStream.config.video.facingMode = options.facingMode;
          if (!Object.keys(localStream.config.video).length)localStream.config.video = true;
        }
        localStream.unmuteVideo(reconnectStreamOnUnmuteVideo, false, 0, !localStream.hardVideoMuted,false,true);
      }else if (localStream) callback (!localStream.isVideoMuted() ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1197 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1189);
      else callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1159);
    }
    const sendSharePermissionReq = (reqId, options, callback = ()=>{}) => {
      if (typeof callback === 'function'&&  options && typeof options == 'object'&& options.pubType != undefined  &&
          (options.pubType === 'screen' || options.pubType === 'canvas')){
        let opt = JSON.parse(JSON.stringify(options));
        opt.req = reqId;
        that.socket.emitEvent ('auxilaryPublishRequests', opt, callback);
      }else {
        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
      }
    }
    that.setSharePermissionMode = (options, callback) => { sendSharePermissionReq('set-permission-mode', options, callback);}
    that.requestSharePermission = (options, callback) => {
      sendSharePermissionReq('req-permission', options, (resp) => {
        if (!that.isModerator() && resp.result == __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result)
          that.sharePermissions[options.pubType].state = 'share-permission-requested';
        callback(resp);
      });
    }
    that.grantSharePermission = (options, callback) => { sendSharePermissionReq('grant-permission', options, callback);}
    that.denySharePermission = (options, callback) => { sendSharePermissionReq('deny-permission', options, callback);}
    that.cancelSharePermission = (options, callback) => {
      sendSharePermissionReq('cancel-permission', options, (resp) => {
        if (!that.isModerator() && resp.result == __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result)
          that.sharePermissions[options.pubType].state = 'idle';
        callback(resp);
      });
    }
    that.releaseSharePermission = (options, callback) => {sendSharePermissionReq('release-permission', options, callback);}

    that.startScreenShare = (param1, param2) => {
        let callback, options;
        if (param1 != undefined && typeof param1 === 'function') callback = param1;
        else if (param2 != undefined && typeof param2 === 'function') {
            if (param1 != undefined) options = param1;
            callback = param2;
        }
        if (typeof callback === 'function' && that.share && (!that.subscription || that.subscription.audio_video)) {
            if (options == undefined){
               options = {audio : (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name === 'chrome-stable' || __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name === 'edge')};
            }else if (options.audio == undefined) options.audio = false;
            options.layout = options.layout != undefined ? options.layout : 'grid';
            that.forcedStopSharing = false;
            let localStream, promise;
            if (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name === 'safari') {
             promise = new Promise((resolve) => {localStream = startShare(options,(result) =>{ resolve(result);});});
            }
            that.socket.emitEvent ('auxilaryPublishRequests', {req: 'start', pubType: 'screen', override: true},(resp) => {
              if (resp.result == __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result){
                if (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name !== 'safari') {
                  promise = new Promise((resolve) => {localStream = startShare(options,(result) =>{ resolve(result);});});
                }
                promise.then((result) => {
                  if (result === true && !that.shareStatus && !that.forcedStopSharing){
                    localStream.addEventListener ('stream-ended', (event)=> {
                      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info (" screen share stream ended, stopping share");
                      that.stopScreenShare((res) => {__WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info ("stopScreenShare resp: " + JSON.stringify(res));});
                    });
                    let ops = {share: true, shareMetadata: {layout: options.layout},
                               maxVideoBW: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_bandwidth_range.share.max,
                               minVideoBW: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_bandwidth_range.share.min};
                    that.publish(localStream, ops, (response) => {
                      callback(response);
                      let addOpt = { streamId: localStream.getID(),negotiatedCodecs: {}, externalIp: that.externalIp };
                      addOpt.negotiatedCodecs = {audio: {codec: 'OPUS'}, video:{ codec : 'VP8'}};
                      if (response.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                        //EL.info('room-event', customEvents.event_start_screenshare_success, { error: {} });
                        adjustMainVideoQuality(true, that.canvasStatus);
                      } else if (response.result === 4108) {
                        addOpt.error =  response.msg;
                        that.createEventLog('clientStreamShareFailed', addOpt);
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_screenshare_failed, { addOpt });
                        localStream.stream.getTracks().forEach((track) => {track.stop();});
                      }
                    });
                  }else {
                    if (result === true) {
                      result = (that.shareStatus) ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1151 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1200;
                      localStream.close();
                    }
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error ("startShare failed: err " + JSON.stringify(result) );
                    that.socket.emitEvent ('auxilaryPublishRequests', {req: 'stop', pubType: 'screen', },(resp) => {
                    });
                    callback(result);
                  }
                });
              }else {
                if (localStream) localStream.stream.getTracks().forEach((track) => {track.stop();});
                callback(resp);
              }
            });
          }else {
            if (typeof callback === 'function') __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('startScreenShare() invalid param - callback');
            else {
              __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Room not connected../ licence error');
              __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_screenshare_failed, { error });
              callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1171 );
            }
          }
          if (localStream) that.ScreenSharelocalStream = localStream;
          return localStream;
        };

    that.getScreenShareStream = () => {
        return that.ScreenSharelocalStream;
    };

    /**
     * method to stop screen share
     */
    that.stopScreenShare = (shareStream, callback = () => { }) => {
        if (typeof callback === 'function') {
            let error = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1159;
            if (that && that.share && (!that.subscription || that.subscription.audio_video)) {
                let stream2Remove;
                that.localStreams.forEach((stream) => {
                    if (stream.ifScreen() && stream.local) {
                        discardLocalStreamForReconnect (true, false);
                        stream.close();
                        stream2Remove = stream;
                        error = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000;
                        //EL.error('room-event', customEvents.event_stop_screenshare_success, { error: {} });
                    }
                });
                adjustMainVideoQuality(false, that.canvasStatus);
                if (stream2Remove != undefined){
                  that.localStreams.remove(stream2Remove.getID());
                }
            } else {
                error = !that ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1171 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Room not connected../ licence error');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_screenshare_failed, { error });
            }
            // Note: 1st param is not required. Incase if application  passes only one param as callback, need to handle
            that.ScreenSharelocalStream = null;
            if (callback) {
                callback(error);
            } else if (shareStream && (typeof shareStream === 'function')) {
                shareStream(error);
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('stopScreenShare() invalid param - callback');
        }
    };

    that.stopAllSharing = (callback) => {
        console.log('stopAllSharing');
        if (that.shareStatus == true || that.isCanvasSharing == true) {
            that.socket.sendParamEvent('stopAllSharing', that.clientId, (rsp) => {
                if (rsp.result != 0) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(rsp.msg);
                    rsp.result = -1;
                    callback(rsp);
                } else {
                    callback(rsp);
                }
            });
        }
    }

    // that.startHLS = (streamingOptions, callback) => {

    //     if (that.subscription && (that.subscription.hls === undefined || that.subscription.hls === false)) {
    //         Logger.error(`HLS subsciption isn't supported for the room !!`);
    //         callback(customErrors.error_1170);
    //         return;
    //     }
    //     Logger.info('startHLS');
    //     that.getCustomData({scope: SESSION}, function(rsp) {
    //         Logger.info('getCustomData- rsp: ', rsp);
    //         if(rsp && rsp.data && rsp.data.stream_url) {
    //             var response = {result: customErrors.error_000, stream_url: rsp.data.stream_url};
    //             callback(response);
    //         } else {
    //             if (streamingOptions != undefined) {
    //               socket.sendMessage('getHlsStreamingURI', streamingOptions, (result, error) => {
    //                     if (result === null) {
    //                         Logger.error('Error on start streaming for audience', error);
    //                         if(error.result !== undefined){
    //                         callback(error);
    //                         return;
    //                         } else if(error.status !== undefined) {
    //                         var response = {result: error.status.resultCode, error: 'streaming error', desc: error.status.error.errorDesc, status: error.status};
    //                         callback(response);
    //                         return;
    //                         }
    //                     } else {
    //                     var resp = {result: result.status.resultCode, error: '', desc: '', status: result.status};
    //                     callback(resp);
    //                     }
    //                 });
    //             }
    //         }
    //     });
    // }

    // that.stopHLS = (callback = () => { }) => {

    //     if (that.subscription && (that.subscription.hls === undefined || that.subscription.hls === false)) {
    //         Logger.error(`HLS subsciption isn't supported for the room !!`);
    //         callback(customErrors.error_1170);
    //         return;
    //     }
    //     Logger.info('stopHLS');
    //     var myStreamConfig={};
    //     if(typeof callback === 'function' && that.me.role === 'moderator') {
    //         socket.sendMessage('stopHlsStreaming', myStreamConfig, (result, error) => {
    //             if(error){
    //                 Logger.error('Error on stop streaming for audience', error);
    //                 callback(error);
    //             }
    //         });
    //     } else if (typeof callback === 'function') {
    //         const resp = that.me.role !== 'moderator' ? customErrors.error_1168 : customErrors.error_1155;
    //         callback(resp);
    //     } else {
    //         Logger.error('stopHLS() invalid param - callback');
    //     }
    // }

    function validScope(scope) {
        if(scope == undefined || typeof(scope) != 'string' || SCOPE.includes(scope) == false) {
            return false;
        }
        return true;
    }

    function validBroadcastOption(broadcast) {
        if(typeof(broadcast) != 'string' || BROADCAST.includes(broadcast) == false) {
            return false;
        }
        return true;
    }

    const onCustomDataSaved = (rsp) => {
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'custom-data-saved', message: { result: rsp.result, scope:  rsp.scope} });
        that.dispatchEvent(evt);
    };

    const onCustomDataUpdated = (rsp) => {
        var data = rsp.data;
        var scope = rsp.scope;
        //These are for updating room level details for each clients
        if(scope == ROOM){
            that.customRoomData = data;
        } else if(scope == SESSION) {
            that.customSessionData = data;
        } else if(scope == USER) {
            const user = that.userList.get(rsp.clientId);
            user.customUserData = data;
            that.userList.set(rsp.clientId, user);
        }
        //This event will be fired in broadcast case
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'custom-data-updated', message: { result: rsp.result, scope:  rsp.scope, msg: rsp.msg} });
        that.dispatchEvent(evt);
    };

    // It sets data in DB.
    that.saveCustomData = (dataOptions, data, callback) => {
        if (that.subscription && (that.subscription.datastore === undefined || that.subscription.datastore === false)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Customer datastore subsciption isn't supported for the room !!`);
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
            return;
        }
        var ret = { result: 0 };
        var scope = dataOptions.scope;
        var query = dataOptions.query;
        if(false == validScope(scope)) {
            ret.result = 1;
            ret.msg = "Invalid scope parameter: "+ scope;
            callback(ret);
            return;
        }
        // Extra check to prevent whether data is Array or not.
        if(data == undefined || typeof(data) != 'object' || (typeof(data) == 'object' && Array.isArray(data))) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data: ${data}`);
            ret.result = 1;
            ret.msg = "Invalid  data";
            callback(ret);
            return;
        }
        //Check on query parameter, it should be string
        if(query && typeof(query) != 'string') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data type of query: ${query}`);
            ret.result = 1;
            ret.msg = "Invalid  data type";
            callback(ret);
            return;
        }
        var keyArray = Object.keys(data);
        for (let app_key of keyArray) {
            if( app_key === '' ) {
                ret.result = 1;
                ret.msg = "Empty string as key not allowed.";
                callback(ret);
                return;
            }
        }
        //To check whether any scope's data has emptry string or null value as value of key.
        // for (let value of Object.values(data)) {
        //     if(value == null || value === ''){
        //         ret.result = 1;
        //         ret.msg = "Wrong value or data type of field !!";
        //         callback(ret);
        //         return;
        //     }
        // }
        //To check except session, does any scope has object as data type of key's value in custom data structure.
        // if(scope != SESSION) {
        //     for (let value of Object.values(data)) {
        //     if(typeof(value) == 'object'){
        //         ret.result = 1;
        //         ret.msg = "Wrong value or data type of field !!";
        //         callback(ret);
        //         return;
        //     }
        //     }
        // }
        var appData = {
            scope: scope, data: data, query: dataOptions.query
        };
        that.socket.sendParamEvent('saveCustomData',appData, (rsp) => {
            if (rsp.result != 0) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(rsp.msg);
                callback(rsp);
            } else {
                callback(rsp);
            }
        });
    }

    // It sets data on signalling server.
    that.setCustomData = (dataOptions, data, callback) => {
        let scope = dataOptions.scope;
        let query = dataOptions.query;
        let broadcast = dataOptions.broadcast;
        if (that.subscription && (that.subscription.datastore === undefined || that.subscription.datastore === false)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Customer datastore subsciption isn't supported for the room !!`);
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
            return;
        }
        var ret = { result: 0 };
        if( scope == OWNER || false == validScope(scope)) {
            ret.result = 1;
            if(scope == OWNER){
                ret.msg = "Owner scope not allowed.";
            } else {
                ret.msg = "Invalid scope parameter: "+ scope;
            }
            callback(ret);
            return;
        }
        //Check if value set for broadcast is valid or not.
        if(broadcast && false == validBroadcastOption(broadcast)) {
            ret.result = 1;
            ret.msg = "Invalid broadcast parameter: "+ broadcast;
            callback(ret);
            return;
        }

        // Extra check to prevent whether data is Array or not.
        if(data == undefined || typeof(data) != 'object' || (typeof(data) == 'object' && Array.isArray(data))) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data: ${data}`);
            ret.result = 1;
            ret.msg = "Invalid  data";
            callback(ret);
            return;
        }
        if(scope == USER && ( broadcast == undefined || broadcast == NONE )) {
            ret.result = 1;
            ret.msg = "Invalid broadcast option for scope USER, it mustn't be undefined or set to none.";
            callback(ret);
            return;
        }
        var keyArray = Object.keys(data);
        for (let app_key of keyArray) {
            if( app_key === '' ) {
                ret.result = 1;
                ret.msg = "Empty string as key not allowed.";
                callback(ret);
                return;
            }
        }
        //Check on query parameter, it should be string
        if(query && typeof(query) != 'string') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data type of query: ${query}`);
            ret.result = 1;
            ret.msg = "Invalid  data type";
            callback(ret);
            return;
        }

        // Check number of level to be accessed in query parameter,
        // If more than 2, then throw error.
        if(query && query.split('.').length > 2) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Object level access exceeded, current size : ${query.split('.').length}`);
            ret.result = 1;
            ret.msg = "Object level access exceeded, It mustn't be greater than 2.";
            callback(ret);
            return;
        }

        //These are for setting values locally
        //Object will be accessible upto level 2 only
        if(scope == ROOM){
            if(query){
                var splittedObject = query.split('.');
                if(splittedObject.length == 0) {
                    that.customRoomData = Object.assign(that.customRoomData,data);
                } else if (splittedObject.length == 1) {
                    if(that.customRoomData[query]){
                        that.customRoomData[query] = Object.assign(that.customRoomData[query],data);
                    } else {
                      that.customRoomData[query] = data;
                    }
                } else if (splittedObject.length == 2) {
                    if(that.customRoomData[splittedObject[0]]){
                        if(that.customRoomData[splittedObject[0]][splittedObject[1]]){
                            that.customRoomData[splittedObject[0]][splittedObject[1]] = Object.assign(that.customRoomData[splittedObject[0]][splittedObject[1]],data);
                        } else {
                            that.customRoomData[splittedObject[0]][splittedObject[1]] = data;
                        }
                    } else {
                        that.customRoomData[splittedObject[0]] = {};
                        that.customRoomData[splittedObject[0]][splittedObject[1]] = data;
                    }
                } else {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Object access level exceeded, it must be atmost 2 : ${query}`);
                    ret.result = 1;
                    ret.msg = "Object level access exceeded";
                    callback(ret);
                    return;
                }
            } else {
                that.customRoomData = Object.assign(that.customRoomData,data);
            }
            data = that.customRoomData;
        } else if(scope == SESSION) {
            if(query) {
                var splittedObject = query.split('.');
                if(splittedObject.length == 0) {
                    that.customSessionData = Object.assign(that.customSessionData,data);
                } else if (splittedObject.length == 1) {
                    if(that.customSessionData[query]){
                        that.customSessionData[query] = Object.assign(that.customSessionData[query],data);
                    } else {
                      that.customSessionData[query] = data;
                    }
                } else if (splittedObject.length == 2) {
                    if(that.customSessionData[splittedObject[0]]){
                        if(that.customSessionData[splittedObject[0]][splittedObject[1]]){
                            that.customSessionData[splittedObject[0]][splittedObject[1]] = Object.assign(that.customSessionData[splittedObject[0]][splittedObject[1]],data);
                        } else {
                            that.customSessionData[splittedObject[0]][splittedObject[1]] = data;
                        }
                    } else {
                        that.customSessionData[splittedObject[0]] = {};
                        that.customSessionData[splittedObject[0]][splittedObject[1]] = data;
                    }
                } else {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Object access level exceeded, it must be atmost 2 : ${query}`);
                    ret.result = 1;
                    ret.msg = "Object level access exceeded";
                    callback(ret);
                    return;
                }
            } else {
                that.customSessionData = Object.assign(that.customSessionData,data);
            }
            data = that.customSessionData;
        }

        if(broadcast == ALL) {
            var appData = { scope: scope, data: data, query: query};
            that.socket.sendParamEvent('setCustomData',appData, (rsp) => {
                if (rsp.result != 0) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(rsp.msg);
                    callback(rsp);
                } else {
                    callback(rsp);
                }
            });
        } else {
            //This will be emitted for non broadcast case, it will only be received by user itself.
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'custom-data-updated', message: { result: 0, scope:  scope, msg: "success"} });
            that.dispatchEvent(evt);
        }
    }

    //It is used to get data either from DB or from signalling room/user/session structure.
    that.getCustomData = (options, callback) => {
        if (that.subscription && (that.subscription.datastore === undefined || that.subscription.datastore === false)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Customer datastore subsciption isn't supported for the room !!`);
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
            return;
        }
        var ret = { result: 0 };

        // Extra check to prevent whether data is Array or not.
        if(options == undefined || typeof(options) != 'object' || (typeof(options) == 'object' && Array.isArray(options))) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data: ${options}`);
            ret.result = 1;
            ret.msg = "Invalid  options";
            callback(ret);
            return;
        }
        var scope = options.scope;
        var query = options.query;
        var db = options.db;

        //Check on db parameter, it should be boolean
        if(db && typeof(db) != 'boolean') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data type of db: ${query}`);
            ret.result = 1;
            ret.msg = "Invalid  data type";
            callback(ret);
            return;
        }

        // Check validity of scope.
        if(false == validScope(scope)) {
            ret.result = 1;
            ret.msg = "Invalid scope parameter: "+ scope;
            callback(ret);
            return;
        }

        //Check on query parameter, it should be string
        if(query && typeof(query) != 'string') {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data type of query: ${query}`);
            ret.result = 1;
            ret.msg = "Invalid  data type";
            callback(ret);
            return;
        }

        // Check number of level to be accessed in query parameter,
        // If more than 2, then throw error.
        if(query && query.split('.').length > 2) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Object level access exceeded, current size : ${query.split('.').length}`);
            ret.result = 1;
            ret.msg = "Object level access exceeded, It mustn't be greater than 2.";
            callback(ret);
            return;
        }

        if(db == undefined || db == false) {
            let targetScopeData;
            if(scope == ROOM) {
                targetScopeData = that.customRoomData;
            } else if(scope == SESSION) {
                targetScopeData = that.customSessionData;
            } else if (scope == USER) {
                if(that.userList.get(that.clientId)) {
                    targetScopeData = that.userList.get(that.clientId).customUserData;
                }
            }
            if(query) {
                var splittedObject = query.split('.');
                if(splittedObject.length > 2 ) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Object access level exceeded, it must be atmost 2 : ${query}`);
                    ret.result = 1;
                    ret.msg = "Object level access exceeded";
                    callback(ret);
                    return;
                } else {
                    if(targetScopeData == undefined) {
                        callback(`No data is set wrt provided scope : ${scope}, Data : ${targetScopeData}`);
                    } else if(splittedObject.length == 0) {
                        callback(targetScopeData);
                    } else if (splittedObject.length == 1) {
                        if(targetScopeData[query]){
                            callback(targetScopeData[query]);
                        } else {
                            callback("Data wrt query doesn't exist");
                        }
                    } else if (splittedObject.length == 2) {
                        if(targetScopeData[splittedObject[0]]){
                            if(targetScopeData[splittedObject[0]][splittedObject[1]]){
                                callback(targetScopeData[splittedObject[0]][splittedObject[1]]);
                            } else {
                                callback("Data wrt query doesn't exist");
                            }
                        } else {
                            callback("Data wrt query doesn't exist");
                        }
                    }
                }
            } else {
                callback(targetScopeData);
            }
        } else {
            if(db == true && scope != "session") {
                ret.result = 1;
                ret.msg = "Option true for db paramereter is valid for session scope only, scope used  : "+ scope;
                callback(ret);
                return;
            }
            var appData = {
                scope: scope, options: options, query: query
            };

            that.socket.sendParamEvent('getCustomData',appData, (rsp) => {
                if (rsp.result != 0) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(rsp.msg);
                    callback(rsp);
                } else {
                    callback(rsp);
                }
            });
        }
    }

    that.lock = (callback) => {
        lockRoom(true, callback);
    };

    that.unlock = (callback) => {
        lockRoom(false, callback);
    };

    that.dropUser = (clientIds, callback = () => { }) => {
        if (clientIds === undefined || clientIds === null || Array.isArray(clientIds) &&
            typeof callback === 'function' && that.me.role === 'moderator') {
            const tempMsg = {};
            tempMsg.all = false;
            tempMsg.clientIds = (clientIds === undefined || clientIds === null) ? [] : clientIds;
            that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.drop, tempMsg, callback);
        } else if (typeof callback === 'function') {
            const resp = that.me.role !== 'moderator' ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155;
            callback(resp);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('dropUser() invalid param - callback');
        }
    };

    that.pinUsers = (clientIds, callback = () => { }) => {
        pinUsers(true, clientIds, callback);
    };

    that.unpinUsers = (clientIds, callback = () => { }) => {
        pinUsers(false, clientIds, callback);
    };

    that.addSpotlightUsers = (clientIds, callback = () => { }) => {
        spotLightUsers(true, clientIds, callback);
    };

    that.removeSpotlightUsers = (clientIds, callback = () => { }) => {
        spotLightUsers(false, clientIds, callback);
    };


    that.destroy = (callback = () => { }) => {
        if (typeof callback === 'function' && that.me.role === 'moderator') {
            const tempMsg = {};
            tempMsg.all = true;
            tempMsg.clients = null;

            that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.drop, tempMsg, (resp) => { });
        } else if (typeof callback === 'function') {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: (`destroy - ${__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168}`) });
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('() invalid param - callback');
        }
    };

    that.setAudioOnlyMode = (enable, callback = () => { }) => {
        if (enable !== undefined && typeof enable === 'boolean' && enable != that.audioOnlyMode && typeof callback === 'function') {
            const promises = [];
            const talkerInfo = {
                numTalkers: that.userVideoTalkerCount,
                numAudioTalkers: that.userAudioTalkerCount,
            };

            // enable - if publisher is active, mute cam , set all subscribers to mute video
            promises[0] = new Promise((resolve, reject) => {
                talkerInfo.numVideoTalkers = enable ? 0 : that.userVideoTalkerCount;
                that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.set_active_talker, talkerInfo, (result) => { resolve(result); });
            });

            promises[1] = new Promise((resolve, reject) => {
                localStreams.forEach((stream, id) => {
                    if (stream && stream.ifVideo()) {
                        const muteFn = enable ? stream.muteVideo : stream.unmuteVideo;
                        muteFn((resp) => { resolve(resp); });
                    }
                });
            });

            Promise.all(promises).then((values) => {
                for (let i = 0; i < values.length; i++) {
                    if (values[i].result !== 0 && values[i].result !== __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1177.result) {
                        callback(values[i].result);
                        return;
                    }
                }
                that.audioOnlyMode = enable;
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000);
            });
        } else {
            const resp = enable === undefined || typeof enable !== 'boolean' ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1188;
            if (typeof callback === 'function') {
                callback(resp);
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('setAudioOnlyMode() invalid param - callback');
            }
        }
    };

    const validSpeakerDevice = (speakerId, callback) => {
        __WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].getDeviceList({speaker:true}, (resp) => {
            let found = false;
            if (resp.result == 0) {
                for (let count = 0; count < resp.devices.speaker.length; count++) {
                    if (resp.devices.speaker[count].deviceId == speakerId) {
                        found = true;
                        break;
                    }
                }
            }
            callback(found);
        });
    };

    const lockRoom = (lock, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (that.me.role === 'moderator' && lock != that.locked) {
                that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.lock_room, lock, (resp) => {
                    if (resp.result === 0) that.locked = lock;
                    callback(resp);
                });
            } else {
                const resp = that.me.role !== 'moderator' ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_4121;
                callback(resp);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('lockRoom() invalid param - callback');
        }
    };

    const pinUsers = (pin, clientIds, callback = () => { }) => {
        if (clientIds === undefined || clientIds === null || Array.isArray(clientIds) &&
            clientIds.length && typeof callback === 'function' && that.me.role === 'moderator') {
            const options = [{ id: 'update-pin-users', request: pin ? 'add' : 'remove', clientIds }];
            that.setAdvancedOptions(options, callback);
        } else if (typeof callback === 'function') {
            const resp = that.me.role !== 'moderator' ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155;
            callback(resp);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('pinUsers() invalid param - callback');
        }
    };


    const spotLightUsers = (spotlight, clientIds, callback = () => { }) => {
        if (clientIds === undefined || clientIds === null || Array.isArray(clientIds) &&
            clientIds.length && typeof callback === 'function') {
            const options = [{ id: 'spotlight-users', request: spotlight ? 'add' : 'remove', clientIds }];
            that.setAdvancedOptions(options, callback);
        } else if (typeof callback === 'function') {
            const resp = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155;
            callback(resp);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('spotlightUsers() invalid param - callback');
        }
    };

    const processFloorRequest = (options, action, callback = () => { }) => {
        if (options !== undefined && typeof options === 'string') {
            that.socket.sendSDP('processFloorRequest', options, action, (result, error) => {
                if (result === null) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Error on ${action} error: ${error}`);
                    callback(undefined, error);
                } else {
                    callback(result);
                }
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(` Floor Req : ${action}Invalid params`);
            callback(undefined, __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
        }
    };

    /**
     *Send socket event
     * @param options Object of  options supplied | object
     * @param callback callback function
     */
    that.sendSocketEvent = (options, callback = () => { }) => {
        const event = 'logClientEvents';
        that.socket.emitEvent(event, options, (result, error) => {
            if (error) {
                callback(error, 'error');
            } else {
                callback(result, 'success');
            }
        });
    };

    /**
     * Create Event logs for various events
     * @param eventType Type of event
     * @param additionalOptions Json provided to merge with the common options
     */
    that.createEventLog = (eventType, additionalOptions) => {
        // Common options
        const options = {
            eventType,
            roomId: that.roomID,
            logId: token.logId,
            timestamp: new Date(),
        };

        // adding the additional-options to options object,  provided by the event
        Object.assign(options, additionalOptions);

        // Event callback
        const eventCallback = (resp, type) => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Logging ${eventType} response:  ${JSON.stringify(resp)} , ${type} `);
        };

        // Logging event options
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`${eventType} :`, options);
        // send event to socket
        that.sendSocketEvent(options, eventCallback);
    };

    const sendSubscribersBitrate = () => {
        if (that.reconnectionState === false) {
            if (!that.sendRecvBitrateStats) {
                that.sendRecvBitrateStats = true;
            }
            const promises = [];
            let index = 0;
            remoteStreams.forEach((stream) => {
                if (stream.pc && stream.pc.peerConnection) {
                    promises[index] = stream.pc.peerConnection.getStats(null)
                        .then((results) => {
                            let bwInfo;
                            results.forEach((report) => {
                                if ((report.type === 'candidate-pair') && (report.availableIncomingBitrate !== undefined)) {
                                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`incoming bitrate: ${report.availableIncomingBitrate}`);
                                    bwInfo = {
                                        streamId: stream.getID(),
                                        availableRecvBitrate: parseInt(report.availableIncomingBitrate),
                                    };
                                }
                            });
                            return (bwInfo || { streamId: stream.getID(), availableRecvBitrate: 0 });
                        }, (err) => {
                            console.log(err);
                            return ({
                                streamId: stream.getID(),
                                availableRecvBitrate: 0,
                            });
                        });
                    index++;
                }
            });

            Promise.all(promises).then((values) => {
                let bw = 0;
                for (let i = 0; i < values.length; i++) {
                    bw += values[i].availableRecvBitrate;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Bitrates Total:${bw} streamInfo: ${JSON.stringify(values)}`);
                const stats = {
                    media: {
                        subscribers: {
                            totalAvailableBw: bw,
                        },
                    },
                };
                //send to server
                that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.client_stats, stats, (result) => {
                });
            });
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('Setting timeout again to execute ');
            setTimeout(sendSubscribersBitrate, 5000);
        } else {
            that.sendRecvBitrateStats = false;
        }
    };

    /**
     * Get Peer connection stats
     * @param streamPeerConnection Stream peerConnection
     * @param callback
     */
    const getPeerStats = (streamPeerConnection, callback) => {
        streamPeerConnection.getStats(null)
            .then((results) => {
                getResults(results, (result) => {
                    callback(result);
                });
            }, err => console.log(" peerconnection getStats failed err : " + err));
    };

    /**
     *  Get candidate list and codecs
     * @param results
     * @param callback
     */
    let successIndex = 0;
    function getResults(results, callback) {
        let activeCandidatePair = null;
        let localCandidate = {};
        let remoteCandidate = {};
        const result = {};
        const codecsList = {};
        results.forEach((report) => {
            if (report.type === 'transport') {
                activeCandidatePair = results.get(report.selectedCandidatePairId);
            }
            /**
             *  transportId = RTCTransport_audio_1, in new style
             *  earlier it was Conn-Audio-1
             *  */
            if (report.transportId == 'RTCTransport_audio_1' && report.ssrc && report.mediaType === 'audio') {
                let codea = '';
                results.forEach((item) => {
                    if (item.id === report.codecId) codea = item;
                });
                codecsList.audio = { codec: codea.mimeType };
            }

            if (report.transportId == 'RTCTransport_audio_1' && report.ssrc && report.mediaType === 'video') {
                let codev = '';
                results.forEach((item) => {
                    if (item.id === report.codecId) codev = item;
                });
                codecsList.video = { codec: codev.mimeType };
            }
        });

        // Fallback for Firefox.
        if (!activeCandidatePair) {
            results.forEach((report) => {
                if (report.type === 'candidate-pair' && report.selected) {
                    activeCandidatePair = report;
                }
            });
        }

        if (activeCandidatePair && activeCandidatePair.remoteCandidateId) {
            remoteCandidate = results.get(activeCandidatePair.remoteCandidateId).ip;
        }

        if (activeCandidatePair && activeCandidatePair.localCandidateId) {
            localCandidate = results.get(activeCandidatePair.localCandidateId).ip;
        }

        if ((localCandidate && Object.keys(localCandidate).length > 0) && (remoteCandidate && Object.keys(remoteCandidate).length > 0)) {
            successIndex++;
            result.selectedCandidates = {
                local: localCandidate,
                remote: remoteCandidate,
            };
        }

        if (Object.keys(codecsList).length > 0) {
            successIndex++;
            result.negotiatedCodecs = codecsList;
        }

        if (successIndex === 2) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('result data: ', result);
            successIndex = 0;
            callback(result);
        }
    }

    const validateVideoResolution = (specInput, assignDefault) => {
        if (specInput.videoSize == undefined) {
            if (assignDefault) {
                specInput.videoSize = [
                    videoResolutionRange.min.width,
                    videoResolutionRange.min.height,
                    videoResolutionRange.max.width,
                    videoResolutionRange.max.height,
                ];
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(' Failed : video size undefined');
                return __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1184;
            }
        } else {
            const minPixelsSet = specInput.videoSize[0] * specInput.videoSize[1];
            const maxPixelsSet = specInput.videoSize[2] * specInput.videoSize[3];
            const minPixelsConfig = videoResolutionRange.min.width * videoResolutionRange.min.height;
            const maxPixelsConfig = videoResolutionRange.max.width * videoResolutionRange.max.height;
            if (minPixelsSet < minPixelsConfig || minPixelsSet > maxPixelsConfig ||
                maxPixelsSet > maxPixelsConfig || maxPixelsSet < minPixelsConfig ||
                minPixelsSet > maxPixelsSet) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(` Failed : video size invalid minPixelsSet:${minPixelsSet} minPixelsConfig:${minPixelsConfig} maxPixelsSet: ${maxPixelsSet} maxPixelsConfig: ${maxPixelsConfig} req: min: ${specInput.videoSize[0]} X ${specInput.videoSize[1]} max: ${specInput.videoSize[2]} X ${specInput.videoSize[3]} config: min: ${videoResolutionRange.min.width} X ${videoResolutionRange.min.height} max: ${videoResolutionRange.max.width} X ${videoResolutionRange.max.height}`);
                return __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1184;
            }
        }
        return __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000;
    };

    //////////////Publish Stream///////////////////
    that.initPublishStream = (domPlayerId, specInput, successCallback, errorCallback) => {
        let stream;
        if (specInput !== undefined) {
            if (specInput.stream != undefined){
              stream = specInput.stream;
              if (stream.audio || stream.video){
                if(stream.stream){
                  if (domPlayerId != undefined && document.getElementById(domPlayerId) !== null) {
                    stream.play(domPlayerId, specInput.options);
                  }
                  successCallback(stream);
                }else {
                  stream.init();
                }
                return stream;
              }
              __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(' Failed : initPublishStream(): audio and video disabled in input stream');
              __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed,
                       { message: 'initPublishStream - a/v disabled in input stream' });
              errorCallback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1146);
              return;
            }
            if (specInput.audio || specInput.video || specInput.screen || specInput.canvas) {
                if (specInput.video && (that.mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].constant.H264_CODEC)
                    && (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name === 'safari')
                    && __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.version <= __WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_NOT_SUPPORTING_VP8) {
                    specInput.video = false;
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Stream publish in Init publish:- SAFARI - false');
                }

                if (specInput.video & !specInput.canvas) {
                    const res = validateVideoResolution(specInput, true);
                    if (res.result !== __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(' Failed : initPublishStream(): video size invalid');
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: 'initPublishStream - video size invalid' });
                        errorCallback(res);
                        return;
                    }
                }

                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`video Size: ${JSON.stringify(videoResolutionRange)} config.video_resolution_range: ${__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_resolution_range} token.roomMeta.settings.quality: ${token.roomMeta.settings.quality} room meta: ${JSON.stringify(token.roomMeta)} video Size: ${__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_resolution_range[token.roomMeta.settings.quality]}`);

                if (specInput.videoSize == undefined || !specInput.videoSize.length) {
                    specInput.videoSize = [
                        videoResolutionRange.min.width,
                        videoResolutionRange.min.height,
                        videoResolutionRange.max.width,
                        videoResolutionRange.max.height,
                    ];
                }
                //   that.oldSpecInfo=specInput;
                stream = EnxRtc.EnxStream(specInput);
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(' Failed : all stream opions (audio/video/screen/canvas)  false/undefined');
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: 'initPublishStream - all stream opions (audio/video/screen/canvas) false/undefined' });
                errorCallback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_publish_success, { message: 'initPublishStream - success' });
            stream = EnxRtc.EnxStream({
                audio: true,
                video: true,
                data: true,
                videoSize: [
                    videoResolutionRange.min.width,
                    videoResolutionRange.min.height,
                    videoResolutionRange.max.width,
                    videoResolutionRange.max.height,
                ],
            });
        }

        if (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
            const plugin = document.getElementById('WebrtcEverywherePluginId');
            plugin.addEventListener('media-access-allowed', (event) => {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`got media access:- ${JSON.stringify(event)}`);
                if (document.getElementById(domPlayerId) !== null) {
                    stream.play(domPlayerId);
                }
                successCallback();
            });
        } else {
            stream.addEventListener('media-access-denied', errorCallback);
            stream.addEventListener('media-access-failed', errorCallback);
            stream.addEventListener('media-access-allowed', (event) => {
                if (document.getElementById(domPlayerId) !== null) {
                    stream.play(domPlayerId, specInput.options);
                }
                successCallback(event.stream);
            });
        }
        stream.init();
        return stream;
    };

    /**
     * Start Share method
     * @param callback
     */
    const startShare = (options, callback) => {
        const config = {video: true,data: true,screen: true,fps: that.screenResolutionRange.fps,attributes: {name:'share'}};
        that.whoAmI((arg) => { config.attributes.name = `${arg.name}_share`; });
        config.audio = (options != undefined && options.audio != undefined) ? options.audio : false;
        const onAccessError = function (event) {
            if (event.msg.name === 'OverconstrainedError') {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Resolution selected is not supported by your webcam');
            }
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_screenshare_failed, { event });
            callback(event.msg);
        };

        const onAccessSuccess = function () {
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_screenshare_success, { error: {} });
            callback(true);
        };

        const stream = that.initPublishStream('', config, onAccessSuccess, onAccessError);
        return stream;
    };


    /**
     * Create the canvas element and add it to the DOM
     * @param selector : string  Selector ID, can be empty
     * @returns {string}: Canvas DOM Handle created
     */
    const createCanvas = (selector, appendTo = null, stream) => {
        if (selector) {
            return selector;
        }
        appendTo.style.position = 'relative';
        const annotateDiv = document.createElement('div');
        annotateDiv.setAttribute('class', 'annotate-div');
        annotateDiv.setAttribute('style', 'display:flex;justify-content: center;align-items: center;height: 100%;width: 100%;');
        if (!stream) {
            return;
        }
        const parentPlayerDiv = document.querySelector(`#player_${stream.getID()}`).parentElement;
        if (!parentPlayerDiv) {
            return;
        }
        const canvas = document.createElement('canvas');
        const domHandle = `${that.canvasVideoPlayer}_veneer`;
        canvas.id = domHandle;
        canvas.width = appendTo ? appendTo.clientWidth : that.canvasOptions.width;
        canvas.height = appendTo ? appendTo.clientHeight : that.canvasOptions.height;
        appendTo.style.height = `${canvas.height}px`;
        appendTo.style.width = `${canvas.width}px`;
        canvas.className = `${that.canvasVideoPlayer}_input_veneer`;
        canvas.setAttribute('style', 'display:none;');
        document.body.appendChild(canvas);

        if (appendTo) {
            that.canvasOptions.width = appendTo.clientWidth;
            that.canvasOptions.height = appendTo.clientHeight;
            const wrapper = document.createElement('div');
            wrapper.setAttribute('id', 'canvas-wrapper');
            wrapper.setAttribute('class', 'canvas-wrapper');
            if(!canvas) {
                return;
            }
            wrapper.style.width = `${canvas.width}px`;
            wrapper.style.height = `${canvas.height}px`;
            wrapper.style.position= 'absolute';
            wrapper.style.top = '0%';
            wrapper.append(canvas);
            __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].appendCustomCanvas(
                wrapper,
                canvas.className,
                canvas.width,
                canvas.height
            );
            // Adding a canvas for video tag
            __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].appendCanvasFrame(
                wrapper,
                canvas.className,
                canvas.width,
                canvas.height,
                stream

            );
            if(document.getElementById(appendTo.id)) {
                document.getElementById(appendTo.id).appendChild(wrapper);
            }
        } else {
            document.body.appendChild(wrapper);
        }
        if (appendTo != null) {
            annotateDiv.appendChild(appendTo);
            parentPlayerDiv.prepend(annotateDiv);
        }
        __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].bindEventListernersForTools();
        that.inputContext = canvas.getContext('2d');
        __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].startFrame();
        __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].pause_play(); // initially playing the frame video
        CombinedCanvas();
       // updateCanvas();
        return domHandle;
    };
         /** taking frames from annotation canvas and video canvas and drawing it to the resultant canvas */

         const CombinedCanvas = () => {
            let video_veneer2_id = __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getVideoFrameId();
            const videoCanvas = document.getElementById(video_veneer2_id);
            if(!videoCanvas){
                return;
            }
            let draw_veneer2_id = __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasId();
            const drawImageData = document.getElementById(draw_veneer2_id);
            if(!drawImageData){
                return;
            }
            timeIntervalforCanvas = setInterval(() => {
            that.inputContext.globalAlpha = 0.1
            if (videoCanvas.width > 0 && videoCanvas.height > 0 && __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasWidth() > 0 && __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasHeight() > 0)
                that.inputContext.drawImage(videoCanvas, 0, 0, __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasWidth(), __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasHeight());
                that.inputContext.globalAlpha = 1;
            if (drawImageData.width > 0 && drawImageData.height > 0 && __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasWidth() > 0 && __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasHeight() > 0 ) {
                that.inputContext.drawImage(drawImageData, 0, 0,__WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasWidth(),__WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].getCanvasHeight());
                }
            }, setTime);

        }

     /** not using for updatecanvas() instead we are using combinedCanvas()
      *  Add the video frames to canvas context using dawImage fn, and updating frames recursively using 'requestAnimationFrame'
      */
    const updateCanvas = () => {
        const drawImageData = document.getElementById('draw_veneer2');
        if (!drawImageData) {
            return;
        }
        const drawImageURL = drawImageData.toDataURL('image/png');
        const drawImage = new Image();
        drawImage.onload = function () {
            that.inputContext.globalAlpha = 1;
            that.inputContext.drawImage(drawImage, 0, 0, drawImageData.width, drawImageData.height);
        };
        drawImage.src = drawImageURL;
        that.inputContext.globalAlpha = 0.1;
        that.inputContext.drawImage(that.canvas_video_player, 0, 0, drawImageData.width, drawImageData.height);
        requestAnimationFrame(updateCanvas);
    };

    that.annotateToolAction = function (action, value) {
        __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].toolBarAction(action, value);
    };

    /**
  * Start Annotation method used to start Annotation over streaming
  * @stream stream
  * @stream callback
  * @returns Ack
  */
    that.startAnnotation = (stream, callback) => {
        let canvasWrapper = document.getElementById('canvas-wrapper');
        if (canvasWrapper) canvasWrapper.remove();
        try {
            if (!stream) {
                return;
            }
            const stream_id = stream.getID();
            const playerDOMID = document.querySelector(`#player_${stream_id}`);
            if (!playerDOMID) {
                return;
            }
            const status = validateCanvas();
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(status, 'status');
            that.canvas_video_player = document.getElementById(`stream${stream_id}`);
            if (!that.canvas_video_player) {
                return;
            }
            that.canvasVideoPlayer = `stream${stream_id}`;
            if (status.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                const canvasDomID = createCanvas(null, playerDOMID, stream);
                const props = {
                    canvasSelector: canvasDomID,
                    fps: 23,
                    canvasType: 'Annotation',
                };
                that.startCanvas(props, (arg) => {
                    // @todo - what is the purpose of this line?
                    if (arg.result == 0) {
                        if (callback) callback(status);
                    }
                });
                isCaptchaStarted = false;
                isAnnotationStarted = true;
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_annotation_success, { error: {} });
                __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].mouseAnnotate(
                    canvasDomID,
                    that.inputContext,
                    `player_${stream_id}`,
                    stream
                );
                // if (callback) callback(status);
            } else if (callback) {
                callback(status);
            }
        } catch (error) {
            console.info(error, 'error');
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`incorrect annotate params ${error}`);
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_annotation_failed, { error });
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
        }
    };

    /**
       * Stop Annotation method used to Stop Annotation over streaming
       * @stream callback
       * @returns Ack
    */
    that.stopAnnotation = (callback) => {
        isAnnotationStarted = false;
        that.stopCanvas(callback);
        __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].stopAnnotation();
        clearInterval(timeIntervalforCanvas);
    };

    /**
       * Adjustcanvas function adjust the size of canvas according to the stream size
    */
    that.adjustCanvas = () => {
        __WEBPACK_IMPORTED_MODULE_18__annotate__["a" /* default */].resize();
    }



    /**
     * Start Canvas method used to start canvas streaming
      * @param params
     * @param callback
     * @returns localStream
     */
    that.startCanvas = (params, callback = () => { }) => {
        if (typeof (callback) === 'function') {
            let localStream,
                canvasDomID;
            const selector = params ? params.canvasSelector : '';
            try {
              const status = validateCanvas();
              if (status.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                that.socket.emitEvent ('auxilaryPublishRequests', {req: 'start', pubType: 'canvas'},(resp) => {
                  if (resp.result == __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result){
                    canvasDomID = createCanvas(selector);
                    let frameRate;
                    let canvasType;
                    if (params) {
                        frameRate = params.fps ? params.fps : that.canvasOptions.fps;
                        canvasType = params.canvasType ? params.canvasType : 'default';
                    } else {
                        frameRate = that.canvasOptions.fps;
                        canvasType = 'default';
                    }
                    /*if (params.refreshFn === undefined){
                    var onCanvasRefresh = function () {
                        console.log("default wb.canvas inside refresh: "  + wb);
                        if (wb != undefined && wb.canvas !== undefined){
                        console.log("wb.canvas.add inside refresh " );
                        wb.canvas.add();
                        }
                    };
                    params.refreshFn = onCanvasRefresh;
                    }*/
                    const props = {
                        domHandle: canvasDomID,
                        fps: frameRate > 23 ? 23 : frameRate,
                        canvasType,
                        refreshFn: params.refreshFn,
                        maxRefreshRate: that.maxCanvasRefreshRate,
                    };
                    localStream = initCanvas(props, (res, type) => {
                        if (type === 'success') {
                            that.publish(
                                res, {
                                canvas: true,
                                canvasType,
                                maxVideoBW: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_bandwidth_range.canvas.max,
                                minVideoBW: __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.video_bandwidth_range.canvas.min,
                            },
                                (response) => {
                                    if (response.result === 0) {
                                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('startCanvas response.result:', response);
                                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_canvas_success, { error: {} });
                                        adjustMainVideoQuality(that.shareStatus, true);
                                        if (callback) callback(response);
                                    }
                                },
                            );
                        } else if (callback) {
                            callback(res);
                        }
                    });
                  }else if (callback) callback(status);
                });
              } else if (callback) callback(status);
            } catch (error) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`incorrect canvas params ${error}`);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_start_canvas_failed, { error });
                if (callback) {
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                }
            }
            return localStream;
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('startCanvas() invalid param - callback');
        }
    };

    /**
     *  Method to set video object for canvas and start the canvas streaming
     * @param videoPlayerId
     * @param options
     * @param callback
     */
    that.playVideo = (videoPlayerId, options, callback) => {
        that.canvasVideoPlayer = videoPlayerId;
        const playerObject = document.querySelector(`#${videoPlayerId}`); // Get the player object using the selector

        //if player does not exist in DOM return error
        if (playerObject === undefined || playerObject === null) {
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1162);
        } else {
            // Set the canvas options and start the canvas
            that.canvas_video_player = playerObject;
            if (options) {
                that.canvasOptions.width = options.width ? options.width : that.canvasOptions.width;
                that.canvasOptions.height = options.height ? options.height : that.canvasOptions.height;
                that.canvasOptions.fps = options.fps ? options.fps : 23;
            }
            that.startCanvas({ fps: options.fps }, callback);
        }
    };

    /**
     * method to stop screen share
     * @param callback
     */
    that.stopCanvas = (callback = () => { }) => {
        if (typeof (callback) === 'function') {
            const status = validateCanvas();
            if (status.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) {
                let stream2Remove;
                that.localStreams.forEach((stream) => {
                    if (stream && stream.ifCanvas()) {
                        discardLocalStreamForReconnect (false, true);
                        stream2Remove = stream;
                        stream.stream.getTracks().forEach((track) => {
                            track.stop();
                        });
                        stream.onConnectionStateChanged(false);
                        stream.close();
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_canvas_success, { error: {} });
                        callback({ result: 0, msg: 'Canvas stopped successfully.' });
                    }
                });
                adjustMainVideoQuality(that.shareStatus, false);
                if (stream2Remove != undefined)
                  that.localStreams.remove(stream2Remove.getID());
            } else {
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stop_canvas_failed, { error: {} });
                callback(status);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('stopCanvas() invalid param - callback');
        }
    };

    that.isModerator = () => (that.me && that.me.role === 'moderator');

    const sendRemoteMediaDeviceControlRequest = (req, mic, cam, broadcast, remClientId, callback) => {
        const error = validatePermission(mic, cam, true);
        if ((error.result === __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) && (broadcast || (remClientId && (typeof remClientId === 'string')))) {
            that.socket.sendMessage(req, { clientId: remClientId }, (resp) => {
                callback(resp);
            });
        } else {
            callback((error.result !== __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000.result) ? error : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
        }
    };

    const validatePermission = (check_audio, check_video, check_moderator) => {
        const subscription = (!that.subscription || ((!check_video || that.subscription.audio_video) &&
            (!check_audio || (that.subscription.audio_only || that.subscription.audio_video))));

        if (that && subscription && (!check_moderator || (that.me.role === 'moderator'))) {
            return __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000;
        }

        const error = !that ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1171 : !subscription ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1168;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`validateCanvas error code ${error.result}`);
        return error;
    };

    const validateCanvas = () => {
        if (that && (!that.subscription || that.subscription.audio_video) &&
            ((that.mode !== 'lecture') || (that.me.role === 'moderator') || (that.floorGranted === true))) {
            return __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_000;
        }
        const error = !that ? __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1171 : (!that.subscription || that.subscription.audio_video) ?
            __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1173 : __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170;
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`validateCanvas error code ${error.result}`);
        return error;
    };

    const initCanvas = (props, callback) => {
        let stream = null;
        const config = {
            video: true,
            canvas: true,
            attributes: {
                name: 'canvas',
            },
        };

        if (config.canvas === false) {
            config.canvas = true;
        }

        if (config.video === false) {
            config.video = true;
        }

        if (config.audio === true) {
            config.audio = false;
        }

        if (!config.div) {
            config.div = props.domHandle;
        }

        if (!config.fps) {
            config.fps = props.fps;
        }

        if (props.refreshFn != undefined) {
            config.refreshFn = props.refreshFn;
            config.maxCanvasRefreshRate = props.maxRefreshRate;
        }

        if (config.attributes === undefined) {
            config.attributes = { name: 'canvas' };
        } else if (config.attributes.name === undefined || config.attributes.name === 'canvas') {
            that.whoAmI((arg) => {
                config.attributes.name = `${arg.name}_canvas`;
            });
        }

        const onAccessError = function (event) {
            if (event.msg.name === 'OverconstrainedError') {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Resolution selected is not supported by your webcam');
            }
            callback(event.msg, 'error');
        };

        const onAccessSuccess = function (st) {
            stream = st;
            callback(stream, 'success');
        };

        // config.fps = 23;
        config.videoSize = [1920, 1080, 1920, 1080];
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`initcanvas config ${JSON.stringify(config)}`);
        that.initPublishStream('', config, onAccessSuccess, onAccessError);
        return stream;
    };

    const onCanvasStarted = (arg) => {
        let evt = null;
        that.isCanvasSharing = true;
        if (that.clientId == arg.clientId) {
            that.isCanvasSharingClient = true;
        }
        if (isCaptchaStarted) {
            evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({
                type: 'annotation-started-ack',
                message: {
                    clientId: arg.clientId,
                    name: arg.name,
                    streamId: arg.streamId,
                    canvasType: arg.canvasType,
                },
            });
        } else if (arg.canvasType === 'Annotation') {
            isAnnotationStarted = true;
            evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({
                type: 'canvas-started',
                message: {
                    clientId: arg.clientId,
                    name: arg.name,
                    streamId: arg.streamId,
                    canvasType: arg.canvasType,
                },
            });
        } else {
            that.canvasStatus = true;
            if (isAnnotationStarted) {
                that.canvasStatus = false;
            }
            isAnnotationStarted = false;
            evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({
                type: 'canvas-started',
                message: {
                    clientId: arg.clientId,
                    name: arg.name,
                    streamId: arg.streamId,
                    canvasType: arg.canvasType ? arg.canvasType : 'default',
                },
            });
        }
        adjustMainVideoQuality(that.shareStatus, true);
        that.dispatchEvent(evt);
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('onCanvasStarted event :', JSON.stringify(evt));
        if (arg.streamId) {
            const stream = remoteStreams.get(arg.streamId);
            if (stream && !stream.failed) {
                // forcing canvas subscriber stream to take HD layer with appropriate temporal layers
                stream._setStaticQualityLayer(2, -1, (result) => {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`stream._setStaticQualityLayer (2/-1) for canvas result : ${result}`);
                });
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('canvas started:stream is undefined or failed');
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('canvas arg.streamId is undefined');
        }
    };

    const onCanvasStopped = (arg) => {
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'canvas-stopped', message: { clientId: arg.clientId, name: arg.name, streamId: arg.streamId } });
        that.canvasStatus = false;
        that.isCanvasSharing = false;
        adjustMainVideoQuality(that.shareStatus, false);
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('onCanvasStopped event :', JSON.stringify(evt));
        that.dispatchEvent(evt);
        that.isCanvasSharingClient = false;
    };

    const onCanvasStateEvents = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('canvasStateEvents');
        if (arg.videomuted === true) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'canvas-state-events', message: 'Canvas stopped', reason: 'bw' });
            that.dispatchEvent(evt);
        } else {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'canvas-state-events', message: 'Canvas resumed', reason: 'bw' });
            that.dispatchEvent(evt);
        }
    };

    const onShareStateEvents = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('shareStateEvents');
        if (arg.videomuted === true) {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'share-state-events', message: 'Share stopped', reason: 'bw' });
            that.dispatchEvent(evt);
        } else {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'share-state-events', message: 'Share resumed', reason: 'bw' });
            that.dispatchEvent(evt);
        }
    };

    const onGenericEvents = (arg) => {
        if (arg.id === 'speaker_notification') {
            arg.id = 'talker-notification';
            let eventDetails = {};
            let talkerArray = arg.data;
            for (const talkerInfo of talkerArray) {
                if (talkerInfo.speech === true) {
                    eventDetails.speech = talkerInfo.users;
                } else if (talkerInfo.noise === true) {
                    eventDetails.noise = talkerInfo.users;
                }
            }
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.id, message: eventDetails });
            that.dispatchEvent(evt);
        } else {
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.id, message: arg.data });
            that.dispatchEvent(evt);
        }
    };

    const onUserRoleChangedEvent = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`onUserRoleChangedEvent${JSON.stringify(arg)} ownclientId: ${that.clientId}`);
        if (arg.moderator.new === that.clientId) {
            if (that.me.role === 'participant') {
                if (arg.sharePermissions){
                  that.sharePermissions.screen.approved = arg.sharePermissions.screen.approved;
                  that.sharePermissions.screen.pending = arg.sharePermissions.screen.pending;
                  that.sharePermissions.canvas.approved = arg.sharePermissions.canvas.approved;
                  that.sharePermissions.canvas.pending = arg.sharePermissions.canvas.pending;
                }
                that.me.role = 'moderator';
                if (arg.userList){
                  that.userList.clear();// clear up the userlist
                  for(const user in arg.userList) {that.userList.set(arg.userList[user].clientId, arg.userList[user]);}
                }

                if (arg.awaitedParticipants) {
                  for (const key in arg.awaitedParticipants) {
                    const partsInfo = {clientId: arg.awaitedParticipants[key].clientId, name: arg.awaitedParticipants[key].name};
                    that.awaitedParticipants.set(arg.awaitedParticipants[key].clientId, partsInfo);
                  }
                }
                if (that.mode === 'lecture') {
                    that.cCrequest = [];
                    that.cCapprovedHands = [];
                    if (arg.raisedHands.length) { arg.raisedHands.forEach((item) => { that.cCrequest.push(item);});}
                    if (arg.approvedHands.length) {arg.approvedHands.forEach((item) => {that.cCapprovedHands.push(item);});}
                } else {
                    //group mode
                }
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('onUserRoleChangedEvent() Already Moderator - no change');
            }
        } else if (arg.moderator.old === that.clientId) {
            if (that.me.role === 'moderator') {
                that.me.role = 'participant';
                if (arg.userList){
                  that.userList.clear();// clear up the userlist
                  for(const user in arg.userList) {that.userList.set(arg.userList[user].clientId, arg.userList[user]);}
                }
                that.sharePermissions.screen.approved = [];
                that.sharePermissions.screen.pending = [];
                that.sharePermissions.canvas.approved = [];
                that.sharePermissions.canvas.pending = [];
                that.sharePermissions.screen.state = 'idle';
                that.sharePermissions.canvas.state = 'idle';
                if (that.mode === 'lecture') {
                    that.cCrequest = [];
                    that.cCapprovedHands = [];
                    const lstrm = that.localStreams.getAll();
                    localStreams.forEach((stream, id) => {
                        that.unpublish(stream, (arg) => {
                            if (arg == true) {
                                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stream has been un-published');
                            } else {
                                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('error during stream un-publishing');
                                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unpublish_failed, { stream });
                            }
                        });
                    });
                }
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('onUserRoleChangedEvent() Already partcipant - no change');
            }
        }else {
          if (that.me.role === 'moderator'){
            const checkAndRemoveSharePermissionEntry = (pubType, id2Remove) => {
            let indx = that.sharePermissions[pubType].pending.indexOf(id2Remove);
            if (indx != -1)
              that.sharePermissions[pubType].pending.splice(indx,1);
            else if ((indx = that.sharePermissions[pubType].approved.indexOf(id2Remove)) != -1)
              that.sharePermissions[pubType].approved.splice(indx,1);
            };
            checkAndRemoveSharePermissionEntry ('screen', arg.moderator.new);
            checkAndRemoveSharePermissionEntry ('canvas', arg.moderator.new);
            if (that.mode === 'lecture') {
              if (!checkAndRemoveRequestedFloor(arg.moderator.new))
                 checkAndRemoveGrantedFloor(arg.moderator.new);
            }
          }
          let user = that.userList.get(arg.moderator.new);
          if (user && user.role == 'participant') user.role = 'moderator';
          user = that.userList.get(arg.moderator.old);
          if (user && user.role == 'moderator') user.role = 'participant';
        }
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'user-role-changed', message: arg });
        that.dispatchEvent(evt);
    };

    const onRoomSwitched = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`onUserRoleChangedEvent${JSON.stringify(arg)} ownclientId: ${that.clientId}`);
        if (that.mode === 'lecture') {
            that.mode = 'group';
            that.roomSettings.mode = 'group'
            that.cCrequest = [];
            that.cCapprovedHands = [];
        } else {
            if (that.mode === 'group') {
                that.roomSettings.mode = 'lecture'
                that.mode = 'lecture';
                that.cCrequest = [];
                that.cCapprovedHands = [];
                //Group to lecture mode, do all unpublish
                //Have all the data structure created.
                if (that.me.role === 'participant') {
                    localStreams.forEach((stream, id) => {
                        that.unpublish(stream, (arg) => {
                            if (arg == true) {
                                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('stream has been un-published');
                            } else {
                                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('error during stream un-publishing');
                                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_stream_unpublish_failed, { stream });
                            }
                        });
                    });
                } else {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('onUserRoleChangedEvent() Already Moderator - no change');
                }
            }
        }
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'room-mode-switched', message: { mode: that.mode, moderator: arg.moderator } });
        that.dispatchEvent(evt);
    };

    const onRoomManagementEvents = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`onRoomManagementEvents:${JSON.stringify(arg)}`);
        let msg = {};
        switch (arg.id) {
            case 'room-locked':
            case 'room-unlocked':
                that.locked = arg.id === 'room-locked';
                msg = arg.msg;
                break;
            case 'floor-opened':
                that.floorOpen = true;
                break;
            case 'floor-closed':
                that.floorOpen = false;
                break;
            case 'knock-enabled':
                that.knockEnabled = true;
                break;
            case 'knock-disabled':
                that.knockEnabled = false;
                that.awaitedParticipants.clear();
                break;
            case 'wait-room-disabled':
                if (that.waitRoom) {
                    that.waitRoom = false;
                }
                let stream;
                const streamList = [];
                const streams = arg.roomData.streams || [];
                const streamIndices = Object.keys(streams);
                const userList = arg.roomData.userList;

                for (let index = 0; index < streamIndices.length; index += 1) {
                    const arg = streams[streamIndices[index]];
                    stream = Object(__WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */])(that.Connection, {
                        streamID: arg.id,
                        local: false,
                        audio: arg.audio,
                        video: arg.video,
                        data: arg.data,
                        screen: arg.screen,
                        canvas: (!(typeof arg.canvas === 'undefined' || arg.canvas === false)),
                        attributes: arg.attributes,
                    });
                    streamList.push(stream);
                    remoteStreams.add(arg.id, stream);
                }

                for (const user in userList) {
                    that.userList.set(userList[user].clientId, userList[user]);
                }
                that.videoMutedUsers = arg.roomData.videoMutedUsers || [];
                msg = { streams: streamList, users: userList };
                break;
            case 'privacy-modes-updated':
            that.privacyModes = arg.modes;
            msg.modes = arg.modes;
            if (arg.userList) {
              msg.userList = arg.userList;
              for (const user in arg.userList) {
                that.userList.set(arg.userList[user].clientId, arg.userList[user]);
              }
            }
            break;
           case 'conf-media-activated':
            processMediaActivationEvent('event');
            break;
            default:
                msg = arg.msg;
        }
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.id, message: msg });
        that.dispatchEvent(evt);
    };

    const onInviteBreakOutRoom = (msg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Recieved an invite to join breakout room ${JSON.stringify(msg)}`);
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Join Breakout Room event dispatched');
        if (msg.force_join === true) {
            const invite = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({
                type: 'breakout-room-joining',
                message: { room_id: msg.room_id, requestor: msg.requestor }
            });
            that.dispatchEvent(invite);
            const data = { audio: true, video: true };
            that.muteRoom(data, (response) => {
                if (response.result === 0) {
                    localStreams.forEach((stream, id) => {
                        if (!stream.screen && !stream.canvas && (stream.ifAudio() || stream.ifVideo())) {
                            let roomInfo = { room_id: msg.room_id, role: 'participant' };
                            that.joinBreakOutRoom(roomInfo, { audio: true, video: msg.video?msg.video:false}, (resp, err) => {
                                if (resp) {
                                    const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({
                                        type: 'breakout-room-connected',
                                        streams: resp.streams, room: resp.room, roomData: resp.roomData,
                                        localBreakoutStream: resp.localBreakoutStream
                                    });
                                    that.dispatchEvent(connectEvt);
                                } else if (err) {
                                    const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'breakout-room-error', message: err });
                                    that.dispatchEvent(connectEvt);
                                }
                            });
                        }
                    });
                } else {
                    let evnt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'breakout-room-error' }, { message: ('mute room request failed') });
                    that.dispatchEvent(evnt);
                }
            });
            return;
        }
        const inviteEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'join-breakout-room', message: { room_id: msg.room_id, requestor: msg.requestor } });
        that.dispatchEvent(inviteEvt);
    };


    that.rejectBreakoutRoomInvite = (room_id, callback = () => { }) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Rejecting the breakout room invite `, room_id);
        if (room_id) {
            that.socket.sendMessage('reject-breakout-room', room_id, (result) => {
                if (result) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Reject breakout room, result: ${JSON.stringify(result)}`);
                    callback(result);
                }
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Invalid value room_id`);
            if (callback) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
            }
        }
    };

    const onUserJoinedBreakOutRoom = (data) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Recieved user joined breakout room ${JSON.stringify(data)}`);
        const joinedEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'user-joined-breakout-room', message: { clientId: data.client } });
        that.dispatchEvent(joinedEvt);
    };

    const onUserDisconnectedBreakOutRoom = (data) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`USER DISCONNECTED BREAKOUT ROOM ${JSON.stringify(data)}`);
        const disconnEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'user-disconnected-breakout-room', message: { name: data.name, clientId: data.clientId, room: data.room } });
        that.dispatchEvent(disconnEvt);
    };

    const onBreakOutRoomDestroyed = (data) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`BREAKOUT ROOM DESTROYED${JSON.stringify(data)}`);
        const destroyEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'breakout-room-destroyed', message: { room_id: data.room_id } });
        that.dispatchEvent(destroyEvt);
    };

    const onAnalyticsEvents = (data) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`Received Analytics events: ${JSON.stringify(data)}`);
        const analyticsEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'meeting-summary-events', message: {data} });
        that.dispatchEvent(analyticsEvt);
    };

    const onMeetingSummarySubscriptionEvents = (data) => {
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Received Meeting Summary Subscription Event : ${JSON.stringify(data)}`);
      const subscriptionEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'meeting-summary-subscription', message: {data} });
      that.dispatchEvent(subscriptionEvt);
    }

    const onTranscriptionEvents = (data) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`Received transcription events: ${JSON.stringify(data)}`);
        if(data.type === 'transcription-started') {
          if(data.transcription_type === 'room') {
            that.liveRoomTranscription = true;
            that.transcriptionLanguage = data.language;
          } else {
            that.liveTranscription = true;
            that.transcriptionLanguage = data.language;
          }
        } else if(data.type === 'transcription-stopped') {
          if(data.transcription_type === 'room')
            that.liveRoomTranscription = false;
          else
            that.liveTranscription = false;
        }
        const transEvt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'transcription-events', message: {data} });
        that.dispatchEvent(transEvt);
    };

    that.extendConferenceDuration = (callback = () => { }) => {
        if (typeof callback === 'function') {
            that.socket.emitEvent(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.extend_conference_duration, {}, (result) => {
                callback(result);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('extendConferenceDuration() : failed Invalid param. callback is not function');
        }
    };

    that.subscribeMediaStats = (reqType, callback = () => { }) => {
        if (reqType !== undefined && typeof reqType === 'string' && typeof callback === 'function') {
            if (that.state === CONNECTED && that.mediaStatsMode != reqType &&
                (reqType == 'disable' || reqType == 'notify' || reqType == 'display' || reqType == 'notify-display')) {
                const setDisplayStyle = (style) => {
                    const selecterStringsButton = document.querySelectorAll('.stats-container');
                    const selecterStringsOverlay = document.querySelectorAll('.stats-overlay');
                    selecterStringsButton.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = style;
                        }
                    });
                    selecterStringsOverlay.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = style;
                        }
                    });
                };
                if (reqType == 'disable' || that.mediaStatsMode == 'disable') {
                    //currently server stats based on local streamID.. need to change
                    localStreams.forEach((stream, id) => {
                        if (!stream.ifCanvas() && !stream.ifScreen()) {
                            socket.sendMessage(
                                'subscribeStreamStatsForClient', { streamId: id, statsEnabled: reqType != 'disable' },
                                (result) => {
                                    if (result != undefined) {
                                        if (result.status === 'Success') {
                                            setDisplayStyle((reqType == 'display' || reqType == 'notify-display') ? 'block' : 'none');
                                        }
                                        that.mediaStatsMode = reqType;
                                    }
                                },
                            );
                        }
                    });
                } else {
                    setDisplayStyle((reqType == 'display' || reqType == 'notify-display') ? 'block' : 'none');
                    that.mediaStatsMode = reqType;
                }
            } else {
                let err;
                if (that.state !== CONNECTED) {
                    err = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1171;
                } else if (that.mediaStatsMode == reqType) {
                    err = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1188;
                } else {
                    err = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155;
                }
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`that.subscribeMediaStats () error: ${JSON.stringify(err)}`);
                callback(err);
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('that.subscribeMediaStats () invalid param ');
            if (typeof callback === 'function') {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
            }
        }
    };

    that.subscribeStreamStatsForClient = (stream, statsEnabled, callback = () => { }) => {
      if (!socket) return 'Error getting stats - no socket';
      if (!stream) return 'Error getting stats - no stream';

      const setStatsView = (enable) => {
        const selecterStringsButton = document.querySelectorAll('.stats-container');
        const selecterStringsOverlay = document.querySelectorAll('.stats-overlay');
        that.mediaStatsMode = enable ? 'display': 'disable';
        that.subscribeSessionStats = enable;
        selecterStringsButton.forEach((selecterString) => {
          if ((selecterString !== undefined) && (selecterString !== null)) {
            selecterString.style.display = enable ? 'block': 'none';
          }
        });
        selecterStringsOverlay.forEach((selecterString) => {
          if ((selecterString !== undefined) && (selecterString !== null)) {
            selecterString.style.display = enable ? 'block' : 'none';
          }
        });
      }
      if (__WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name === 'chrome-stable' || __WEBPACK_IMPORTED_MODULE_11__Common_config___default.a.browser_info.name){
        setStatsView (statsEnabled);
        that.getStats(statsEnabled, {intervalSecs: 2, log: false}, (stats) => {
        });
        callback({status:'Success'});
      }else {
        socket.sendMessage('subscribeStreamStatsForClient', { streamId: stream.getID(), statsEnabled }, (result) => {
            if (result) {
                const selecterStringsButton = document.querySelectorAll('.stats-container');
                const selecterStringsOverlay = document.querySelectorAll('.stats-overlay');

                //To Do : need result/error code will send the result code
                if (result.status === 'Success' && statsEnabled === true) {
                    that.mediaStatsMode = 'display';
                    that.subscribeSessionStats = true;
                    selecterStringsButton.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'block';
                        }
                    });
                    selecterStringsOverlay.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'block';
                        }
                    });
                } else {
                    that.mediaStatsMode = 'disable';
                    that.subscribeSessionStats = false;
                    selecterStringsButton.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'none';
                        }
                    });
                    selecterStringsOverlay.forEach((selecterString) => {
                        if ((selecterString !== undefined) && (selecterString !== null)) {
                            selecterString.style.display = 'none';
                        }
                    });
                }
                callback(result);
            }
        });
      }
      return undefined;
    };

    that.subscribeForTalkerNotification = (enabled, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (!socket) {
                return 'Error subscribing - no socket';
            }
            let advancedOptions = [{ id: 'speaker-notification', enable: enabled }];
            that.setAdvancedOptions(advancedOptions, callback);
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('subscribeForTalkerNotification() invalid param - Callback');
        }
    };





    that.manageStatsSubscription = (stream) => {
        if (that.mediaStatsMode != 'disable') {
            const reqType = that.mediaStatsMode;
            that.mediaStatsMode = 'disable';
            that.subscribeMediaStats(reqType, (result) => { });
        } else if (that.subscribeSessionStats === true) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('resubscribe session stats');
            that.subscribeStreamStatsForClient(stream, that.subscribeSessionStats);
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('session stats not subscribed');
        }
    };

    that.reconPubSubFailed = (message) => {
        // after reconnect publish or subscribe failed, we should clear all peer connection and streams and emit event
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reconnect publish or subscribe failed', message);
        validateProcessNetworkTimeout (true, false);
    };

    that.manageNumTalker = () => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Reset the preferred number of active talkers');
        if (prefNumTakler !== -1) {
            that.setTalkerCount(prefNumTakler, (result) => {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('reset active talker', result);
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Use default prefrence of number of active talkers');
        }
    };

    that.startLiveMeetingSummary = (options, callback) => {
      let summaryOptions = {};
      if(options === undefined || callback === undefined) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('subscribeForLiveTranscription() invalid parameters');
        if(options !== undefined && typeof options === 'function') {
          callback(response.error_1155);
        }
        return;
      }

      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Starting the live meeting analytics for the room');

      if(options !== undefined && options.language !== undefined) {
        summaryOptions.language = options.language;
      } else {
        summaryOptions.language = "english_us"
      }

      if(options !== undefined && options.moderator_only !== undefined && typeof options.moderator_only === 'boolean') {
        summaryOptions.moderator_only = options.moderator_only;
      } else {
        summaryOptions.moderator_only = false
      }

      if(options !== undefined && options.record_summary !== undefined && typeof options.record_summary === 'boolean') {
        summaryOptions.record_summary = options.record_summary;
      } else {
        summaryOptions.record_summary = false;
      }

      if(that.liveMeetingAnalytics === false) {
        that.socket.sendMessage('startLiveMeetingAnalytics', summaryOptions, (response) => {
          if(response && response.result === 0) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("Setting the live meeting analytics for room");
            that.liveMeetingAnalytics = true;
          }
          if(callback) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("Sending the callbacks");
            callback(response);
          }
        });
      } else {
        if(callback) callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8003);
      }
    };

    that.stopLiveMeetingSummary = (callback = () => { }) => {
      let options = {};
      if(that.liveMeetingAnalytics === true || that.isAnalyticsStarted === true) {
        that.socket.sendMessage('stopLiveMeetingAnalytics', options, (response) => {
          that.liveMeetingAnalytics = false;
          if(response.result === 3001)
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8004);
          else
            callback(response);
        });
     } else {
        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8004);
        return;
      }
    };

    that.subscribeForLiveSummary = (options, callback) => {
      let summaryOptions = {}
      if(options === undefined || callback === undefined) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('subscribeForLiveSummary() invalid parameters');
        if(options !== undefined && typeof options === 'function') {
          callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
        }
        return;
      }

      if(options !== undefined && options.enable !== undefined && typeof options.enable === 'boolean') {
        summaryOptions.enable = options.enable
      } else {
        summaryOptions.enable = false;
      }
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`subscribe for live summary ${options.enable}`);
      that.socket.sendMessage('subscribeForLiveSummary', summaryOptions, (response) => {
        callback(response);
      });
    };

    that.getLiveMeetingSummary = (operation,callback = () => { }) => {
      let options = {};
       if(operation === undefined || callback === undefined) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('getLiveMeetingSummary invalid parameters');
        if(operation !== undefined && typeof options === 'function') {
          callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
        } else {
          callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
        }
        return;
      }

      if(operation !== undefined)
        options.operation = operation;
      else
        options.operation = 'abstract_summary'

      if(analytics_operation.indexOf(operation) !== -1) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('get the live meeting analytics for the room');
        that.socket.sendMessage('getLiveMeetingAnalytics', options, (response) => {
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`getLiveMeetingAnalytics returned ${response}`);
          callback(response);
        });
      } else {
         callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
      }
    };

    that.startLiveTranscription = (language, callback) => {
      let options = {};
      __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Starting the live transcription for the room');
      if(language === undefined && callback === undefined) {
        options.language = "english_us";
        options.room = true;
      } else if(callback === undefined) { //Check whether callback is a function
        if(language && typeof language === 'function') {
          callback = language;
          options.room = true;
          options.language = "english_us";
          __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Parameter null callback is params', JSON.stringify(options));
        } else {
          options.room = true;
          if(language === undefined) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error("Language parameter undefined, going ahead with default english_us");
            options.language = "english_us";
          } else {
            options.language = language;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Parameter null callback is params', JSON.stringify(options));
          }
        }
      } else {
          options.room = true;
          options.language = language;
      }
      if(that.liveRoomTranscription === false) {
        that.socket.sendMessage('startLiveTranscription', options, (response) => {
          if(response && response.result === 0) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("Setting the live transcription for room");
            that.liveRoomTranscription = true;
          }
          if(callback) {
              __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info("Sending the callbacks");
            callback(response);
          }
        });
      } else {
        if(callback) callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8001);
      }
    };

    that.subscribeForLiveTranscription = (asroptions, callback) => {
      let options = {};
      if(asroptions === undefined || callback === undefined) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('subscribeForLiveTranscription() invalid parameters');
        if(asroptions !== undefined && typeof asroptions === 'function') {
          asroptions(response.error_1155);
        }
        return;
      }
      if(asroptions !== undefined && asroptions.enable !== undefined &&
        typeof asroptions.enable === 'boolean') {
        if(asroptions.enable === true) {
          if(that.liveRoomTranscription === true) {
            options.language = that.transcriptionLanguage;
          } else {
            if(asroptions.language !== undefined) {
              options.language = asroptions.language;
            }
          }
          if(that.liveTranscription === false) {
            that.socket.sendMessage('startLiveTranscription', options, (response) => {
              if(response && response.result === 0) {
                that.liveTranscription = true;
              }
              if(callback) callback(response);
            });
          } else {
            if (callback) callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8001);
          }
        } else {
          let options = {client:true};
          if(that.liveTranscription === true) {
            that.socket.sendMessage('stopLiveTranscription', options, (response) => {
            that.liveTranscription = false;
            callback(response);
          });
          } else {
            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8002);
            return;
          }
        }
      } else {
        callback(response.error_1155);
        return;
      }
    }
    that.stopLiveTranscription = (callback = () => { }) => {
      let options = {};
      if(that.liveRoomTranscription === true) {
        options.room = true;
        that.socket.sendMessage('stopLiveTranscription', options, (response) => {
          that.liveRoomTranscription = false;
          callback(response);
        });
      } else {
        callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_8002);
        return;
      }
    };

    that.makeOutboundCall = (dialNumber, callerId, dialOptions, callback = () => { }) => {
        if (typeof callback === 'function') {
            const allow = !((that.subscription && (that.subscription.sip_outbound === false)));
            let options = {};
            if (dialOptions === undefined) {
                options.silent_join = true
            } else {
                if (dialOptions.name !== undefined) {
                    options.name = dialOptions.name;
                }
                if (dialOptions.early_media !== undefined && typeof dialOptions.early_media == 'boolean') {
                    //early media case
                    options.early_media = dialOptions.early_media;
                } else if (dialOptions.silent_join !== undefined && typeof dialOptions.silent_join == 'boolean')
                    options.silent_join = dialOptions.silent_join;
                else
                    options.silent_join = true;
            }
            if (allow === true) {
                if (dialNumber != null) {
                    console.log("Options: " + JSON.stringify(options));
                    that.socket.sendMessage('makeOutboundCall', { number: dialNumber, caller_id: callerId, options }, (response) => {
                        if (response && response.result === 0) {
                            that.dialOutList.set(dialNumber, { initiator: true, state: 'initiated' });
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Outbound call initiated for the number: ${dialNumber}`);
                        } else if (response && response.result === 1141) {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Outbound call is in progress for the number: ${dialNumber}`);
                        } else {
                            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Received ${JSON.stringify(response)} for outbound number: ${dialNumber}`);
                        }
                        // @todo - error handling
                        if (callback) {
                            callback(response);
                        }
                    });
                } // @todo - what happens in else condition
            } else if (!allow) {
                if (callback) {
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: 'makeOutboundCall - not allowed' });
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1170);
                }
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('makeOutboundCall() invalid param - callback');
        }
    };

    that.cancelOutboundCall = (dialNumber, callback) => {
        const dialState = that.dialOutList.get(dialNumber);

        if (dialState === undefined) {
            //This is the case where the client must have rejoined or moderator is trying to cancel the call.
            if (that.me.role === 'moderator') {
                that.socket.sendMessage('cancelOutboundCall', { number: dialNumber }, (response) => {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Cancel outbound call, response received is ${JSON.stringify(response)}`);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: 'cancelOutboundCall - success' });
                    if (callback) {
                        callback(response);
                    }
                });
            } else if (callback) {
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: 'cancelOutboundCall - Insufficient Privileges' });
                callback({ result: 1705, msg: 'Insufficient Privileges' });
            }
            return;
        }

        if (that.me.role === 'moderator' || dialState.initiator === true) {
            that.socket.sendMessage('cancelOutboundCall', { number: dialNumber }, (response) => {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Cancel outbound call, response received is ${JSON.stringify(response)}`);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: 'cancelOutboundCall - success' });
                if (callback) {
                    callback(response);
                }
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(' You need to be moderator or the initiator of the oubound call to disconnect the call.');
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: 'cancelOutboundCall - Insufficient Privileges' });
            if (callback) {
                callback({ result: 1705, msg: 'Insufficient Privileges' });
            }
        }
    };

    const onDialStateEvents = (msg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('recieved dialStateEvents');
        let dialState = that.dialOutList.get(msg.number);
        switch (msg.status) {
            case 'dialing':
                if (dialState === undefined) {
                    dialState = { initiator: false, state: 'dialing' };
                    that.dialOutList.set(msg.number, dialState);
                }
                break;

            case 'proceeding':
            case 'connected':
                dialState.state = msg.status;
                break;

            case 'failed':
            case 'timeout':
            case 'disconnected':
                that.dialOutList.delete(msg.number);
                break;

            default:
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('Unknown response received');
        }
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'dial-state-events', message: { number: msg.number, state: msg.status, description: msg.description } });
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug(`Dispatching dial state event: ${JSON.stringify(evt)}`);
        that.dispatchEvent(evt);
    };

    that.pingBack = (callback) => {
        that.socket.sendMessage('pingBack', {}, (response) => {
            if (callback) {
                callback(response);
            }
        });
    };

    //Generic log method for external tools usage
    that.startClientUsage = (data, callback) => {
        that.socket.sendMessage('startClientUsage', data, (response) => {
            if (callback) {
                callback(response);
            }
        });
    };

    that.stopClientUsage = (data, callback) => {
        that.socket.sendMessage('stopClientUsage', data, (response) => {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`callback received ${JSON.stringify(response)}`);
            if (callback) {
                callback(response);
            }
        });
    };

    /*
    * Creates the breakout room, sends the room_id and room_name in the callbacks.
    */
    that.createBreakOutRoom = (data, callback = () => { }) => {
        if (typeof callback === 'function' && typeof data === 'object' && data.hasOwnProperty('participants')) {
            if (data && data.participants > 0) {
                that.socket.sendMessage('create-breakout-room', data, (result) => {
                    if (result) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Create breakout room, result: ${JSON.stringify(result)}`);
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: 'createBreakOutRoom - success' });
                        callback(result);
                    }
                });
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Invalid value for participants ${JSON.stringify(data)}`);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: `createBreakOutRoom - Invalid value for participants ${JSON.stringify(data)}` });
                if (callback) {
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                }
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('createBreakOutRoom() invalid param - callback/RoomDefinition');
        }
    };

    /*
    * Creates and Automatically Invites participants to the breakout room.
    * Participants are choosen automatically for the breakout room.
    */
    that.createAndInviteBreakOutRoom = (data, callback) => {
        if (data && data.max_rooms > 0) {
            data.force_join = true;
            that.socket.sendMessage('create-invite-breakout-room', data, (result) => {
                if (result) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Create breakout room, result: ${JSON.stringify(result)}`);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: 'createAndInviteBreakOutRoom - success' });
                    callback(result);
                }
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Invalid value for participants ${JSON.stringify(data)}`);
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failed, { message: `createAndInviteBreakOutRoom - Invalid value for participants ${JSON.stringify(data)}` });
            if (callback) {
                callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
            }
        }
    };

    that.joinBreakOutRoom = (data, streamInfo, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (data && data.room_id !== null && data.role !== null) {
                that.socket.sendMessage('join-breakout-room', data, (resp) => {
                    if (resp && resp.result === 0) {
                        that.breakOutRoom.joinRoom(resp.token, streamInfo, (success, error) => {
                            if (success) {
                                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`****Join Breakout Room Success****, sending user-joined-event****${JSON.stringify(success.roomData)}`);
                                that.socket.sendMessage('user-joined-breakout-room', { name: success.roomData.name });
                                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: 'joinBreakOutRoom - success' });
                                if (callback) {
                                    callback(success, null);
                                }
                            }
                            if (error) {
                                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failure, { message: 'joinBreakOutRoom - failure' });
                                if (callback) {
                                    callback(null, error);
                                }
                            }
                        });
                    } else {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data, room id not found ${JSON.stringify(data)}`);
                        __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failure, { message: `joinBreakOutRoom - Invalid data, room id not found ${JSON.stringify(data)}` });
                        if (callback) {
                            callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                        }
                    }
                });
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(`Invalid data, room id not found${JSON.stringify(data)}`);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failure, { message: `joinBreakOutRoom - Invalid data, room id not found ${JSON.stringify(data)}` });
                if (callback) {
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                }
            }
        }
        else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('joinBreakoutRoom() invalid param - callback');
        }
    };

    that.inviteToBreakoutRoom = (data, callback = () => { }) => {
        if (typeof callback === 'function' && typeof data === 'object' && data.hasOwnProperty('room_id')) {
            if (data === undefined || data.room_id === undefined) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Invalid data, room id not found${JSON.stringify(data)}`);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_failure,
                    { message: `inviteToBreakoutRoom - Invalid data, room id not found ${JSON.stringify(data)}` });
                if (callback) {
                    callback(__WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1155);
                }
                return;
            }
            that.socket.sendMessage('invite-breakout-room', data, (result) => {
                if (result) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Create breakout room, result:${JSON.stringify(result)}`);
                    __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_general_success, { message: 'inviteToBreakoutRoom - success' });
                    if (callback) {
                        callback(result);
                    }
                }
            });
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('inviteToBreakoutRoom() invalid param - callback/invitee');
        }
    };

    that.clearAllBreakOutSession = (callback) => {
        if (callback !== undefined && typeof callback === 'function') {
            that.breakOutRoom.disconnectAll();
            that.resumeRoom(callback);
        }
    };

    that.destroyAllBreakOutSession = (callback) => {
        if (that.me.role === 'moderator') {
            that.breakOutRoom.destroyAll();
            that.resumeRoom(callback);
        }
    };


    const fileUploader = async function (archive, options = { isMobile: false, broadcast: true, clientList: [] }, callback) {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' init file upload ');
        const upJobId = uploadsInProgress.size;
        const fUploadResult = {
            messageType: 'upload-started',
            result: 0,
            description: 'upload started',
            response: {
                uploadStatus: 'started',
                upJobId,
                uploadInfo: {
                    upJobId,
                    name: archive.name,
                    size: archive.size,
                    type: archive.type,
                },
            },
        };

        try {
            const fs = new __WEBPACK_IMPORTED_MODULE_15__fileShare_app_fileSender__["a" /* default */]();
            const fSender = { sender: fs, status: 'started' };
            uploadsInProgress.set(upJobId, fSender);
            // fire event to app informing upload success  // to do : modify the message and keep only relevent metadata
            let evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
            that.dispatchEvent(evt);
            // upload the file
            const file = await fs.upload(archive);
            const sFile = file.toJSON();

            //update the status as complete and update the map
            fSender.status = 'completed';
            uploadsInProgress.set(upJobId, fSender);
            fUploadResult.messageType = 'upload-completed';
            fUploadResult.response.uploadStatus = fSender.status;
            fUploadResult.response.upJobId = upJobId;
            fUploadResult.description = ' upload completed';
            fUploadResult.response.uploadInfo = {
                upJobId,
                name: sFile.name,
                size: sFile.size,
                speed: sFile.speed,
                createdAt: sFile.createdAt,
                dlimit: sFile.dlimit,
                time: sFile.time,
                expiresAt: sFile.expiresAt,
                timeLimit: sFile.timeLimit,
            };

            if (options.isMobile === true) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file sharing mobile client ');
                fUploadResult.response.uploadInfo = sFile;
                fUploadResult.response.uploadInfo.upJobId = upJobId;
                shFileList.push (sFile);
                let favailable = JSON.parse(JSON.stringify(sFile));
                favailable.index = shFileList.length - 1;
                that.availableFiles.push(favailable);
                evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
                that.dispatchEvent(evt);
                callback(fUploadResult);
                return;
            }

            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' is mobile  false ', options.isMobile);
            // web client send the data to signalling server
            // do we want to provide a default way to
            //allow user to append File sharing fantom UI  then this provision can be used with UI modification
            if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                inFileShareUI(sFile, document.getElementById(fileShareUI.recvElToAppend), 'fs-file-uploaded');
            }

            sendFtData(sFile, 'fs-file-available', options.broadcast, options.clientList, (res) => {
                fUploadResult.response.sentStatus = res;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('sent message to all participants: file is available for download ', res, 'fupload result', fUploadResult);
                // fire event to app informing upload success
                // to do : modify the message and keep only relevent metadata
                shFileList.push (sFile);
                let favailable = JSON.parse(JSON.stringify(sFile));
                favailable.index = shFileList.length - 1;
                that.availableFiles.push(favailable);
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('file upload fs-file-available name: ' + favailable.name + ' id: ' + (favailable.id ? favailable.id : "undefined"));
                evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
                that.dispatchEvent(evt);
                callback(fUploadResult);
            });

            //refactor seems some error need to check why callback not returned from send ft
            // comment below event to fix duplcate message
            evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
            that.dispatchEvent(evt);
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_shared_success, { error: {} });
            callback(fUploadResult);
        } catch (error) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('upload to file server failed', error);
            uploadsInProgress.delete(upJobId);
            fUploadResult.messageType = 'upload-failed';
            fUploadResult.response.uploadStatus = 'failed';
            fUploadResult.description = ' upload failed';
            fUploadResult.result = 1;
            const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-upload-result', message: fUploadResult });
            that.dispatchEvent(evt);
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('exception in file upload ', error);
            // callback sith failure code
            const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1182;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' send file failed', result);
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_shared_failed, { error: {} });
            callback(result);
        }
    };

    //  var callback =( res)=> {console.log('send file response ', res)};
    // (msg, broadcast, clientList, callback)
    that.sendFiles = (files = [], options = { isMobile: false, broadcast: true, clientList: [] }, callback) => {
        // sanatize the input , check if it is a proper file or not
        // upload files
        // check the sanity of files array
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(`Send file called options ${JSON.stringify(options)} file object ${JSON.stringify(files)}`);
        if (that.state === DISCONNECTED && options.isMobile === false) {
            const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1180;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file upload: room is disconnected, file operations are not allowed');
            __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_shared_failed, { message: 'file upload: room is disconnected, file operations are not allowed' });
            callback(result);
            return;
        }

        if (!(callback && typeof callback === 'function')) {
            var callback = (res) => {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('SDK defined callback send file response ', res);
            };
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('send file called with callback ');
        }

        if (files.length > 0) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('preparing to upload files');
            that.filesToUpload = files;
            try {
                if (that.filesToUpload[that.filesToUpload.length - 1].size <= 0) {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file size is 0 bytes ', that.filesToUpload[that.filesToUpload.length - 1].size);
                    const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1186 + that.filesToUpload[that.filesToUpload.length - 1].size;
                    callback(result);
                    return;
                }

                if (!options.isMobile) {
                    // check the size limit
                    if (that.filesToUpload[that.filesToUpload.length - 1].size > maxFileSize) {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file upload limit exceeded. max allowed limit is ', maxFileSize);
                        const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1187 + maxFileSize;
                        callback(result);
                        return;
                    }
                    // send the signalling mesage about upload started
                    const fsMessage = {};
                    fsMessage.data = files;

                    // do we want to provide a default way to
                    //allow user to append File sharing fantom UI  then this provision can be used with UI modification
                    if (that.showFsUi === true && document.getElementById(fileShareUI.recvElToAppend) !== null) {
                        inFileShareUI(fsMessage, document.getElementById(fileShareUI.recvElToAppend), 'fs-upload-init');
                    }

                    sendFtData(fsMessage, 'fs-upload-started', options.broadcast, options.clientList, (res) => {
                        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file-upload-started sent to all participants', res);
                    });
                }

                const archive = new __WEBPACK_IMPORTED_MODULE_16__fileShare_app_archive__["a" /* default */](files);
                fileUploader(archive, options, callback);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_shared_success, { error: {} });
            } catch (error) {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('exception occured in send file ', error);
                // callback sith failure code
                const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1182;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' send file failed', result);
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_shared_failed, { error: {} });
                callback(result);
            }
        } else {
            const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1185;
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' input file list to upload is empty', result, ' length of file array', files.length);
            callback(result);
        }
    };

    that.recvFiles = async (index, options = { isMobile: false }, callback = () => { }) => {
        if (typeof callback === 'function') {
            if (that.state === DISCONNECTED && options.isMobile === false) {
                const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1180;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file download: room is disconnected file operations are not allowed');
                if (callback != undefined) {
                    callback(result);
                }
                return;
            } else if (index > shFileList.length) {
                const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1181;
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file download: file is not available');
                if (callback != undefined) {
                    callback(result);
                }
                return;
            }

            const fDownloadResult = {
                messageType: 'download-started',
                result: 0,
                description: 'download-started',
                response: {
                    downloadStatus: 'started',
                    jobId: index,
                    downloadInfo: that.availableFiles[index],
                },
            };

            try {
                const fileInfo = shFileList[index];
                // download started for file , send the fs-download-result event with data from available list of files
                // set up file receiver
                const url = fileInfo.url.split('#')[0];
                const response = await fetch(url);
                const gheder = response.headers.get('WWW-Authenticate');
                const tempNonce = gheder.replace('send-v1 ', '');
                const fr = new __WEBPACK_IMPORTED_MODULE_17__fileShare_app_fileReceiver__["a" /* default */]({
                    secretKey: fileInfo.secretKey,
                    id: fileInfo.id,
                    nonce: tempNonce,
                    requiresPassword: false,
                });

                // set the download in progress map
                const fReceiver = {
                    receiver: fr,
                    status: 'started',
                };

                downloadsInProgress.set(index, fReceiver);
                // fire event to app informing upload success  // to do : modify the message and keep only relevent metadata
                let evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
                that.dispatchEvent(evt);
                // get meta and download file
                await fr.getMetadata();
                const resp = await fr.download(options);
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file downloaded successfully ', resp);

                fReceiver.status = 'completed';
                downloadsInProgress.set(index, fReceiver);
                fDownloadResult.messageType = 'download-completed';
                fDownloadResult.response.downloadStatus = fReceiver.status;
                fDownloadResult.response.jobId = index;
                fDownloadResult.description = ' upload completed';
                evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].info('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_download_success, { error: {} });
                that.dispatchEvent(evt);

                if (callback != undefined) {
                    callback(resp);
                }
            } catch (error) {
                // delete the entry from download progress map
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file download failed', error);
                downloadsInProgress.delete(index);
                fDownloadResult.messageType = 'download-failed';
                fDownloadResult.response.downloadStatus = 'failed';
                fDownloadResult.description = ' download failed';
                fDownloadResult.result = 1;// do we send 1 for failure for other SDK fails ? need to check
                const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: 'fs-download-result', message: fDownloadResult });
                that.dispatchEvent(evt);

                const result = __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1183;
                __WEBPACK_IMPORTED_MODULE_13__EventLogger__["a" /* default */].error('room-event', __WEBPACK_IMPORTED_MODULE_12__customEvents__["a" /* default */].event_file_download_failed, { error: __WEBPACK_IMPORTED_MODULE_10__customErrors__["a" /* default */].error_1183.desc });
                if (callback != undefined) {
                    callback(result);
                }
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('recvFiles() invalid param - callback');
        }

    };

    that.mobileSetAvailableFile = (dat, callback) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('mobile sdk wants to set the available file list ', dat);
        // To Do validate and sanantize to see if SDK is pushing correct values ?
        if (dat.message.type === 'fs-file-available') {
            // can further sanataze but do we need ?
            shFileList.push(dat.message);
            // mobile does not have available file list and we do not want to expose full structure
            // to do :- find a better solution to abstract this for mobile sdk user and normal open API
            const favailable = {
                name: dat.message.name,
                size: dat.message.size,
                speed: dat.message.speed,
                createdAt: dat.message.createdAt,
                dlimit: dat.message.dlimit,
                time: dat.message.time,
                expiresAt: dat.message.expiresAt,
                timeLimit: dat.message.timeLimit,
                index: shFileList.length - 1,
            };
            that.availableFiles.push(favailable);

            callback(true);
        } else {
            callback(true);
        }
    };

    that.setFsEndPoint = (options = { isMobile: false, fsDetails: {} }) => {
        if (options.isMobile === true) {
            //    Logger.info('set filsharing service details from mobile client', JSON.stringify(options.fsDetails));
            Object(__WEBPACK_IMPORTED_MODULE_14__fileShare_app_api__["f" /* setFileShareServiceEndPoint */])(options.fsDetails, options.callInfo); // pass the call info as well
        }
    };

    // added for testing , if needed we can extend it to provide injected UI
    that.inJectFsUI = (options = { enable: true, uploadElToAppend: '', recvElToAppend: '' }) => {
        if (options && options.enable === true && options.uploadElToAppend !== '' && document.getElementById(options.uploadElToAppend) !== null && options.recvElToAppend !== '' && document.getElementById(options.recvElToAppend) !== null) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' show file sharing UI ');
            that.showFsUi = true;
            fileShareUI.uploadElToAppend = options.uploadElToAppend;
            fileShareUI.recvElToAppend = options.recvElToAppend;
            that.testFT();
        } else {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file UI injection failed');
        }
    };

    that.testFT = () => {
        if ((that.showFsUi === false) || (that.showFsUi === true && document.getElementById(fileShareUI.uploadElToAppend) === null)) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' file upload  UI can not be appended');
            return;
        }
        const x = document.createElement('INPUT');
        x.setAttribute('type', 'file');
        x.setAttribute('id', 'filesID');
        //  var elToAppend = document.getElementById('chat_btn');
        const elToAppend = document.getElementById(fileShareUI.uploadElToAppend);
        elToAppend.appendChild(x);

        function handleFileSelect(evt) {
            const files = evt.target.files; // FileList object
            //    that.filesToUpload = files;
            // temp test for android
            //    that.sendFiles(that.filesToUpload);
            that.sendFiles(files);
            // Loop through the FileList and render image files as thumbnails.
            for (var i = 0, f; f = files[i]; i++) {
                console.log(f);
            }
        }

        document.getElementById('filesID').addEventListener('change', handleFileSelect, false);
        document.getElementById('filesID').addEventListener('click', (evt) => {
            evt.target.value = null;
        }, false);
    };

    //room level functionality to cancel all running uploads
    that.cancelUploads = (cancelAll = false, upJobId = undefined, callback) => {
        const res = {
            description: 'failed',
            result: 1,
        };
        if (upJobId === undefined && cancelAll === false) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error(' upJobId must be defined for cancelling a particular upload ');
            res.description = 'upJobId is undefined.';
            res.result = 1;
            if (callback !== undefined) {
                return callback(res);
            }
        } else if (cancelAll === true) {
            for (const [key, value] of uploadsInProgress) {
                if (value.status === 'started') {
                    value.sender.cancel();
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' running jobs are', value);
                } else {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' status is ', value.status);
                }
            }
            res.description = 'Cancelled all uploads';
            res.result = 0;
            if (callback !== undefined) {
                callback(res);
            }
        } else if (upJobId != undefined) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('cancelling specified upload with id', upJobId);
            const cancelUpload = uploadsInProgress.get(upJobId);
            if (cancelUpload != undefined) {
                if (cancelUpload.status === 'started') {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('canceled upload', upJobId);
                    cancelUpload.sender.cancel();
                    res.description = `Cancelled upload ${upJobId}`;
                    res.result = 0;
                    if (callback != undefined) {
                        callback(res);
                    }
                } else if (cancelUpload.status === 'completed') {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('upload can not be cancelled because it is already completed');
                    res.description = 'upload is already completed.';
                    res.result = 1;
                    if (callback != undefined) {
                        callback(res);
                    }
                }
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Uplode id is invalid');
                res.description = 'Uplode id is invalid. ';
                res.result = 1;
                if (callback != undefined) {
                    callback(res);
                }
            }
        }
    };

    //room level functionality to cancel all running uploads
    that.cancelDownloads = (cancelAll = false, dJobId = undefined, callback) => {
        const res = { description: 'failed', result: 1 };
        if (dJobId === undefined && cancelAll === false) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].error('ID must be defined for cancelling a particular upload ');
            res.description = 'ID is undefined.';
            res.result = 1;
            if (callback !== undefined) {
                return callback(res);
            }
        } else if (cancelAll === true) {
            for (const [key, value] of downloadsInProgress) {
                if (value.status === 'started') {
                    value.receiver.cancel();
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' running jobs are', value);
                } else {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info(' status is ', value.status);
                }
            }
            res.description = 'Cancelled all downloads';
            res.result = 0;
            if (callback !== undefined) {
                callback(res);
            }
        } else if (dJobId != undefined) {
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('cancelling specified download with id', dJobId);
            dJobId = dJobId.toString();
            const cancelDownloadload = downloadsInProgress.get(dJobId);
            if (cancelDownloadload != undefined) {
                if (cancelDownloadload.status === 'started') {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('cancelling download', dJobId);
                    cancelDownloadload.receiver.cancel();
                    res.description = `Cancelled download ${dJobId}`;
                    res.result = 0;
                    if (callback != undefined) callback(res);
                } else if (cancelDownloadload.status === 'completed') {
                    __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('Download can not be cancelled because it is already completed');
                    res.description = 'download is already completed.';
                    res.result = 1;
                    if (callback != undefined) {
                        callback(res);
                    }
                }
            } else {
                __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('download id is invalid');
                res.description = 'Download id is invalid. ';
                res.result = 1;
                if (callback != undefined) {
                    callback(res);
                }
            }
        }
    };

    // test function for mobile SDK file sharing  // remove it latter
    that.testFtMobile = (isMobile = false) => {
        const x = document.createElement('INPUT');
        x.setAttribute('type', 'file');
        x.setAttribute('id', 'files-mobile');
        let elToAppend = '';
        if (isMobile === false) {
            elToAppend = document.getElementById('chat_btn');
        } else {
            elToAppend = document.body;
        }

        elToAppend.appendChild(x);

        function handleFileSelect(evt) {
            const files = evt.target.files; // FileList object
            __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].info('mobile list of files to upload', files[0]);

            that.filesToUpload = files;
            // that.sendFiles(that.filesToUpload);

            // Loop through the FileList and render image files as thumbnails.
            for (var i = 0, f; f = files[i]; i++) {
                console.log('iterating file list', f);
            }
        }

        document.getElementById('files-mobile').addEventListener('change', handleFileSelect, false);
    };

    const socketOnHlsStreamingNotification = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('onstreamingnotification events' + JSON.stringify(arg));
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.type, message: arg.data });
        // if(evt.message.stream_url) {
        //     that.saveCustomData(SESSION, {'stream_url': evt.message.stream_url}, function(rsp) {

        //     });
        // }
        that.dispatchEvent(evt);
    };

    const socketOnHlsStreamingNotificationToPublisher = (arg) => {
        __WEBPACK_IMPORTED_MODULE_8__utils_Logger__["default"].debug('socketOnHlsStreamingNotificationToPublisher events' + JSON.stringify(arg));
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.type, message: arg.data });
        that.dispatchEvent(evt);
    };

    const socketOnStreamingNotification = (arg) => {
        //      Logger.debug('onstreamingnotification events' + JSON.stringify(arg));
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.type, message: arg.data });
        that.dispatchEvent(evt);
    };
    const socketOnLiveRecordingNotification = (arg) => {
        //      Logger.debug('onLiveRecordingnotification events' + JSON.stringify(arg));
        const evt = Object(__WEBPACK_IMPORTED_MODULE_1__Events__["e" /* RoomEvent */])({ type: arg.type, message: arg.data });
        that.dispatchEvent(evt);
    };
    if (__WEBPACK_IMPORTED_MODULE_0__Pair__["a" /* default */].browserEngineCheck() !== 'IE') {
        //that.on('room-disconnected', clearAll);
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream, socketEventToArgs.bind(null, socketOnAddStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting, socketEventToArgs.bind(null, socketOnVcxRtcMessage));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.signaling_message_peer, socketEventToArgs.bind(null, socketOnPeerMessage));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.publish_me, socketEventToArgs.bind(null, socketOnPublishMe));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.unpublish_me, socketEventToArgs.bind(null, socketOnUnpublishMe));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthAlert, socketEventToArgs.bind(null, socketOnBandwidthAlert));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthEvents, socketEventToArgs.bind(null, socketOnBandwidthEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onSelfBandwidthAlert, socketEventToArgs.bind(null, socketOnSelfBandwidthAlert));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onDataStream, socketEventToArgs.bind(null, socketOnDataStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onUpdateAttributeStream, socketEventToArgs.bind(null, socketOnUpdateAttributeStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream, socketEventToArgs.bind(null, socketOnRemoveStream));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, socketEventToArgs.bind(null, socketOnDisconnect));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.connection_failed, socketEventToArgs.bind(null, socketOnICEConnectionFailed));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.error, socketEventToArgs.bind(null, socketOnError));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveTrack, socketEventToArgs.bind(null, socketOnRemoveTrack));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_connected, socketEventToArgs.bind(null, userConnect));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_updated, socketEventToArgs.bind(null, userUpdate));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected, socketEventToArgs.bind(null, userDisConnect));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed, socketEventToArgs.bind(null, userSubcribe));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_unsubscribed, socketEventToArgs.bind(null, userUnSubcribe));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.floor_management_events, socketEventToArgs.bind(null, onFloorManagementEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.dial_state_events, socketEventToArgs.bind(null, onDialStateEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].UserEvent.user_awaited, socketEventToArgs.bind(null, onUserAwaited));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.data_stream_room, socketEventToArgs.bind(null, socketOnDataStreamToRoom));

        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.room_awaited, socketEventToArgs.bind(null, onRoomAwaited));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.room_connected, socketEventToArgs.bind(null, onRoomConnected));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.room_disconnected, socketEventToArgs.bind(null, onRoomDisconnected));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.room_record_on, socketEventToArgs.bind(null, onRoomRecordStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.room_record_off, socketEventToArgs.bind(null, onRoomRecordStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.change_layout, socketEventToArgs.bind(null, onChangeLayout));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.new_active_talker, socketEventToArgs.bind(null, onNewActiveTalker));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_audio, socketEventToArgs.bind(null, onHardMuteAudio));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_audio, socketEventToArgs.bind(null, onHardUnmuteAudio));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_video, socketEventToArgs.bind(null, onHardMuteVideo));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_video, socketEventToArgs.bind(null, onHardUnmuteVideo));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.auxilary_publish_events, socketEventToArgs.bind(null, onAuxilaryPublishEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.share_started, socketEventToArgs.bind(null, onShareStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.share_stopped, socketEventToArgs.bind(null, onShareStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.screen_share_override, socketEventToArgs.bind(null, onScreenShareOverride));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.stop_sharing, socketEventToArgs.bind(null, onStopSharing));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.update_layout, socketEventToArgs.bind(null, onUpdateLayout));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.share_state_events, socketEventToArgs.bind(null, onShareStateEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.custom_data_saved, socketEventToArgs.bind(null, onCustomDataSaved));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.custom_data_updated, socketEventToArgs.bind(null, onCustomDataUpdated));

        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.canvas_started, socketEventToArgs.bind(null, onCanvasStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.canvas_stopped, socketEventToArgs.bind(null, onCanvasStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.canvas_state_events, socketEventToArgs.bind(null, onCanvasStateEvents));

        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.generic_events, socketEventToArgs.bind(null, onGenericEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.user_role_changed, socketEventToArgs.bind(null, onUserRoleChangedEvent));

        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.switch_codec, socketEventToArgs.bind(null, onSwitchCodec));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.invite_breakout_room, socketEventToArgs.bind(null, onInviteBreakOutRoom));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.user_joined_breakout_room, socketEventToArgs.bind(null, onUserJoinedBreakOutRoom));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.user_left_breakout_room, socketEventToArgs.bind(null, onUserDisconnectedBreakOutRoom));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.breakout_room_destroyed, socketEventToArgs.bind(null, onBreakOutRoomDestroyed));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.transcription_events, socketEventToArgs.bind(null, onTranscriptionEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.analytics_events, socketEventToArgs.bind(null, onAnalyticsEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.meeting_summary_subscription_events, socketEventToArgs.bind(null, onMeetingSummarySubscriptionEvents));

        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].UserEvent.user_audio_muted, socketEventToArgs.bind(null, onUserAudioMuted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].UserEvent.user_audio_unmuted, socketEventToArgs.bind(null, onUserAudioUnmuted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].UserEvent.user_video_muted, socketEventToArgs.bind(null, onUserVideoMuted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].UserEvent.user_video_unmuted, socketEventToArgs.bind(null, onUserVideoUnmuted));

        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.room_management_events, socketEventToArgs.bind(null, onRoomManagementEvents));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute, socketEventToArgs.bind(null, onHardmuteOne));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute_room, socketEventToArgs.bind(null, onHardmuteRoom));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.hard_unmute_room, socketEventToArgs.bind(null, onHardUnmuteRoom));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onStatSubscription, socketEventToArgs.bind(null, socketOnStatSubscription));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onStreamingNotification, socketEventToArgs.bind(null, socketOnStreamingNotification));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onHlsStreamingNotification, socketEventToArgs.bind(null, socketOnHlsStreamingNotification));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onHlsStreamingNotificationToPublisher, socketEventToArgs.bind(null, socketOnHlsStreamingNotificationToPublisher));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onLiveRecordingNotification, socketEventToArgs.bind(null, socketOnLiveRecordingNotification));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingOn, socketEventToArgs.bind(null, onRoomLiveRecordStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingOff, socketEventToArgs.bind(null, onRoomLiveRecordStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingFailed, socketEventToArgs.bind(null, onRoomLiveRecordFailed));
        //Switched room changes
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.switched_room, socketEventToArgs.bind(null, onRoomSwitched));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_on, socketEventToArgs.bind(null, onRoomTranscriptionStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_off, socketEventToArgs.bind(null, onRoomTranscriptionStopped));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.self_transcription_on, socketEventToArgs.bind(null, onSelfTranscriptionStarted));
        socket.on(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].RoomEvent.self_transcription_off, socketEventToArgs.bind(null, onSelfTranscriptionStopped));
    } else {
        if (document.getElementById('WebrtcEverywherePluginId') === null) {
            that.installPlugin();
        }
        const plugin = document.getElementById('WebrtcEverywherePluginId');

        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream, (event) => {
            for (arg in event.data.args) {
                socketOnAddStream(event.data.args[arg]);
            }
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream, (event) => {
            for (arg in event.data.args) {
                socketOnRemoveStream(event.data.args[arg]);
            }
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting, (event) => {
            for (arg in event.data.args) {
                socketOnVcxRtcMessage(event.data.args[arg]);
            }
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.publish_me, (event) => {
            for (arg in event.data.args) {
                socketOnPublishMe(event.data.args[arg]);
            }
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_connected, (event) => {
            for (arg in event.data.args) { userConnect(event.data.args[arg]); }
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected, (event) => {
            for (arg in event.data.args) {
                userDisConnect(event.data.args[arg]);
            }
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed, (event) => {
            for (arg in event.data.args) {
                userSubcribe(event.data.args[arg]);
            }
        });
        plugin.addEventListener(__WEBPACK_IMPORTED_MODULE_9__vcxEventProperties__["a" /* default */].SocketEvent.user_unsubscribed, (event) => {
            for (arg in event.data.args) {
                userUnSubcribe(event.data.args[arg]);
            }
        });
    }
    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (Room);


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

const b64 = __webpack_require__(28);

function arrayToB64(array) {
  return b64
    .fromByteArray(array)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

function b64ToArray(str) {
  return b64.toByteArray(str + '==='.slice((str.length + 3) % 4));
}


function isFile(id) {
  return /^[0-9a-fA-F]{10,16}$/.test(id);
}

function copyToClipboard(str) {
  const aux = document.createElement('input');
  aux.setAttribute('value', str);
  aux.contentEditable = true;
  aux.readOnly = true;
  document.body.appendChild(aux);
  if (navigator.userAgent.match(/iphone|ipad|ipod/i)) {
    const range = document.createRange();
    range.selectNodeContents(aux);
    const sel = getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    aux.setSelectionRange(0, str.length);
  } else {
    aux.select();
  }
  const result = document.execCommand('copy');
  document.body.removeChild(aux);
  return result;
}

const LOCALIZE_NUMBERS = !!(
  typeof Intl === 'object' &&
  Intl &&
  typeof Intl.NumberFormat === 'function' &&
  typeof navigator === 'object'
);

const UNITS = ['bytes', 'kb', 'mb', 'gb'];
function bytes(num) {
  if (num < 1) {
    return '0B';
  }
  const exponent = Math.min(Math.floor(Math.log10(num) / 3), UNITS.length - 1);
  const n = Number(num / Math.pow(1024, exponent));
  const decimalDigits = Math.floor(n) === n ? 0 : 1;
  let nStr = n.toFixed(decimalDigits);
  if (LOCALIZE_NUMBERS) {
    try {
      nStr = n.toLocaleString(locale(), {
        minimumFractionDigits: decimalDigits,
        maximumFractionDigits: decimalDigits,
      });
    } catch (e) {
      // fall through
    }
  }
  return translate('fileSize', {
    num: nStr,
    units: translate(UNITS[exponent]),
  });
}

function percent(ratio) {
  if (LOCALIZE_NUMBERS) {
    try {
      return ratio.toLocaleString(locale(), { style: 'percent' });
    } catch (e) {
      // fall through
    }
  }
  return `${Math.floor(ratio * 100)}%`;
}

function number(n) {
  if (LOCALIZE_NUMBERS) {
    return n.toLocaleString(locale());
  }
  return n.toString();
}

function allowedCopy() {
  const support = !!document.queryCommandSupported;
  return support ? document.queryCommandSupported('copy') : false;
}

function delay(delay = 100) {
  return new Promise(resolve => setTimeout(resolve, delay));
}

function fadeOut(selector) {
  const classes = document.querySelector(selector).classList;
  classes.remove('effect--fadeIn');
  classes.add('effect--fadeOut');
  return delay(300);
}

function openLinksInNewTab(links, should = true) {
  links = links || Array.from(document.querySelectorAll('a:not([target])'));
  if (should) {
    links.forEach((l) => {
      l.setAttribute('target', '_blank');
      l.setAttribute('rel', 'noopener noreferrer');
    });
  } else {
    links.forEach((l) => {
      l.removeAttribute('target');
      l.removeAttribute('rel');
    });
  }
  return links;
}

function browserName() {
  try {
    if (/firefox/i.test(navigator.userAgent)) {
      return 'firefox';
    }
    if (/edge/i.test(navigator.userAgent)) {
      return 'edge';
    }
    if (/trident/i.test(navigator.userAgent)) {
      return 'ie';
    }
    if (/chrome/i.test(navigator.userAgent)) {
      return 'chrome';
    }
    if (/safari/i.test(navigator.userAgent)) {
      return 'safari';
    }
    if (/send android/i.test(navigator.userAgent)) {
      return 'android-app';
    }
    return 'other';
  } catch (e) {
    return 'unknown';
  }
}
async function streamToArrayBuffer(stream, size) {
  const reader = stream.getReader();
  let state = await reader.read();

  if (size) {
    const result = new Uint8Array(size);
    let offset = 0;
    while (!state.done) {
      result.set(state.value, offset);
      offset += state.value.length;
      state = await reader.read();
    }
    return result.buffer;
  }

  const parts = [];
  let len = 0;
  while (!state.done) {
    parts.push(state.value);
    len += state.value.length;
    state = await reader.read();
  }
  let offset = 0;
  const result = new Uint8Array(len);
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result.buffer;
}

function list(items, ulStyle = '', liStyle = '') {
  const lis = items.map(i =>
    html`
        <li class="${liStyle}">${i}</li>
      `);
  return html`
    <ul class="${ulStyle}">
      ${lis}
    </ul>
  `;
}

function secondsToL10nId(seconds) {
  if (seconds < 3600) {
    return { id: 'timespanMinutes', num: Math.floor(seconds / 60) };
  } else if (seconds < 86400) {
    return { id: 'timespanHours', num: Math.floor(seconds / 3600) };
  }
  return { id: 'timespanDays', num: Math.floor(seconds / 86400) };
}

function timeLeft(milliseconds) {
  if (milliseconds < 1) {
    return { id: 'linkExpiredAlt' };
  }
  const minutes = Math.floor(milliseconds / 1000 / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (days >= 1) {
    return {
      id: 'expiresDaysHoursMinutes',
      days,
      hours: hours % 24,
      minutes: minutes % 60,
    };
  }
  if (hours >= 1) {
    return {
      id: 'expiresHoursMinutes',
      hours,
      minutes: minutes % 60,
    };
  } else if (hours === 0) {
    if (minutes === 0) {
      return { id: 'expiresMinutes', minutes: '< 1' };
    }
    return { id: 'expiresMinutes', minutes };
  }
  return null;
}

function platform() {
  if (typeof Android === 'object') {
    return 'android';
  }
  return 'web';
}

const ECE_RECORD_SIZE = 1024 * 64;
const TAG_LENGTH = 16;
function encryptedSize(size, rs = ECE_RECORD_SIZE, tagLength = TAG_LENGTH) {
  const chunk_meta = tagLength + 1; // Chunk metadata, tag and delimiter
  return 21 + size + chunk_meta * Math.ceil(size / (rs - chunk_meta));
}

let translate = function () {
  throw new Error('uninitialized translate function. call setTranslate first');
};
function setTranslate(t) {
  translate = t;
}

module.exports = {
  fadeOut,
  delay,
  allowedCopy,
  bytes,
  percent,
  number,
  copyToClipboard,
  arrayToB64,
  b64ToArray,
  isFile,
  openLinksInNewTab,
  browserName,
  streamToArrayBuffer,
  list,
  secondsToL10nId,
  timeLeft,
  platform,
  encryptedSize,
  setTranslate,
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
//'use strict';
/* exported arrayAverage, arrayMax, arrayMin, enumerateStats */

// array<function> returns the average (down to nearest int), max and min of
// an int array.
let currentTest;
function arrayAverage(array) {
  const cnt = array.length;
  let tot = 0;
  for (let i = 0; i < cnt; i++) {
    tot += array[i];
  }
  return Math.floor(tot / cnt);
}

function arrayMax(array) {
  if (array.length === 0) {
    return NaN;
  }
  return Math.max(...array);
}

function arrayMin(array) {
  if (array.length === 0) {
    return NaN;
  }
  return Math.min(...array);
}
function setTestProgress(value) {
  currentTest.setProgress(value);
}
function setActiveTest(test) {
  currentTest = test;
}
// Enumerates the new standard compliant stats using local and remote track ids.
function enumerateStats(stats, localTrackIds, remoteTrackIds) {
  // Create an object structure with all the needed stats and types that we care
  // about. This allows to map the getStats stats to other stats names.
  const statsObject = {
    audio: {
      local: {
        audioLevel: 0.0,
        bytesSent: 0,
        clockRate: 0,
        codecId: '',
        mimeType: '',
        packetsSent: 0,
        payloadType: 0,
        timestamp: 0.0,
        trackId: '',
        transportId: '',
      },
      remote: {
        audioLevel: 0.0,
        bytesReceived: 0,
        clockRate: 0,
        codecId: '',
        fractionLost: 0,
        jitter: 0,
        mimeType: '',
        packetsLost: -1,
        packetsReceived: 0,
        payloadType: 0,
        timestamp: 0.0,
        trackId: '',
        transportId: '',
      },
    },
    video: {
      local: {
        bytesSent: 0,
        clockRate: 0,
        codecId: '',
        firCount: 0,
        framesEncoded: 0,
        frameHeight: 0,
        framesSent: -1,
        frameWidth: 0,
        nackCount: 0,
        packetsSent: -1,
        payloadType: 0,
        pliCount: 0,
        qpSum: 0,
        timestamp: 0.0,
        trackId: '',
        transportId: '',
      },
      remote: {
        bytesReceived: -1,
        clockRate: 0,
        codecId: '',
        firCount: -1,
        fractionLost: 0,
        frameHeight: 0,
        framesDecoded: 0,
        framesDropped: 0,
        framesReceived: 0,
        frameWidth: 0,
        nackCount: -1,
        packetsLost: -1,
        packetsReceived: 0,
        payloadType: 0,
        pliCount: -1,
        qpSum: 0,
        timestamp: 0.0,
        trackId: '',
        transportId: '',
      },
    },
    connection: {
      availableOutgoingBitrate: 0,
      bytesReceived: 0,
      bytesSent: 0,
      consentRequestsSent: 0,
      currentRoundTripTime: 0.0,
      localCandidateId: '',
      localCandidateType: '',
      localIp: '',
      localPort: 0,
      localPriority: 0,
      localProtocol: '',
      remoteCandidateId: '',
      remoteCandidateType: '',
      remoteIp: '',
      remotePort: 0,
      remotePriority: 0,
      remoteProtocol: '',
      requestsReceived: 0,
      requestsSent: 0,
      responsesReceived: 0,
      responsesSent: 0,
      timestamp: 0.0,
      totalRoundTripTime: 0.0,
    },
  };

  // Need to find the codec, local and remote ID's first.
  if (stats) {
    stats.forEach(((report, stat) => {
      switch (report.type) {
        case 'outbound-rtp':
          if (report.hasOwnProperty('trackId')) {
            if (report.trackId.indexOf(localTrackIds.audio) !== 1 &
                localTrackIds.audio !== '') {
              statsObject.audio.local.bytesSent = report.bytesSent;
              statsObject.audio.local.codecId = report.codecId;
              statsObject.audio.local.packetsSent = report.packetsSent;
              statsObject.audio.local.timestamp = report.timestamp;
              statsObject.audio.local.trackId = report.trackId;
              statsObject.audio.local.transportId = report.transportId;
            } else if (report.trackId.indexOf(localTrackIds.video) !== 1 &
                localTrackIds.video !== '') {
              statsObject.video.local.bytesSent = report.bytesSent;
              statsObject.video.local.codecId = report.codecId;
              statsObject.video.local.firCount = report.firCount;
              statsObject.video.local.framesEncoded = report.framesEncoded;
              statsObject.video.local.framesSent = report.framesSent;
              statsObject.video.local.packetsSent = report.packetsSent;
              statsObject.video.local.pliCount = report.pliCount;
              statsObject.video.local.qpSum = report.qpSum;
              statsObject.video.local.timestamp = report.timestamp;
              statsObject.video.local.trackId = report.trackId;
              statsObject.video.local.transportId = report.transportId;
            }
          }
          break;
        case 'inbound-rtp':
          if (report.hasOwnProperty('trackId')) {
            if (report.trackId.indexOf(remoteTrackIds.audio) !== 1 &
                remoteTrackIds.audio !== '') {
              statsObject.audio.remote.bytesReceived = report.bytesReceived;
              statsObject.audio.remote.codecId = report.codecId;
              statsObject.audio.remote.fractionLost = report.fractionLost;
              statsObject.audio.remote.jitter = report.jitter;
              statsObject.audio.remote.packetsLost = report.packetsLost;
              statsObject.audio.remote.packetsReceived = report.packetsReceived;
              statsObject.audio.remote.timestamp = report.timestamp;
              statsObject.audio.remote.trackId = report.trackId;
              statsObject.audio.remote.transportId = report.transportId;
            }
            if (report.trackId.indexOf(remoteTrackIds.video) !== 1 &
                remoteTrackIds.video !== '') {
              statsObject.video.remote.bytesReceived = report.bytesReceived;
              statsObject.video.remote.codecId = report.codecId;
              statsObject.video.remote.firCount = report.firCount;
              statsObject.video.remote.fractionLost = report.fractionLost;
              statsObject.video.remote.nackCount = report.nackCount;
              statsObject.video.remote.packetsLost = report.packetsLost;
              statsObject.video.remote.packetsReceived = report.packetsReceived;
              statsObject.video.remote.pliCount = report.pliCount;
              statsObject.video.remote.qpSum = report.qpSum;
              statsObject.video.remote.timestamp = report.timestamp;
              statsObject.video.remote.trackId = report.trackId;
              statsObject.video.remote.transportId = report.transportId;
            }
          }
          break;
        case 'candidate-pair':
          if (report.hasOwnProperty('availableOutgoingBitrate')) {
            statsObject.connection.availableOutgoingBitrate =
                report.availableOutgoingBitrate;
            statsObject.connection.bytesReceived = report.bytesReceived;
            statsObject.connection.bytesSent = report.bytesSent;
            statsObject.connection.consentRequestsSent =
                report.consentRequestsSent;
            statsObject.connection.currentRoundTripTime =
                report.currentRoundTripTime;
            statsObject.connection.localCandidateId = report.localCandidateId;
            statsObject.connection.remoteCandidateId = report.remoteCandidateId;
            statsObject.connection.requestsReceived = report.requestsReceived;
            statsObject.connection.requestsSent = report.requestsSent;
            statsObject.connection.responsesReceived = report.responsesReceived;
            statsObject.connection.responsesSent = report.responsesSent;
            statsObject.connection.timestamp = report.timestamp;
            statsObject.connection.totalRoundTripTime =
               report.totalRoundTripTime;
          }
          break;
        default:
      }
    }).bind());

    // Using the codec, local and remote candidate ID's to find the rest of the
    // relevant stats.
    stats.forEach(((report) => {
      switch (report.type) {
        case 'track':
          if (report.hasOwnProperty('trackIdentifier')) {
            if (report.trackIdentifier.indexOf(localTrackIds.video) !== 1 &
                localTrackIds.video !== '') {
              statsObject.video.local.frameHeight = report.frameHeight;
              statsObject.video.local.framesSent = report.framesSent;
              statsObject.video.local.frameWidth = report.frameWidth;
            }
            if (report.trackIdentifier.indexOf(remoteTrackIds.video) !== 1 &
                remoteTrackIds.video !== '') {
              statsObject.video.remote.frameHeight = report.frameHeight;
              statsObject.video.remote.framesDecoded = report.framesDecoded;
              statsObject.video.remote.framesDropped = report.framesDropped;
              statsObject.video.remote.framesReceived = report.framesReceived;
              statsObject.video.remote.frameWidth = report.frameWidth;
            }
            if (report.trackIdentifier.indexOf(localTrackIds.audio) !== 1 &
                localTrackIds.audio !== '') {
              statsObject.audio.local.audioLevel = report.audioLevel;
            }
            if (report.trackIdentifier.indexOf(remoteTrackIds.audio) !== 1 &
                remoteTrackIds.audio !== '') {
              statsObject.audio.remote.audioLevel = report.audioLevel;
            }
          }
          break;
        case 'codec':
          if (report.hasOwnProperty('id')) {
            if (report.id.indexOf(statsObject.audio.local.codecId) !== 1 &
                localTrackIds.audio !== '') {
              statsObject.audio.local.clockRate = report.clockRate;
              statsObject.audio.local.mimeType = report.mimeType;
              statsObject.audio.local.payloadType = report.payloadType;
            }
            if (report.id.indexOf(statsObject.audio.remote.codecId) !== 1 &
                remoteTrackIds.audio !== '') {
              statsObject.audio.remote.clockRate = report.clockRate;
              statsObject.audio.remote.mimeType = report.mimeType;
              statsObject.audio.remote.payloadType = report.payloadType;
            }
            if (report.id.indexOf(statsObject.video.local.codecId) !== 1 &
                localTrackIds.video !== '') {
              statsObject.video.local.clockRate = report.clockRate;
              statsObject.video.local.mimeType = report.mimeType;
              statsObject.video.local.payloadType = report.payloadType;
            }
            if (report.id.indexOf(statsObject.video.remote.codecId) !== 1 &
                remoteTrackIds.video !== '') {
              statsObject.video.remote.clockRate = report.clockRate;
              statsObject.video.remote.mimeType = report.mimeType;
              statsObject.video.remote.payloadType = report.payloadType;
            }
          }
          break;
        case 'local-candidate':
          if (report.hasOwnProperty('id')) {
            if (report.id.indexOf(statsObject.connection.localCandidateId) !== -1) {
              statsObject.connection.localIp = report.ip;
              statsObject.connection.localPort = report.port;
              statsObject.connection.localPriority = report.priority;
              statsObject.connection.localProtocol = report.protocol;
              statsObject.connection.localType = report.candidateType;
            }
          }
          break;
        case 'remote-candidate':
          if (report.hasOwnProperty('id')) {
            if (report.id.indexOf(statsObject.connection.remoteCandidateId) !== -1) {
              statsObject.connection.remoteIp = report.ip;
              statsObject.connection.remotePort = report.port;
              statsObject.connection.remotePriority = report.priority;
              statsObject.connection.remoteProtocol = report.protocol;
              statsObject.connection.remoteType = report.candidateType;
            }
          }
          break;
        default:
      }
    }).bind());
  }
  return statsObject;
}

function enumerateStatsFirefox(stats) {
  // Create an object structure with all the needed stats and types that we care
  // about. This allows to map the getStats stats to other stats names.
  const statsObject = {
    audio: {
      local: {
        bytesSent: 0,
        packetsSent: 0,
      },
      remote: {
        bytesReceived: -1,
        packetsReceived: 0,
        packetsLost: -1,
        jitter: 0,
        roundTripTime: 0,
        timestamp: 0,
      },
    },
    video: {
      local: {
        bytesSent: 0,
        packetsSent: -1,
        bitrateMean: 0,
        bitrateStdDev: 0,
        qpSum: 0,
      },
      remote: {
        bytesReceived: -1,
        packetsReceived: 0,
        packetsLost: -1,
        bitrateMean: 0,
        bitrateStdDev: 0,
        roundTripTime: 0,
        timestamp: 0,
      },
    },
    connection: {
      bytesSent: 0,
      bytesReceived: 0,
      timestamp: 0
    },
  };

  // Need to find the codec, local and remote ID's first.
  if (stats) {
    stats.forEach(((report, stat) => {
      //console.log('report', JSON.stringify(report));
      switch (report.type) {
        case 'outbound-rtp':
          if (report.mediaType == 'audio') {

            statsObject.audio.local.bytesSent = report.bytesSent;
            statsObject.audio.local.packetsSent = report.packetsSent;
          } else if (report.mediaType == 'video') {
            statsObject.video.local.bytesSent = report.bytesSent;
            statsObject.video.local.packetsSent = report.packetsSent;
            statsObject.video.local.bitrateMean = report.bitrateMean;
            statsObject.video.local.bitrateStdDev = report.bitrateStdDev;
            statsObject.video.local.qpSum = report.qpSum;
          }
        break;
        case 'remote-outbound-rtp':
          if (report.mediaType == 'audio') {

            statsObject.audio.local.bytesSent = report.bytesSent;
            statsObject.audio.local.packetsSent = report.packetsSent;
          } else if (report.mediaType == 'video') {
            statsObject.video.local.bytesSent = report.bytesSent;
            statsObject.video.local.packetsSent = report.packetsSent;
          }
        break;
        case 'inbound-rtp':
          if (report.mediaType == 'audio') {

            statsObject.audio.remote.bytesReceived = report.bytesReceived;
            statsObject.audio.remote.packetsLost = report.packetsLost;
            statsObject.audio.remote.packetsReceived = report.packetsReceived;
            statsObject.audio.remote.jitter = report.jitter;
          } else if (report.mediaType == 'video') {
            statsObject.video.remote.bytesReceived = report.bytesReceived;
            statsObject.video.remote.packetsLost = report.packetsLost;
            statsObject.video.remote.packetsReceived = report.packetsReceived;
            statsObject.video.remote.bitrateMean = report.bitrateMean;
            statsObject.video.remote.bitrateStdDev = report.bitrateStdDev;
            statsObject.video.remote.qpSum = report.qpSum;
          }
          break;
          case 'remote-inbound-rtp':
            if (report.mediaType == 'audio') {

              statsObject.audio.remote.bytesReceived = report.bytesReceived;
              statsObject.audio.remote.packetsLost = report.packetsLost;
              statsObject.audio.remote.packetsReceived = report.packetsReceived;
              statsObject.audio.remote.jitter = report.jitter;
              statsObject.audio.remote.roundTripTime = report.roundTripTime;
              statsObject.audio.remote.timestamp = report.timestamp;
            } else if (report.mediaType == 'video') {
              statsObject.video.remote.bytesReceived = report.bytesReceived;
              statsObject.video.remote.packetsLost = report.packetsLost;
              statsObject.video.remote.packetsReceived = report.packetsReceived;
              statsObject.video.remote.roundTripTime = report.roundTripTime;
              statsObject.video.remote.timestamp = report.timestamp;
            }
            break;
          case 'candidate-pair':
            statsObject.connection.bytesReceived = report.bytesReceived;
            statsObject.connection.bytesSent = report.bytesSent;
            statsObject.connection.timestamp = report.timestamp;
            break;
        default:
      }
    }).bind());
  }
  return statsObject;
}

function doGetUserMedia(constraints, onSuccess, onFail) {
  try {
    navigator.mediaDevices.getUserMedia(constraints)
        .then((stream) => {
          stream.onremovetrack = function () {
          };
          onSuccess(stream);
        })
        .catch((error) => {
          onFail(error);
        });
  } catch (e) {
    onFail(e.message);
  }
}
function appendSourceId(id, type, constraints) {
  if (id === '') {
    return;
  }
  if (constraints[type] === true) {
    constraints[type] = { optional: [{ sourceId: id }] };
  } else if (typeof constraints[type] === 'object') {
    if (typeof constraints[type].optional === 'undefined') {
      constraints[type].optional = [];
    }
    constraints[type].optional.push({ sourceId: id });
  }
}
function setTimeoutWithProgressBar(timeoutCallback, timeoutMs) {
  const start = window.performance.now();
  const updateProgressBar = setInterval(() => {
    const now = window.performance.now();
    setTestProgress((now - start) * 100 / timeoutMs);
  }, 100);

  const timeoutTask = function () {
    clearInterval(updateProgressBar);
    setTestProgress(100);
    timeoutCallback();
  };
  const timer = setTimeout(timeoutTask, timeoutMs);
  const finishProgressBar = function () {
    clearTimeout(timer);
    timeoutTask();
  };
  return finishProgressBar;
}

function StatisticsAggregate(rampUpThreshold) {
  this.startTime_ = 0;
  this.sum_ = 0;
  this.count_ = 0;
  this.max_ = 0;
  this.rampUpThreshold_ = rampUpThreshold;
  this.rampUpTime_ = Infinity;
}

StatisticsAggregate.prototype = {
  add(time, datapoint) {
    if (this.startTime_ === 0) {
      this.startTime_ = time;
    }
    this.sum_ += datapoint;
    this.max_ = Math.max(this.max_, datapoint);
    if (this.rampUpTime_ === Infinity &&
        datapoint > this.rampUpThreshold_) {
      this.rampUpTime_ = time;
    }
    this.count_ += 1;
  },

  getAverage() {
    if (this.count_ === 0) {
      return 0;
    }
    return Math.round(this.sum_ / this.count_);
  },

  getMax() {
    return this.max_;
  },

  getRampUpTime() {
    return Math.round(this.rampUpTime_ - this.startTime_);
  },
};

module.exports = {
 arrayAverage, arrayMax, arrayMin, enumerateStats, doGetUserMedia, setTimeoutWithProgressBar,
 setActiveTest, appendSourceId, StatisticsAggregate, enumerateStatsFirefox
};


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__views_AudioPlayer__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__views_VideoPlayer__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Pair__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_ErrorHandler__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__customErrors__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Localization__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__customEvents__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__EventLogger__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Common_config_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11__Common_config_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__noiseAnalysis_noiseEffects__ = __webpack_require__(51);
/* Import Global Libraries */














const VOICE_DETECTION_LEVEL = 0.9;
const VOICE_AVG_THRESHOLD = 0.6;
const PROCESS_AUDIO_DETECTION_TIMEOUT = 700;
//const SPEAKING_WHILE_MUTE_EVENT_SUPRESS_TIME_SECS = 5000;

const NOISE_DETECTION_LEVEL = 0.2;
const AUDIO_LEVEL_SCORE_TRIGGER = 0.020;
const PROCESS_TIME_FRAME_SPAN_MS = 1500;
const NOISE_AVG_THRESHOLD = 0.2;
const NOISE_AUDIO_LEVEL_THRESHOLD = 0.040;

const ENABLE_TALKING_WHILE_MUTE = true;
const ENABLE_NOISE_DETECTION = true;

if(__WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.noise_analysis == true)
var noiseEffects = new __WEBPACK_IMPORTED_MODULE_12__noiseAnalysis_noiseEffects__["a" /* default */]();
/*
 * Class: Stream
 * Description: This class represents a stream, either a Published Local Stream or Subscribed Remote Stream.
 *              This Class will handle WebRTC stream, identify it and draw it in Player.
 * Author: Subrat
 * Las Edit Date: 27/11/2017
 * Relase Version: 1.0
 */


const Stream = (altConnection, specInput) => {
  if (!__WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.is_supported()) { console.log('Webrtc not supported'); return undefined; }
  const spec = specInput;
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["c" /* EventDispatcher */])(spec);
  that.config = specInput;
  that.stream = spec.stream; // Media Stream
  that.url = spec.url; // URL - if a stream is initiated from a URL
  that.recording = spec.recording; // If a stream is initiated from a Recorded File.
  that.recordingId = undefined;
  that.room = undefined; // Gets room info when its published in a Room.
  that.showing = false; // If the Stream is being played in any DOM Object.
  that.local = false; // If the Stream is a local stream.
  that.video = spec.video; // If the stream has Video Track. Or, if a local stream has access to Video Device
  that.audio = spec.audio; // If the stream has Audio Track. Or, if a local stream has access to Mic Device
  that.screen = spec.screen; // If the stream has Screen Track. Or, if a local stream has access to Screen
  that.videoSize = spec.videoSize; // VideoSize to be defined in 4 element array [minWidth, minHeight, maxWidth, maxHeight]
  that.videoFrameRate = spec.videoFrameRate; // Video Frame Rate - Initiated or Opted, defined in 2 element array [min, max]
  that.extensionId = spec.extensionId; // Chrome Extension ID for Screen Share App
  that.desktopStreamId = spec.desktopStreamId; // Stream ID for Screen Share
  that.recordingId = spec.recordingId; // Archived File ID of recorded stream. Used for playback
  that.clientId = spec.clientId;
  that.videoMutedDueToBw = false; // If video track has been muted
  that.hardAudioMuted = false;
  that.hardVideoMuted = false;
  that.softVideoMuted = false;
  that.selfMuteVideo = false;
  that.selfMuteAudio = false;
  that.ATVideoMuted = false;
  that.selfPausedVideo = false;
  that.selfPausedAudio = false;
  that.audioOnlyModeEnabled = false;
  that.processingVideoMute = false;
  that.attributes = spec.attributes; // Additional Information about Stream, defined as {var: value, var:value}
  that.Connection = altConnection === undefined ? __WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */] : altConnection;
  that.playerDivs = [];
  that.canvas = spec.canvas;
  that.transactions = new Map();
  that.audioStream = spec.audioStream;
  that.audioStreamClone = undefined ;
  that.videoStream = spec.videoStream;
  that.recordedBlobs = [];
  that.negotiatedMedia = { audio: spec.audio != undefined, video: spec.video != undefined };
  that.state = 'idle';
  const pendingUserReqs = {};
  let audioMuted = false; // If audio track has been muted
  let videoMuted = false; // If video track has been muted
  let localVideoOn = false;
  that.inputMediaSource = {audio:{},video:{user:null, self:null, selected: 'self'}};
  if (that.config.videoMuted == undefined ) that.config.videoMuted = false;
  if (that.config.audioMuted == undefined ) that.config.audioMuted = false;
  that.abwdEnabled = true;
  that.abwdNotification = 'sdk';
  that.abwdLanguage = 'en';
  let currentMediaType = 'none';
  let currentRemoteClientId = 'none';
  let currentImageDisplay = false;
  let currentVideoMuteReason = 'none';
  let currentActiveTalkerList;
  that.maxVideoBwKbpsReqByUser = 0;
  that.maxVideoBwKbpsReqByServer = 0;
  that.maxVideoBwKbpsSet = 0;
  that.reconnect = false;
  that.reconnectAttempt = 0;
  that.reconnectsTotal= 0;
  that.pcmInputBuf =undefined;
  that.pcmOutputBuf =undefined;
  that.pcmInputIndex = undefined;
  that.rnn = undefined;
  that.bufferResidue = new Float32Array([]);
  that.scoreArrayVoice = [];
  that.scoreArrayNoise = [];
  that.audioLevelArray = [];
  that.processing_voice_while_mute = false;
  that.processing_noise_detection = false;

  //that.lastNoiseEventTime = new Date();
  that.audioContext = undefined;

  const mediaConfig = {
    videoFps: { set: 0, max: { user: 0, server: 0 }, min: { user: 0, server: 0 } },
    videoBw: { set: 0, max: { user: 0, server: 0 }, min: { user: 0, server: 0 } },
  };
  // Verify if video size specified in the specs is legible
  /*if (that.videoSize !== undefined && (!(that.videoSize instanceof Array) || that.videoSize.length !== 4)) {
    throw Error('Error! Invalid Video Size');
  }*/

  if (spec.local === undefined || spec.local === true) {
    that.local = true;
  } else {
    audioMuted = videoMuted = true; //remote streams set as false
  }

  that.isAudioMuted = () => audioMuted;
  that.isVideoMuted = () => videoMuted || that.config.videoMuted;
  // ************************************
  // Public function: getID()
  // It returns Unique Stream ID of Published and Subscribed Streams.
  // ************************************

  that.setID = (id) => {
    spec.streamID  = id;
    if (id && that.player) {
      that.player.streamUpdated(id);
    }
  }
  that.getID = () => {
    let id;
    // An initiated local stream will not have ID unless its published.
    if (that.local && !spec.streamID) {
      id = 'local'; // Inititing ID with a String Constant "Local"
    } else {
      id = spec.streamID;
    }
    return id;
  };


  // ************************************
  // Public function: getAttributes()
  // It returns attributes of the stream
  // ************************************

  that.getAttributes = () => spec.attributes;


  // ************************************
  // Public function: setAttributes()
  // It changes local & published stream attribute in room
  // ************************************

  that.setAttributes = (attrs) => {
    if (that.local) {
      that.emit(Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'internal-set-attributes', stream: that, attrs }));
      return;
    }
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Error! Stream Object is not published. Failed to update attributes.');
  };


  // ************************************
  // Public function: updateLocalAttributes()
  // It changes local attributes of local or subscribed streams. Changes not reflected in Room
  // ************************************

  that.updateLocalAttributes = (attrs) => {
    spec.attributes = attrs;
  };


  // ************************************
  // Public function: ifAudio()
  // It returns if the Stream has Audio Track
  // ************************************

  that.ifAudio = () => {
    if (spec.audio !== false && spec.audio !== undefined) {
      return true;
    }

    return false;
  };


  // ************************************
  // Public function: ifVideo()
  // It returns if the Stream has Video Track
  // ************************************

  that.ifVideo = () => {
    if (spec.video !== false && spec.video !== undefined) {
      return true;
    }

    return false;
  };


  // ************************************
  // Public function: ifData()
  // It returns if the Stream has Data Track
  // ************************************

  that.ifData = () => {
    if (spec.data !== false && spec.data !== undefined) {
      return true;
    }

    return false;
  };


  // ************************************
  // Public function: ifScreen()
  // It returns if the Stream has Screen Share Track
  // ************************************

  that.ifScreen = () => spec.screen;


  // ************************************
  // Public function: ifMedia()
  // It returns if the Stream has either  Audio track,  Video track or Screen Track
  // ************************************

  that.ifMedia = () => {
    if (spec.audio !== false && spec.audio !== undefined) {
      return true;
    } else if (spec.video !== false && spec.video !== undefined) {
      return true;
    } else if (spec.screen !== false) {
      return true;
    }

    return false;
  };


  // ************************************
  // Public function: ifExternal()
  // It returns if the Stream Video Track is created from URL or a Recorded File
  // ************************************

  that.ifExternal = () => {
    if (that.url !== undefined || that.recording !== undefined) {
      return true;
    }

    return false;
  };


  that.ifCanvas = () => spec.canvas;

  // ************************************
  // Public function: sendData()
  // Sends plain text or mime encoded data.
  // This function will further evolve by changing parameter and Stream-Event to handle Public/Pvt Messages
  // ************************************

  that.sendData = (msg) => {
    if (that.local && that.ifData()) {
      that.emit(Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'internal-send-data', stream: that, msg }));
      return;
    }
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Error! Stream Object is not published. Failed to send data.');
    __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_send_data_failed, { error: 'Error! Stream Object is not published. Failed to send data.' });
  };


  that.handleMediaDeviceChangeNotify = (id) => {
    let id2Set = (id != undefined) ? (id +"_handleMediaDeviceChangeNotify") : 'stream_handleMediaDeviceChangeNotify';
    let id2Reset = (id2Set != 'stream_handleMediaDeviceChangeNotify') ? 'stream_handleMediaDeviceChangeNotify' : false;
    that.Connection.mediaDeviceUpdate(id2Reset, {mic:true, cam:true, speaker:true}, id2Set, (devices) => {
    let currentDevices = devices.current, addedDevices = devices.added, removedDevices = devices.removed;
      const selectDevice2Switch = (currentDevices, removedDevices, addedDevices,
                                   deviceSetParams, deviceConfigParams, trackActive) => {
        let foundSetDevice = false, foundConfigDevice = false, switchDeviceId;

        let deviceIdSet = typeof deviceSetParams == 'object' ? deviceSetParams.deviceId.exact: deviceSetParams.deviceId;
        let groupIdSet = deviceSetParams.groupId;
        let deviceIdConfig = typeof deviceConfigParams == 'object' ?
                                      deviceConfigParams.deviceId.exact: deviceConfigParams.deviceId;
        let groupIdConfig = deviceConfigParams.groupId;
        /*console.log(" selectDevice2Switch() currentDevices: " + JSON.stringify(currentDevices) + " addedDevices: " +
                      JSON.stringify(addedDevices) +
                      " removedDevices: " +  JSON.stringify(removedDevices) +
                      " deviceSetParams: " + JSON.stringify(deviceSetParams) + " deviceConfigParams: " + JSON.stringify(deviceConfigParams));*/
        for (const indx in removedDevices) {
          if ((deviceIdSet == 'default' ||  removedDevices[indx].deviceId == deviceIdSet) &&
              removedDevices[indx].groupId == groupIdSet)
            foundSetDevice = false;
          if ((deviceIdConfig == 'default' || removedDevices[indx].deviceId == deviceIdConfig) &&
              removedDevices[indx].groupId == groupIdConfig)
            foundConfigDevice = false;
        }
        for (const indx in currentDevices) {
          if ((deviceIdSet == 'default' || currentDevices[indx].deviceId == deviceIdSet) &&
              currentDevices[indx].groupId == groupIdSet)
            foundSetDevice = true;
          if ((deviceIdConfig == 'default' || currentDevices[indx].deviceId == deviceIdConfig) &&
              currentDevices[indx].groupId == groupIdConfig)
            foundConfigDevice = true;
        }
        if (!foundSetDevice || !foundConfigDevice){
          for (const indx in addedDevices) {
            if ((deviceIdSet == 'default' || addedDevices[indx].deviceId == deviceIdSet) &&
                addedDevices[indx].groupId == groupIdSet)
              foundSetDevice = true;
            if ((deviceIdConfig == 'default' || addedDevices[indx].deviceId == deviceIdConfig) &&
                addedDevices[indx].groupId == groupIdConfig)
              foundConfigDevice = true;
          }
        }
        //console.log ("foundConfigDevice: " + foundConfigDevice + " foundSetDevice: " + foundSetDevice +
                    // " deviceIdSet: "+ deviceIdSet + " deviceIdConfig: " + deviceIdConfig + " grpid set: " + groupIdSet + " grpid config: " + groupIdConfig + " addedDevices.length: " +addedDevices.length + " currentDevices.length: " +  currentDevices.length);
        if ((deviceIdSet != deviceIdConfig || groupIdSet != groupIdConfig || !trackActive) && foundConfigDevice){
          return deviceIdConfig;
        }
        if (!foundSetDevice){
          if (addedDevices.length)
            return addedDevices[0].deviceId;
          if (currentDevices.length){
            return currentDevices[0].deviceId;
          }
        }
        return ;
      };
      if (spec.params){
        let camId2Switch = null , micId2Switch = null;
        if(spec.params.set.video && that.videoStream){
          let trackActive = false;
          that.videoStream.getVideoTracks().forEach((track) => {if (track.readyState != 'ended') trackActive=true });
          camId2Switch = selectDevice2Switch (currentDevices.cam, removedDevices.cam, addedDevices.cam,
                                                spec.params.set.video, spec.params.config.video, trackActive);
        }else{
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error ("spec.params.set.video not defined");
        }
        console.log ("handleMediaDeviceChangeNotify() pec.params.set.audio: " + spec.params.set.audio + "that.audioStream: " + that.audioStream);
        if (spec.params.set.audio && that.audioStream){
          let trackActive = false;
          that.audioStream.getAudioTracks().forEach((track) => {if (track.readyState != 'ended') trackActive=true });
          micId2Switch = selectDevice2Switch (currentDevices.mic, removedDevices.mic, addedDevices.mic,
                                                spec.params.set.audio, spec.params.config.audio, trackActive);
        }else {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error ("spec.params.set.audio not defined");
        }
        let selectedMicId, selectedCam;
        if (micId2Switch != undefined){
          if (!that.selfMuteAudio &&!that.hardAudioMuted) selectedMicId = micId2Switch;
          that.selectedMicId = micId2Switch;
        }else {
            that.selectedMicId = spec.params.set.audio.deviceId;
        }
        if (camId2Switch != undefined){
            if (!that.selfMuteVideo &&!that.hardVideoMuted) selectedCam = {deviceId : camId2Switch};
            that.selectedCam = {deviceId : camId2Switch};
        }else {
          let deviceIdSet = typeof spec.params.set.video.deviceId == 'object' ?
                            spec.params.set.video.deviceId.exact: spec.params.set.video.deviceId;
            that.selectedCam = { deviceId : deviceIdSet};
        }
        if (selectedCam != undefined || selectedMicId != undefined){
          setMediaDevicesTrack(that, selectedMicId , selectedCam, true, (status) => {
              if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) {
                let evntDetails = {};
                if (selectedCam != undefined) {
                  attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
                  evntDetails.video = {deviceId : selectedCam.deviceId};
                }
                if (selectedMicId != undefined){
                  evntDetails.audio = {deviceId :selectedMicId};
                }
                const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-device-updated', evntDetails});
                that.dispatchEvent(streamEvent);
              } else {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error ("setMediaDevicesTrack() returned failure : " + JSON.stringify(status));
                if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1145 && __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile'){
                  if (that.room !== undefined) {
                    that.room.onMediaDeviceStateChanged(that,{type :'mic', state: 'inactive', error:status});
                  }
                }
              }
          });
        }
      }else {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error("spec.params not defined");
      }
    });
  }
  const checkPopulateVideoResolution = (videoOpt) => {
    if (__WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type != 'mobile') {
      videoOpt.width = {}; videoOpt.height = {};
      if (that.videoSize !== undefined) {
        videoOpt.width.min = that.videoSize[0];
        videoOpt.height.min = that.videoSize[1];
        videoOpt.width.max = that.videoSize[2];
        videoOpt.height.max = that.videoSize[3];
      }else {
        videoOpt.width.min = __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.video_resolution_range["Default"].min.wdith;
        videoOpt.height.min = __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.video_resolution_range["Default"].min.height;
        videoOpt.width.max = __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.video_resolution_range["Default"].max.width;
        videoOpt.height.max = __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.video_resolution_range["Default"].max.height;
      }
      if (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'chrome-stable') {
        videoOpt.width.ideal = videoOpt.width.max;
        videoOpt.height.ideal = videoOpt.height.max;
      }
    } else {
      //videoOpt.width.ideal = that.videoSize[2];
      //videoOpt.height.ideal = that.videoSize[3];
    }
  }
  // ************************************
  // Public function: init()
  // Intializes stream, tries to  get access of Local Video and Audio Devices
  // This function must be called before one can publish stream into a room.
  // However, we don't want to shwocase this method to developers. Rather they would
  // Simply call an InitPublisher() function which will initiaze stream and do init(0 and
  // return the object
  // ************************************

  that.init = () => {
    try {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(`requested getUsermedia options: ${JSON.stringify(spec)}`);
      if ((spec.audio || spec.video || spec.screen || spec.canvas) || spec.url === undefined) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Note! Requested access to local media');
        let videoOpt = false,
          audioOpt = false,
          canvasOpt = false;
        const videoSizeForCanvas = [640, 480, 1280, 720];

        if (spec.video && (spec.video !== false)) {
          if (spec.disableGUMOptions == undefined || !spec.disableGUMOptions){
            videoOpt = {};
            checkPopulateVideoResolution(videoOpt);
            if (that.videoFrameRate !== undefined) {
              videoOpt.frameRate = { min: that.videoFrameRate[0], max: that.videoFrameRate[1] };
            }
            if (typeof spec.video === 'object') {
              if (spec.video.deviceId !== undefined && spec.video.deviceId !== '') {
                videoOpt.deviceId = (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() !== 'safari') ?
                  { exact: spec.video.deviceId } : spec.video.deviceId;
              }
              if (spec.video.facingMode !== undefined && spec.video.facingMode !== '' &&
                __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile') {
                videoOpt.facingMode = spec.video.facingMode;
              }
            }
          }else {
            videoOpt = true;
          }
        }

        if (spec.screen && (spec.screen !== false)) {
          videoOpt = true;
        }

        if (spec.canvas && spec.canvas !== false) {
          canvasOpt = {};
          if (that.videoSize === undefined) {
            canvasOpt = {
              width: { min: that.videoSizeForCanvas[0], max: that.videoSizeForCanvas[2] },
              height: { min: that.videoSizeForCanvas[1], max: that.videoSizeForCanvas[3] },
              canvasId: spec.div,
              fps: spec.fps,
            };
          } else {
            canvasOpt = {
              width: { min: that.videoSize[0], max: that.videoSize[2] },
              height: { min: that.videoSize[1], max: that.videoSize[3] },
              canvasId: spec.div,
              fps: spec.fps,
            };
          }
        }

        if (spec.audio && (spec.audio !== false)) {
          if (spec.disableGUMOptions == undefined || !spec.disableGUMOptions){
            audioOpt = {
              echoCancellation: { exact: true },
              googEchoCancellation: { exact: true },
              autoGainControl: { exact: true },
              noiseSuppression: { exact: true },
              googHighpassFilter: { exact: true },
              googExperimentalNoiseSuppression: { exact: true },
              googExperimentalEchoCancellation: { exact: true },
              googExperimentalAutoGainControl: { exact: true },
            };
            if ((typeof spec.audio === 'object') && spec.audio.deviceId && spec.audio.deviceId !== '') {
              audioOpt.deviceId = spec.audio.deviceId;
            }
          }else {
            audioOpt = true;
          }
        }

        const opt = {
          video: videoOpt,
          audio: audioOpt,
          screen: spec.screen,
          canvas: canvasOpt,
          fake: spec.fake,
          extensionId: that.extensionId,
          desktopStreamId: that.desktopStreamId,
        };
        if (spec.screen && (spec.screen !== false)) {
          opt.fps = spec.fps;
        }

        if (spec.canvas && (spec.canvas !== false)) {
          that.state = 'initing';
          that.Connection.GetCanvasStream(opt, (stream) => {
            that.videoStream = stream;
            that.stream = stream;
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(`Got stream from canvas opt: ${opt} refreshFn: ${spec.refreshFn}`);
            that.state = 'inited';
            that.videoStream.getTracks().forEach((trackInput) => {
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('getTracks canvas: ', trackInput);
              const track = trackInput;
              track.onended = () => {
                that.videoStream.getTracks().forEach((secondTrackInput) => {
                  const secondTrack = secondTrackInput;
                  secondTrack.onended = null;
                });

                const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({
                  type: 'stream-ended',
                  stream: that,
                  msg: track.kind,
                });
                that.dispatchEvent(streamEvent);
              };
            });
            const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-access-allowed', stream: that });
            that.dispatchEvent(streamEvent);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_success, { error: {} });
          }, (err) => {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('GetCanvasStream: ', err);
            const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-access-denied', msg: err });
            that.dispatchEvent(streamEvent);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_denied, { error: err });
          });
        } else {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(`Note!! calling getUserMedia ${JSON.stringify(opt)}`);
          if (!spec.screen && that.local){
            if (spec.params == undefined){
              spec.params = {};
              spec.params.config = JSON.parse(JSON.stringify(opt));
              spec.params.set = JSON.parse(JSON.stringify(opt));
            }
          }
          that.state = 'initing';
          getUserMedia(opt, (stream, error) => {
            if (!error) {
              if (spec.params == undefined) spec.params = {set : {}, config : {}};
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Note!!!!! User has granted access to local media.');
              __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_success, { error: {} });
              that.stream = stream;
              that.stream.getTracks().forEach((trackInput, index) => {
                if (trackInput.kind === 'video') {
                  that.videoStream = stream;
                  that.inputMediaSource.video.self = stream;
                  __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info (" GUM success vidtrack muted : " + trackInput.muted + " state: " +
                                trackInput.readyState + " enabled: " + trackInput.enabled);
                  if (typeof (spec.video) !== 'object') spec.video = {};
                  spec.video.trackIndex = index;
                  if (trackInput.getSettings().deviceId) {
                    spec.video.deviceId = trackInput.getSettings().deviceId;
                    spec.params.set.video = {}; spec.params.config.video = {};
                    spec.params.config.video.deviceId = (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() !== 'safari') ?
                                                         { exact: spec.video.deviceId } : spec.video.deviceId;
                    spec.params.config.video.groupId = trackInput.getSettings().groupId;
                    spec.params.set.video = JSON.parse(JSON.stringify(spec.params.config.video));
                  }
                  __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(` Checking and setting soft video muted : ${that.config.videoMuted} firstGumcall: ${that.firstGumCall}`);
                  if (that.config.videoMuted && that.firstGumCall === undefined) {
                    trackInput.enabled = false;
                    that.softVideoMuted = true;
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(' soft muted video ');
                  }
                } else if (trackInput.kind === 'audio') {
                  that.audioStream = stream;
                  if (typeof (spec.audio) !== 'object') spec.audio = {};
                  spec.audio.trackIndex = index;
                  if (trackInput.getSettings().deviceId){
                    spec.audio.deviceId = trackInput.getSettings().deviceId;
                    spec.params.set.audio = {}; spec.params.config.audio = {};
                    spec.params.config.audio.deviceId = (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() !== 'safari') ?
                                                         spec.audio.deviceId  : spec.audio.deviceId;
                    spec.params.config.audio.groupId = trackInput.getSettings().groupId;
                    spec.params.set.audio = JSON.parse(JSON.stringify(spec.params.config.audio));
                  }
                  if (that.config.audioMuted && that.firstGumCall === undefined) {
                    trackInput.enabled = false;
                    audioMuted = true;
                    that.selfMuteAudio = true;
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(' soft muted aduio');
                  }
                }
                if (that.local && !that.ifScreen() && !that.ifCanvas()  &&
                    (__WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type != 'mobile' &&  __WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() != 'safari')){
                  that.handleMediaDeviceChangeNotify ();
                }
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('getTracks', trackInput, ' kind: ', trackInput.kind);
                const track = trackInput;
                track.onended = () => {
                  that.stream.getTracks().forEach((secondTrackInput) => {
                    const secondTrack = secondTrackInput;
                    secondTrack.onended = null;
                  });

                  const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({
                    type: 'stream-ended',
                    stream: that,
                    msg: track.kind,
                  });

                  that.dispatchEvent(streamEvent);
                };
              });
              if(that.videoStream == null) {
                //that.video = false;
                that.config.videoMuted = true;
              }
              if(that.audioStream == null)  {
                that.audio = false;
                that.config.audioMuted = true;
              }
              if((spec.audio === true || spec.video === true) &&
                 ((that.audio === false  && !that.ifScreen) || that.video === false)) {
                let evntDetails = {};
                if(that.video === false) evntDetails.video = that.video;
                if(that.audio === false) evntDetails.audio = that.audio;
                const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-access-failed', evntDetails});
                that.dispatchEvent(streamEvent);
              }
              that.state = 'inited';
              const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-access-allowed', stream: that });
              that.dispatchEvent(streamEvent);
              __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_success, { error: {} });
            }else {
              let type = !that.ifScreen() ? 'media-access-denied'  : 'media-access-failed';
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error("Error! local media access Failed - share: " + that.ifScreen()+ " Err : " + JSON.stringify(error));
              that.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-access-denied', msg: error }));
              __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_denied, { error });
            }
            that.fistGumCall = true;
          });
        }
      } else {
        const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-access-allowed' });
        that.dispatchEvent(streamEvent);
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_success, { error: {} });
      }
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Error! Failed to get access to local media. Error was ${e}.`);
      const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'media-access-denied', msg: e });
      that.dispatchEvent(streamEvent);
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_media_access_denied, { error: e });
    }
  };

  that.initRemoteStream = (stream) => {
    if (!that.local) {
      that.stream = stream;
      if (that.ifAudio() || that.audioOnly) {
        that.audioStream = new MediaStream();
        that.stream.getAudioTracks().forEach((track) => {
          that.audioStream.addTrack(track);
        });
      }
      // @todo - mediaStream or videoStream
      that.mediaStream = new MediaStream();
      that.stream.getTracks().forEach((track) => {
        that.mediaStream.addTrack(track);
      });
    }
  };

  // ************************************
  // Public function: close()
  // Unpublishes a published stream from Room. Hides it from HTML DOM object and stops each track of the stream.
  // ************************************

  that.close = () => {
    if (that.local) {
      // Unpublishes stream from Room
      if (that.room !== undefined) {
        that.room.unpublish(that);
      }

      // Removes HTML DOM element
      that.hide();
      if (that.videoStream !== undefined) {
        that.videoStream.getVideoTracks().forEach((track) => {
          track.enabled = false;
          track.onended = null;
          track.stop(); // Stops each track in the Stream
        });
        that.videoStream = undefined;
      }
      if (that.audioStream !== undefined) {
        that.audioStream.getAudioTracks().forEach((track) => {
          track.onended = null;
          track.stop(); // Stops each track in the Stream
        });
        that.audioStream = undefined;
      }
      // @todo - no clean up for mediaStream object
      if (that.pc && that.pc.peerConnection !== undefined)
        that.pc.peerConnection.close();
      that.stream = undefined;
      that.state = 'idle';
    }
  };


  // ************************************
  // Public function: play()
  // Plays the stream in HTML DOM Element. One can pass all player's display options too.
  // ************************************
  that.disableTrack = (streamID) => {
    that.room.removeTrack(streamID);
  };

  that.attachMediaStream = (element, stream) => {
    if (!element) {
      return null;
    }
    if (element.isWebRtcPlugin) {
      element.src = stream;
      return element;
    } else if (element.nodeName.toLowerCase() === 'video') {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Checked element is video');
      if (!element.pluginObj && stream) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Plugins and stream validated');
        const _pluginObj = document.createElement('object');
        const _isIE = (Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(window, 'ActiveXObject')) || ('ActiveXObject' in window);
        if (_isIE) {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Browser IE validated');
          // windowless
          const windowlessParam = document.createElement('param');
          windowlessParam.setAttribute('name', 'windowless');
          windowlessParam.setAttribute('value', true);
          _pluginObj.appendChild(windowlessParam);
          _pluginObj.setAttribute('classid', 'CLSID:7FD49E23-C8D7-4C4F-93A1-F7EACFA1EC53');
        } else {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Other browser got');
          _pluginObj.setAttribute('type', 'application/webrtc-everywhere');
        }
        element.pluginObj = _pluginObj;

        _pluginObj.setAttribute('className', element.className);
        _pluginObj.setAttribute('innerHTML', element.innerHTML);
        let width = element.getAttribute('width');
        let height = element.getAttribute('height');
        const bounds = element.getBoundingClientRect();
        if (!width) width = bounds.right - bounds.left;
        if (!height) height = bounds.bottom - bounds.top;

        if ('getComputedStyle' in window) {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('computing style');
          const computedStyle = window.getComputedStyle(element, null);
          if (!width && computedStyle.width != 'auto' && computedStyle.width != '0px') {
            width = computedStyle.width;
          }
          if (!height && computedStyle.height != 'auto' && computedStyle.height != '0px') {
            height = computedStyle.height;
          }
        }
        if (width) _pluginObj.setAttribute('width', width);
        else _pluginObj.setAttribute('autowidth', true);
        if (height) _pluginObj.setAttribute('height', height);
        else _pluginObj.setAttribute('autoheight', true);

        document.body.appendChild(_pluginObj);
        if (element.parentNode) {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('parent node found');
          element.parentNode.replaceChild(_pluginObj, element); // replace (and remove) element
          // add element again to be sure any query() will succeed
          document.body.appendChild(element);
          element.style.visibility = 'hidden';
        }
      }


      if (element.pluginObj) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('plugin object found');
        element.pluginObj.bindEventListener('play', (objvid) => {
          if (element.pluginObj) {
            if (element.pluginObj.getAttribute('autowidth') && objvid.videoWidth) {
              element.pluginObj.setAttribute('width', objvid.videoWidth/* + "px"*/);
            }
            if (element.pluginObj.getAttribute('autoheight') && objvid.videoHeight) {
              element.pluginObj.setAttribute('height', objvid.videoHeight/* + "px"*/);
            }
          }
        });
        element.pluginObj.src = stream;
      }
      return element.pluginObj;
    } else if (element.nodeName.toLowerCase() === 'audio') {
      return element;
    }
    // @todo - element.nodeName can be only audio or video?
  };
  let retryCount = 1;

  const getUserMedia = (mediaOpt, callback, retry = true) => {
    let opt = JSON.parse(JSON.stringify(mediaOpt));
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(`getusermedia called  opt ${JSON.stringify(opt)}`);
    let supportedConstrnts = that.Connection.getSupportedDeviceConstraints();
    if (supportedConstrnts){
      if (opt.video && typeof opt.video == 'object'){
        if (__WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile'){
          if (supportedConstrnts.hasOwnProperty('facingMode') && opt.video.facingMode){
            if (opt.video.deviceId) delete opt.video.deviceId;
          }else if (supportedConstrnts.hasOwnProperty('deviceId') && opt.video.deviceId){
            if (opt.video.facingMode) delete opt.video.facingMode;
          }else {
            if (opt.video.deviceId) delete opt.video.deviceId;
            if (opt.video.facingMode) delete opt.video.facingMode;
          }
          if (opt.video.height) delete opt.video.height;
          if (opt.video.width) delete opt.video.width;
        }else {
          if (supportedConstrnts.hasOwnProperty('deviceId') && opt.video.deviceId){
            if (opt.video.facingMode) delete opt.video.facingMode;
          }else if (supportedConstrnts.hasOwnProperty('facingMode') && opt.video.facingMode){
            if (opt.video.deviceId) delete opt.video.deviceId;
          }else {
            if (opt.video.deviceId) delete opt.video.deviceId;
            if (opt.video.facingMode) delete opt.video.facingMode;
          }
        }
        if (!supportedConstrnts.hasOwnProperty('frameRate') && opt.video.frameRate != undefined){
          delete opt.video.frameRate;
        }
      }
    }
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug ("calling gum with options: " + JSON.stringify(opt));
    that.Connection.GetUserMedia(opt, (stream) => {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('getUserMedia success');
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_gum_success, { error: {} });
      retryCount = 0;
      callback(stream);
    }, (error) => {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Get User Media screen  failed streamId: ' , that.getID(), ' Error ', error);
      error = Object(__WEBPACK_IMPORTED_MODULE_5__utils_ErrorHandler__["a" /* default */])(error);

      if ((opt.video.height && opt.video.height.min) && (opt.video.width && opt.video.width.min)) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(`getUserMedia failed error: ${error.result} min Res: ${opt.video.height.min}X${opt.video.width.min}`);
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_gum_failed, { error });
      }
      const newOpt = {};
      Object.assign(newOpt, opt);
      switch (error.result) {
        case 1143:
        case 1144:
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(` ERROR : ${error.result} newOpt: ${JSON.stringify(newOpt)}`);
          if (!newOpt.screen && (!spec.media_order || spec.media_order != "exact")){
            if ( newOpt.video && newOpt.audio) {
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('getUserMedia() Failed with device denied/unvailable .. retrying with audio only');
              newOpt.video = false;
            } else {
              retry = false;
            }
          }else {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('getUserMedia() Failed with device denied/unvailable . no retry ');
            retry = false;
          }
          break;
        case 1147:
        case 1148:
        case 1149:
          switch (newOpt.video.height.min) {
            case 720:
              newOpt.video.height.min = 540;
              newOpt.video.width.min = 960;
              break;
            case 540:
              newOpt.video.height.min = 540;
              newOpt.video.width.min = 960;
              break;
            case 480:
              newOpt.video.height.min = 360;
              newOpt.video.width.min = 480;
              break;
            default:
              retry = false;
              break;
          }
          break;
        case 1145:
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(` ERROR : ${error.result} Opt: ${JSON.stringify(newOpt)} check and retry`);
          break;
        default:
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(` ERROR Default : ${error.result} newOpt: ${JSON.stringify(newOpt)}`);
          retry = false;
          break;
      }

      if (!that.ifScreen() && retry === true && retryCount <= 5) {
        retryCount = retryCount + 1;
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info("getUserMedia() failed retry count: " + retryCount);
        getUserMedia(newOpt, callback);
      } else {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error("getUserMedia() failed for screen or no retry allowed  or retry count exceeded: " );
        retryCount = 0;
        callback(undefined, error);
      }
    });
  };

  that.setQualityLayers = (numSpatialLayers) => {
    if (that.pc && that.stream && that.local && that.pc.peerConnection && that.pc.peerConnection.getSenders) {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(` that.setQulaityLayers numSpatialLayers:${numSpatialLayers}`);

      that.pc.peerConnection.getSenders().forEach((sender) => {
        if (sender.track && sender.track.kind === 'video') {
          const parameters = sender.getParameters();
          if ((parameters != undefined) && (parameters.encodings != undefined)) {
            for (let cnt = 0; cnt < parameters.encodings.length; cnt++) {
              if (numSpatialLayers > cnt) {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(` Layer :${cnt} enabled`);
                parameters.encodings[cnt].active = true;
              } else {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(` Layer :${cnt} disabled`);
                parameters.encodings[cnt].active = false;
              }
            }
            sender.setParameters(parameters);
          } else {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(' that.setQulaityLayers: no sender params/encodings-  Not in simulcast mod');
          }
        }
      });
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(`setQulaityLayers Failed invalid stream :${that.stream} local: ${that.local}`);
    }
  };

  that.onConnectionStateChanged = (active) => {
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(` that.onConnectionStateChanged() active : ${active} `);
    if (that.local) {
      if (active) {
        if (that.ifCanvas()) {
          if (spec.refreshFn !== undefined) {
            spec.refreshFn();
            const timerVal = spec.fps > spec.maxCanvasRefreshRate ? 1000 / spec.maxCanvasRefreshRate : 1000 / spec.fps;
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(` that.onConnectionStateChanged ()  timerVal : ${timerVal} spec.fps: ${spec.fps}`);
            that.refreshTimer = setInterval(() => { __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug('refresh called timer '); spec.refreshFn(); }, timerVal);
          }
        } else if (!that.ifScreen()) {
          that.negotiatedMedia.video = that.videoStream != undefined;
          that.negotiatedMedia.audio = that.audioStream != undefined;
          if (that.video && that.negotiatedMedia.video) {
            if (that.maxVideoLayers <= 0) {
              //setVideoBitrate();
              mediaConfig.videoBw.set = mediaConfig.videoFps.set = 0;
              setVideoParams(mediaConfig.videoBw, mediaConfig.videoFps);
            } else {
              that.videoStream.getVideoTracks().forEach((track) => {
              const constraints = track.getConstraints();
              constraints.height.max = that.videoSize[3];
              constraints.height.ideal = that.videoSize[3];
              constraints.width.max = that.videoSize[2];
              constraints.width.ideal = that.videoSize[2];
              constraints.frameRate = { max: 26 };
              track.applyConstraints(constraints)
                .then(() => { __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug('applying constraints for simulcast video success'); })
                .catch((e) => { __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(` error in applying constraints for simulcast video error: ${e}`); });
              });
            }
          }
        }
      } else if (that.ifCanvas() && that.refreshTimer != undefined) {
        clearInterval(that.refreshTimer);
        that.refreshTimer = undefined;
      }
    }
    if (active) that.state = 'connected';
  };

  that.setVideoParamsRange = (maxKbps, minKbps, maxFps, minFps, setByServer) => {
    if (that.maxVideoLayers > 1) return;

    if (setByServer) {
      if (maxKbps !== undefined) mediaConfig.videoBw.max.server = parseInt(maxKbps);
      if (maxFps !== undefined) mediaConfig.videoFps.max.server = parseInt(maxFps);
      if (minKbps !== undefined) mediaConfig.videoBw.min.server = parseInt(minKbps);
      if (minFps !== undefined) mediaConfig.videoFps.min.server = parseInt(minFps);
    } else {
      if (maxKbps !== undefined) mediaConfig.videoBw.max.user = parseInt(maxKbps);
      if (maxFps !== undefined) mediaConfig.videoFps.max.user = parseInt(maxFps);
      if (minKbps !== undefined) mediaConfig.videoBw.min.user = parseInt(minKbps);
      if (minFps !== undefined) mediaConfig.videoFps.min.user = parseInt(minFps);
    }
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(`setVideoParamsRange() id: ${that.getID()} :: ${maxKbps}: ${minKbps}:${maxFps}:${minFps}:${setByServer}`);
    setVideoParams(mediaConfig.videoBw, mediaConfig.videoFps);
  };

  const setVideoParams = (bwRange, fpsRange) => {
    let b2Set = 0,
      fps2Set = 0;
    if (bwRange.max.user && bwRange.max.user < bwRange.min.user) b2Set = bwRange.min.user;
    else if (bwRange.max.user && (!bwRange.max.server || bwRange.max.user <= bwRange.max.server)) b2Set = bwRange.max.user;
    else if (bwRange.max.server && bwRange.max.server < bwRange.min.user) b2Set = bwRange.min.user;
    else if (bwRange.max.server && bwRange.max.server < bwRange.min.server) b2Set = bwRange.min.server;
    else b2Set = bwRange.max.server;

    if (fpsRange.max.user < fpsRange.min.user) fps2Set = fpsRange.min.user;
    else if (fpsRange.max.user &&(!fpsRange.max.server || fpsRange.max.user <= fpsRange.max.server)) fps2Set= fpsRange.max.user;
    else if (fpsRange.max.server && fpsRange.max.server < fpsRange.min.user) fps2Set = fpsRange.min.user;
    else if (fpsRange.max.server && fpsRange.max.server < fpsRange.min.server) fps2Set = fpsRange.min.server;
    else fps2Set = fpsRange.max.server;

    if (that.pc == undefined || that.pc.peerConnection == undefined || that.room == undefined) {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`setVideoParams() not set pc/room not defined ${JSON.stringify(mediaConfig)} b2Set: ${b2Set} fps2Set: ${fps2Set}`);
      return;
    }
    if (b2Set && (bwRange.min.server != b2Set && bwRange.max.server != b2Set)) {
      const options = [{
        id: 'publisher-video-bw-update',
        streamId: that.getID(),
        min: bwRange.min.user,
        max: bwRange.max.user,
      }];
      that.room.setAdvancedOptions(options, () => { });
    }
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(` setVideoParams: id: ${that.getID()} b2Set ${b2Set} fps2Set ${fps2Set} bwrange: ${JSON.stringify(bwRange)}`);
    if ((b2Set && bwRange.set != b2Set) || (fps2Set && fpsRange.set != fps2Set)) {
      const browser = __WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck();
      if ((browser === 'chrome-stable') || ((browser === 'mozilla') &&
        (!__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_7__vcxEventProperties__["a" /* default */].constant.FIREFOX_VERSION_SENDER_ENCODINGS_PARAM_SUPPORT))) ||
        (browser === 'safari' &&
          !__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].isCurrentVerLess(__WEBPACK_IMPORTED_MODULE_7__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_SENDER_ENCODINGS_PARAM_SUPPORT))) {
        that.pc.peerConnection.getSenders().forEach((sender) => {
          if (sender.track && sender.track.kind === 'video') {
            const parameters = sender.getParameters();
            if (parameters != undefined) {
              if (!parameters.encodings) parameters.encodings = [{}];
              for (let cnt = 0; cnt < parameters.encodings.length; cnt++) {
                if (b2Set) {
                  __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(' that.setMaxVideoBitarte id: ' + that.getID() + ' bw: ' + b2Set);
                  parameters.encodings[cnt].maxBitrate = b2Set * 1000;
                  bwRange.set = b2Set;
                }
                if (fps2Set) {
                  __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(' that.setMaxVideoFramerate id: ' + that.getID() + ' fps: ', fps2Set);
                  parameters.encodings[cnt].maxFramerate = fps2Set;
                  fpsRange.set = fps2Set;
                }
              }
              sender.setParameters(parameters);
            } else {
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(' that.setMaxVideoBitarte: no sender params/encodings-  ');
            }
          }
        });

        const setVideoQualityConstraints = (track, constraints, resTable, typeIndex, resIndex, fps, errors, callback) => {
          if (typeIndex < resTable.length) {
            let constr = track.getConstraints();
            let apply = false;
            if (constraints.height){
              constraints.height.max = resTable[typeIndex].res[resIndex].height;
              constraints.height.ideal = resTable[typeIndex].res[resIndex].height ;
              if (!constr.height || !constr.height.max || constr.height.max != constraints.height.max) apply=true;
            }
            if (constraints.width){
              constraints.width.max = resTable[typeIndex].res[resIndex].width;
              constraints.width.ideal = resTable[typeIndex].res[resIndex].width;
              if (!constr.width || !constr.width.max ||  constr.width.max != constraints.width.max) apply=true;
            }
            constraints.frameRate = { max: fps };
            if (!constr.frameRate || !constr.frameRate.max || constr.frameRate.max != constraints.frameRate.max) apply=true;
            if (apply) {
              track.applyConstraints(constraints)
                .then(() => {
                  callback(constraints, errors);
                })
                .catch((e) => {
                  errors.push({ res: resTable[typeIndex].res[resIndex], error: e });
                  if (resTable[typeIndex].res.length < (resIndex + 1)) resIndex++;
                  else { typeIndex++; resIndex = 0, fps = 30; }
                  // only first time take the fps value, after that should be 30
                  setVideoQualityConstraints(track, constraints, resTable, typeIndex, resIndex, fps, errors, callback);
                });
            }else {
              callback(constraints, errors);
            }
          } else {
            callback(null, errors);
          }
        };

        if (!that.ifScreen() && !that.ifCanvas() && browser !== 'safari') {
          that.videoStream.getVideoTracks().forEach((track) => {
            const quality = __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.getCamResTableToCheck(bwRange.set);
            //console.log (" Bitrate map table : " + JSON.stringify(enxConfig.getBitrateMapTable()) +
            //             " res table: " + JSON.stringify(enxConfig.getCamResolutionTable()));
            const constraints = track.getConstraints();
            if (quality == undefined) {
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`reverting kbps: ${bwRange.set} constraints: curr: ${JSON.stringify(constraints)
                } original: ${that.videoSize[3]} X ${that.videoSize[2]}`);
              if ((constraints.height != undefined && constraints.width != undefined) &&
                  (constraints.height.max == undefined || constraints.width.max == undefined ||
                   that.videoSize[3] != constraints.height.max || that.videoSize[2] != constraints.width.max)) {
                constraints.height.max = that.videoSize[3];
                constraints.height.ideal = that.videoSize[3];
                constraints.width.max = that.videoSize[2];
                constraints.width.ideal = that.videoSize[2];
                constraints.frameRate = { max: 26 };
                track.applyConstraints(constraints)
                  .then(() => { __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('apply constraints to original value'); })
                  .catch((e) => { __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('failed  - apply constraints to original value'); });
              }
            } else {
              const errors = [];
              if (!constraints.height || !constraints.width){
                constraints.width = {min: __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.video_resolution_range["Default"].min.width};
                constraints.height = {min: __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.video_resolution_range["Default"].min.height};
              }
              setVideoQualityConstraints(track, constraints, quality.resTable, 0, 0, quality.fps, errors,
                (newConstraints, errors) => {
                    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug("setVideoQualityConstraints() " + (newConstraints != null ? "Succes" : "Failure") +
                                " constraints old: " + JSON.stringify(constraints) +
                                 " new: " + JSON.stringify(newConstraints) + "  errors: " + JSON.stringify(errors));
              });
            }
          });
        }
      } else {
        //support traditional way of sdp renegotiation.. in kbps
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Setting Max Bw  using sdp reneg videoBwKbps= ', videoBwKbps);
        const config = { maxVideoBW: b2Set, Sdp: true };
        bwRange.set = b2Set;
        that.pc.updateSpec(config, () => {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('that.setMaxVideoBitarte: sdp reneg success');
        });
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_incompatible_browser, { message: (`Setting Max Bw  using traditional way of sdp renegotiation videoBwKbps= ${b2Set}`) });
      }
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(`setVideoParams Failed id: ${that.getID()} b2Set ${b2Set} bwrange: ${JSON.stringify(bwRange)}`);
    }
  };

  that.setVideoQualityParams = (minWidth, minHeight, maxWidth, maxHeight, fps) => {
    that.videoStream.getVideoTracks().forEach((track) => {
      const constraints = track.getConstraints();
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info(`RESOLUTION Set track before constariants : ${JSON.stringify(constraints)}`);
      if (minWidth != null && minHeight != null) {
        if (constraints.width == undefined) constraints.width = {};
        if (constraints.height == undefined) constraints.height = {};
        constraints.width.min = minWidth;
        constraints.height.min = minHeight;
      }
      if (maxHeight != null && maxWidth != null) {
        if (constraints.width == undefined) constraints.width = {};
        if (constraints.height == undefined) constraints.height = {};
        constraints.height.max = maxHeight;
        constraints.width.max = maxWidth;
        if (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'chrome-stable') {
          constraints.width.ideal = maxWidth;
          constraints.height.ideal = maxHeight;
        }
      }
      if (constraints.width.min && constraints.height.min &&
          constraints.width.max && constraints.height.max &&
          (constraints.width.min * constraints.height.min) > (constraints.width.max * constraints.height.max)){
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error( "setVideoResolution() : constraint mismatch : " + JSON.stringify(constraints));
        return false;
      }
      if (fps != null) constraints.frameRate = { max: fps };
      track.applyConstraints(constraints)
        .then(() => {
          console.log(`RESOLUTION Set track constariants success : ${JSON.stringify(constraints)}`);
        })
        .catch((reason) => {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`RESOLUTION Set trac constraints failed: ${reason} constraints: ${JSON.stringify(constraints)}`);
          //EL.error('stream-event', customEvents.event_general_failed, { message: (`RESOLUTION Set trac constraints failed: ${reason} constraints: ${JSON.stringify(constraints)}`) });
        });
    });
  };

  that.switchMicrophone = (stream, mic_id, callback, force = true) => {
    if (!that.negotiatedMedia.audio) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMicrophone - Stream not found') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
      return;
    }
    if (setTrasactionIfNotExists('setMicrophoneTrack') == false) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMicrophone - Previous similar request in process') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
      return;
    }
    if ((that.selfMuteAudio || that.hardAudioMuted) && force) {
      pendingUserReqs['switchMicrophone'] = {newStream: stream, deviceInfo : mic_id};
      resetTransaction('setMicrophoneTrack');
      callback({result : 0, msg : "set but not active"});
      return;
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMicrophone - Media device switching not allowed in mute state') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1189);
      return;
    }
    setMediaDevicesTrack(stream, mic_id, undefined, true, (status) => {
      resetTransaction('setMicrophoneTrack');
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error("setMediaDevicesTrack() in switch mic returned failure : " + JSON.stringify(status) + "device type: " +
                  __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type);
      if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1145 && __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile'){
        if (that.room !== undefined) {
          that.room.onMediaDeviceStateChanged(stream,{type :'mic', state: 'inactive', error:status});
        }else {
          callback(status);
        }
      }else {
        callback((status.result === 0) ? stream : status);
      }
    });
  };

  that.switchCamera = (stream, camInfo, callback = () => { }, force = true, setPCTrack =true) => {
    if (typeof callback === 'function') {
      if (that.stream == undefined) {
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
        return;
      }
      if (that.stream.getVideoTracks().length !== 1) {
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
        return;
      }
      if (!that.negotiatedMedia.video) {
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchCamera - Stream not found') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
        return;
      }
      if (setTrasactionIfNotExists('setCameraTrack') == false) {
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed,
                { message: ('switchCamera - Previous similar request in process') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
        return;
      }
      if ((that.selfMuteVideo || that.hardVideoMuted) && !localVideoOn && force) {
        pendingUserReqs['switchCamera'] = {newStream: stream, deviceInfo : camInfo};
        callback({result : 0, msg : "set but not active"});
        resetTransaction("setCameraTrack");
        return;
      }
      const cam = {};
      if (camInfo != undefined) {
        if (typeof camInfo === 'string') cam.deviceId = camInfo;
        else if (typeof camInfo === 'object') {
          that.sendMessage('cameraSwitched',  {});
          if (camInfo.deviceId != undefined && typeof camInfo.deviceId === 'string') cam.deviceId = camInfo.deviceId;
          if (camInfo.facingMode != undefined && typeof camInfo.facingMode === 'string') {cam.facingMode = camInfo.facingMode; }          if (cam.deviceId == undefined && cam.facingMode == undefined) {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Error switchCamera(), error: invalid camera options ${JSON.stringify(camInfo)}`);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed,
                     { message: (`Error switchCamera(), error: invalid camera options ${JSON.stringify(camInfo)}`) });
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
            return;
          }
        } else {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Error switchCamera(), error: invalid camera options type ${JSON.stringify(camInfo)}`);
          __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed,
                    { message: (`Error switchCamera(), error: invalid camera options type ${JSON.stringify(camInfo)}`) });
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
          resetTransaction("setCameraTrack");
          return;
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Error switchCamera(), error: camera options undefined');
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed,
                 { message: ('Error switchCamera(), error: camera options undefined') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
        resetTransaction("setCameraTrack");
        return;
      }
      var retry = 0;

      that.stream.getVideoTracks().forEach((track) => {
        track.enabled = false;
        track.stop();
        track.onended = setMediaDevicesTrack(stream, undefined, cam, setPCTrack, (status) => {
          var stream_status = false;
          var callback_stream = stream;
          stream.stream.getVideoTracks().forEach((track) => {
            stream_status = track.readyState;
          })
          if (status.result === 0) {
            attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
            // attachStreamOnPlayerDivs(that.videoStream);
            resetTransaction("setCameraTrack");
            callback((status.result === 0) ? stream : status);
          }else if (status.result === 1150) {
            // attachStreamOnPlayerDivs(that.videoStream);
            // callback(stream);
            if (stream_status == 'live') {
              attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
            // attachStreamOnPlayerDivs(that.videoStream);
              resetTransaction("setCameraTrack");
              callback(stream);
            }
          }else {
            resetTransaction("setCameraTrack");
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error ("setMediaDevicesTrack() switch cam returned failure : " + JSON.stringify(status) + "device type: " +
                          __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type);
            if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1145 && __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile'){
              if (that.room !== undefined) {
                that.room.onMediaDeviceStateChanged(stream,{type :'cam', state: 'inactive', error:status});
              }else {
                callback(status);
              }
            }else {
              resetTransaction("setCameraTrack");
              callback(status);

            }
          }
        });
      });
    }
    else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('switchCamera() invalid param - callback');
    }
    // resetTransaction("setCameraTrack");
  };

  that.switchMediaDevices = (stream, mic_id, camInfo, callback) => {
    if (!that.negotiatedMedia.audio || !that.negotiatedMedia.video) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMediaDevices - Stream not found') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
      return;
    }
    if (camInfo !== undefined) {
      if (that.selfMuteVideo || that.hardVideoMuted) {
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMediaDevices - Media device switching not allowed in video mute state') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1189);
        return;
      }
      if (setTrasactionIfNotExists('setCameraTrack') == false) {
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMediaDevices - Previous similar request in process') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
        return;
      }
    }
    if (mic_id !== undefined) {
      if (that.selfMuteAudio || that.hardAudioMuted) {
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMediaDevices - Media device switching not allowed in audio mute state') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1189);
        if (camInfo !== undefined) resetTransaction('setCameraTrack');
        return;
      }
      if (setTrasactionIfNotExists('setMicrophoneTrack') == false) {
        if (camInfo !== undefined) resetTransaction('setCameraTrack');
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('switchMediaDevices - Previous similar request in process') });

        return;
      }
    }
    let cam = {};
    if (camInfo != undefined) {
      if (typeof camInfo === 'string') cam.deviceId = camInfo;
      else if (typeof camInfo === 'object') {
        if (camInfo.deviceId != undefined && typeof camInfo.deviceId === 'string') cam.deviceId = camInfo.deviceId;
        if (camInfo.facingMode != undefined && typeof camInfo.facingMode === 'string') { cam.facingMode = camInfo.facingMode; }         if (cam.deviceId == undefined && cam.facingMode == undefined ){
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Error switchMediaDevices(), error: invalid camera options ${JSON.stringify(camInfo)}`);
          __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: (`Error switchMediaDevices(), error: invalid camera options ${JSON.stringify(camInfo)}`) });
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
          return;
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Error switchMediaDevices(), error: invalid camera options type ${JSON.stringify(camInfo)}`);
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: (`Error switchMediaDevices(), error: invalid camera options type ${JSON.stringify(camInfo)}`) });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
        return;
      }
    } else {
      cam = undefined;
    }

    if (that.stream == undefined) {
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
      resetTransaction("setCameraTrack");
      return;
    }
    that.stream.getVideoTracks().forEach((track) => {
      track.stop();
      track.onended = setMediaDevicesTrack(stream, mic_id, cam, true, (status) => {
        var stream_status = false;
        var callback_stream = stream;
        stream.stream.getVideoTracks().forEach((track) => {
          stream_status = track.readyState;
        })
        if (status.result === 0) {
          attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
         // attachStreamOnPlayerDivs(that.videoStream);
          resetTransaction("setCameraTrack");
          resetTransaction("setMicrophoneTrack");
          callback((status.result === 0) ? stream : status);
        }else if (status.result === 1150) {
          attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
          //attachStreamOnPlayerDivs(that.videoStream);

          callback(stream);
          if (stream_status == 'live') {
            attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
            //attachStreamOnPlayerDivs(that.videoStream);
            resetTransaction("setCameraTrack");
            resetTransaction("setMicrophoneTrack");
            callback(stream);
          }
          else {
            resetTransaction("setCameraTrack");
            resetTransaction("setMicrophoneTrack");
            callback(status);

          }
        }else {
          resetTransaction("setCameraTrack");
          resetTransaction("setMicrophoneTrack");
          console.log ("setMediaDevicesTrack() switch media dev  failure : " + JSON.stringify(status) + "device type: " +
                       __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type);
          if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1145 && __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile'){
            if (that.room !== undefined) {
              that.room.onMediaDeviceStateChanged(stream,{type :'mic', state: 'inactive', error:status});
            }else {
              callback(status);
            }
          }else {
            callback(status);
          }
        }
      });
    });
  };

  that.setSpeaker = (speakerId, volume) => {
    let elementID = that.getPlayerId();
    if (document.querySelector(`#${elementID.stream}`) !== undefined &&
        document.querySelector(`#${elementID.stream}`) !== null) {
      let domIds = document.querySelectorAll('#' + elementID.stream);
      domIds.forEach(element => {
        if (typeof element.setSinkId === "function" && speakerId != undefined) element.setSinkId(speakerId);
        if (volume != undefined) element.volume = volume;
      });
    }
  };

  const setTrasactionIfNotExists = (transId) => {
    if (!that.transactions.get(transId)) {
      that.transactions.set(transId, { state: 'inprogress' });
      return true;
    }
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Invalid state: previous request in progress. transId: ${transId}`);
    __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: (`setTrasactionIfNotExists - Invalid state: previous request in progress. transId: ${transId}`) });
    return false;
  };

  const resetTransaction = transId => that.transactions.delete(transId);
  let retry = 0;

  const setMediaDevicesTrack = (stream, mic_id, cam, setPCTrack, callback) => {
    var newStream = new MediaStream();
    //if(stream && stream.local===true && stream.pc && stream.pc.peerConnection &&
    if (stream && stream.local === true && !stream.ifScreen() && !stream.ifCanvas()) {
      let options = {};
      if (mic_id !== undefined) {
        if (mic_id !== 'none') options.audio = { deviceId: mic_id  };
        else options.audio = true;
      } else options.audio = false;
      if (cam !== undefined) {
        options.video = {};
        checkPopulateVideoResolution(options.video);
        if (cam.deviceId != undefined && cam.deviceId !== "none")
          options.video = { 'deviceId': { exact: cam.deviceId } };
        if (cam.facingMode != undefined)
          options.video = { facingMode: { exact: cam.facingMode } };
        // options.video.facingMode = { exact: cam.facingMode};
        if (that.videoFrameRate !== undefined)
          options.video.frameRate = { min: that.videoFrameRate[0], max: that.videoFrameRate[1] };
      } else {
        options.video = false;
      }

      getUserMedia(options, (streamGot, error) => {
        if (error == undefined) {
          if (stream.pc && stream.pc.peerConnection && setPCTrack) {
            let stream2Set ;
            if (cam){
              stream2Set = that.inputMediaSource.video.selected === 'user' ?
                              that.inputMediaSource.video.user : streamGot;
              that.inputMediaSource.video.self = streamGot;
            }else {
              stream2Set = streamGot;
            }
            replaceNewMediaStreamTrack(stream, (mic_id !== undefined), (cam !== undefined), stream2Set,
                                       that.inputMediaSource.video.selected == 'self' );
          }
          //stream.stream = newStream;
          if (cam) {
            stream.videoStream = streamGot;
            if (!spec.params.set.video || typeof spec.params.set.video != 'object') spec.params.set.video = {};
            that.inputMediaSource.video.self = streamGot;
            streamGot.getVideoTracks().forEach((track, index) => {
              newStream.addTrack(track);
              spec.params.set.video.groupId = track.getSettings().groupId;
            });
            if (cam.deviceId != undefined) {
              if (cam.deviceId !== 'none') {
                spec.video.deviceId = cam.deviceId;
                spec.params.set.video.deviceId = JSON.parse (JSON.stringify(options.video.deviceId));
              }
            } else {
              streamGot.getVideoTracks().forEach((track, index) => {
                if (track.getSettings().deviceId != undefined) spec.video.deviceId = track.getSettings().deviceId;
                newStream.addTrack(track);
              });
            }
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].log('Got video access from devices:- ', spec.video.deviceId);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_gum_success, { message: (`Got video access from devices:- ${spec.video.deviceId}`) });
          } else {
            if (stream.videoStream){
              stream.videoStream.getVideoTracks().forEach((track, index) => {
                newStream.addTrack(track);
              });
            }
          }
          if (mic_id) {
            stream.audioStream = streamGot;
            streamGot.getAudioTracks().forEach((newtrack, index) => {
              newStream.addTrack(newtrack);
              spec.params.set.audio.groupId = newtrack.getSettings().groupId;
            });
            if (mic_id !== 'none') {
              if(spec.audio) spec.audio.deviceId = mic_id;
              spec.params.set.audio.deviceId = JSON.parse (JSON.stringify(options.audio.deviceId));
            }
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].log('Got audio access from devices:- ', mic_id);
            __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_gum_success, { message: (`Got audio access from devices:- ${mic_id}`) });
          } else {
            if(stream.audioStream) {
              stream.audioStream.getAudioTracks().forEach(track => newStream.addTrack(track));
            }
          }
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        } else {
          let camId = cam ? cam.deviceId : "null";
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info("Error getUserMedia(), error: " + error + " cam: " +  camId +  " mic: ", mic_id);
          __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_gum_failed, { cam_id: camId , mic_id: mic_id });
          callback(error);

        }
        stream.stream = newStream;
      });
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Cannot switch devices over invalid stream');
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('setMediaDevicesTrack - Cannot switch devices over invalid stream') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
    }
  };

  const replaceNewMediaStreamTrack = (streamObj, audio, video, newStream, closeCurrVStream=true, closeCurrAStream=true) => {
    let sender_audio_track_found = false,
      sender_video_track_found = false;
    if (streamObj.pc && streamObj.pc.peerConnection){
      streamObj.pc.peerConnection.getSenders().forEach((sender, index) => {
        if (sender.track) {
          if (video && (sender.track.kind === 'video')) {
            if (typeof spec.video !== 'object') spec.video = {};
            spec.video.trackIndex = index;
            sender_video_track_found = true;
            if (newStream) {
              newStream.getVideoTracks().forEach((vtrack) => {
                vtrack.enabled = true; sender.replaceTrack(vtrack);
              });
            } else {
              sender.replaceTrack(null);
            }
            if (closeCurrVStream){
              streamObj.videoStream.getVideoTracks().forEach((vtrack) => {
                vtrack.enabled = false;vtrack.onended = null; vtrack.stop();
              });
            }
          } else if (audio && (sender.track.kind === 'audio')) {
            spec.audio.trackIndex = index;
            sender_audio_track_found = true;
            if (newStream) {
              newStream.getAudioTracks().forEach((atrack) => {
                atrack.enabled = true; sender.replaceTrack(atrack);
              });
            } else {
              sender.replaceTrack(null);
            }
            if (closeCurrAStream){
              if (streamObj.audioStream){
                streamObj.audioStream.getAudioTracks().forEach((atrack) => {
                  atrack.enabled = false;atrack.onended = null; atrack.stop();
                });
              }
            }
          }
        }
      });
    }else {
      if (video && streamObj.videoStream && closeCurrVStream){
        streamObj.videoStream.getVideoTracks().forEach((vtrack) => {
          console.log ("without replace track setting current videotracks to stop");
          vtrack.enabled = false;vtrack.onended = null; vtrack.stop();
        });
      }
      if (audio && streamObj.audioStream && closeCurrAStream){
        streamObj.audioStream.getAudioTracks().forEach((atrack) => {
          atrack.enabled = false;atrack.onended = null; atrack.stop();
        });
      }
    }

    if (streamObj.pc && streamObj.pc.peerConnection &&
        ((audio && !sender_audio_track_found) || (video && !sender_video_track_found))) {
      streamObj.pc.peerConnection.getSenders().forEach((sender, index) => {
        if (!sender.track && newStream) {
          if (audio && !sender_audio_track_found && ((spec.audio.trackIndex !== undefined) && (index === spec.audio.trackIndex))) {
            sender_audio_track_found = true;
            newStream.getAudioTracks().forEach((atrack) => {
              atrack.enabled = true; sender.replaceTrack(atrack);
            });
          }
          if (video && !sender_video_track_found && ((spec.video.trackIndex !== undefined) && (index === spec.video.trackIndex))) {
            sender_video_track_found = true;
            newStream.getVideoTracks().forEach((vtrack) => {
              vtrack.enabled = true; sender.replaceTrack(vtrack);
            });
          }
        }
      });

      if ((audio && !sender_audio_track_found) || (video && !sender_video_track_found)) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Error: Not finding sender track::  audio: ${audio} found: ${sender_audio_track_found
          } index: ${spec.audio.trackIndex} video: ${video} found: ${sender_video_track_found
          } index: ${spec.video.trackIndex}`);
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: (`replaceNewMediaStreamTrack - Not finding sender track::  audio: ${audio} found: ${sender_audio_track_found} index: ${spec.audio.trackIndex} video: ${video} found: ${sender_video_track_found} index: ${spec.video.trackIndex}`) });
        streamObj.pc.peerConnection.getSenders().forEach((sender, index) => {
          const kind = sender.track ? sender.track.kind : 'none';
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`index : ${index} sender.track: ${sender.track} kind : ${kind}`);
        });
      }
    }
    //streamObj.stream.getTracks().forEach(function(track){track.onended = null;track.stop();});
  };

  const shouldDisplayFrozenImage = (imageOnVideoMute, remoteClientId, userMute) => (imageOnVideoMute && ((currentRemoteClientId == remoteClientId) || (currentRemoteClientId == 'none')) &&
    ((currentMediaType == 'video') || (currentMediaType == 'audiovideo') || (currentImageDisplay && !userMute)));

  that.getPlayerId = function (room = null) {
    let id = that.getID();
    // console.log('Player id rooms: ', room, that.room);
    let _room = room ? room : that.room;
    let roomType = _room && _room.roomSettings && _room.roomSettings.room_type
      ? _room.roomSettings.room_type
      : null;

    let isBreakOutString = roomType === 'breakout-room' ? `br_${_room.roomID}_` : '';

    return {
      'stream': `${isBreakOutString}stream${id}`,
      'player': `${isBreakOutString}player_${id}`
    }
  }

  that.reloadPlayer = function (talkerInfo, imageOnVideoMute) {
    const newMediaType = talkerInfo.mediatype;
    const remoteClientId = talkerInfo.clientId;
    if ((currentMediaType == newMediaType) && !currentImageDisplay && (!imageOnVideoMute || currentVideoMuteReason == 'none' || currentVideoMuteReason == talkerInfo.reason)) {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(`reloadPlayer() id : ${that.getID()} no change in media type: ${newMediaType}`);
      //if first time, set the muted options
      if (currentRemoteClientId === 'none') {
        switch (currentMediaType) {
          case 'audio':
          case 'audioOnly':
            audioMuted = false;
            videoMuted = true;
            break;
          case 'video':
            audioMuted = true;
            videoMuted = false;
            break;
          case 'audiovideo':
            audioMuted = videoMuted = false;
            break;
          default:
            audioMuted = videoMuted = true;
            break;
        }
      }
      currentRemoteClientId = remoteClientId;
      currentActiveTalkerList = {
        talkerInfo: JSON.parse(JSON.stringify(talkerInfo)),
        imageOnVideoMute,
      };
      return;
    }
    __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(`reloadPlayer() streamId: ${that.getID()} mediatype:( ${newMediaType} , ${currentMediaType} ), clientId:( ${remoteClientId} , ${currentRemoteClientId} ), reason:( ${talkerInfo.reason} , ${currentVideoMuteReason} ) ` +
      ` imageOnVideoMute: ${imageOnVideoMute}`);
    const id = that.getID();
    let elementID = that.getPlayerId();

    if (document.querySelector(`#${elementID.stream}`) !== undefined && document.querySelector(`#${elementID.stream}`) !== null) {
      var domIds = document.querySelectorAll('#' + elementID.stream);
      let stremAttached = false;

      domIds.forEach(streamElement => {
        try {
          switch (newMediaType) {
            case 'audio':
              //show prevous image incase of video mute TODO - if user mutes, show blank ?.
              currentVideoMuteReason = talkerInfo.reason;
              if (shouldDisplayFrozenImage(imageOnVideoMute, remoteClientId, (talkerInfo.reason == 'user'))) {
                //if transition from video-> audio, audio track need to be added
                if (that.mediaStream && that.mediaStream.getAudioTracks().length == 0) {
                  that.stream.getAudioTracks().forEach(function (track) {
                    that.mediaStream.addTrack(track);
                  });
                }
                currentImageDisplay = true;
                stremAttached = true;
                audioMuted = false;
                videoMuted = true;
                break;
              }
            case 'audioOnly':
              if (that.audioStream) {
                streamElement.srcObject = that.audioStream;
                currentImageDisplay = false;
                stremAttached = true;
                audioMuted = false;
                videoMuted = true;
              } else {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`reloadPlayer() failed id : ${that.getID()} audiostream null ` +
                  `medtype - curr: ${currentMediaType} new: ${newMediaType}`);
              }
              break;
            case 'video':
              if (that.mediaStream) {
                if (currentMediaType == 'audiovideo') {
                  if (that.mediaStream.getVideoTracks().length == 0) {
                    that.stream.getVideoTracks().forEach(function (track) {
                      that.mediaStream.addTrack(track);
                    });
                  }
                  if (that.mediaStream.getAudioTracks().length != 0) {
                    that.mediaStream.getAudioTracks().forEach(function (track) {
                      that.mediaStream.removeTrack(track);
                    });
                  }
                } else {
                  streamElement.srcObject = that.mediaStream;
                }
                currentImageDisplay = false;
                currentVideoMuteReason = 'none';
                stremAttached = true;
                audioMuted = true;
                videoMuted = false;
              } else {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`reloadPlayer() failed id : ${that.getID()} videostream null, medtype - curr: ${currentMediaType} new: ${newMediaType}`);
                //EL.error('stream-event', customEvents.event_general_failed, { message: (`reloadPlayer() failed id : ${that.getID()} videostream null, medtype - curr: ${currentMediaType} new: ${newMediaType}`) });
              }
              break;
            case 'audiovideo':
              if (that.mediaStream) {
                if (that.mediaStream.getAudioTracks().length == 0) {
                  that.stream.getAudioTracks().forEach(function (track) {
                    that.mediaStream.addTrack(track);
                  });
                }
                if (that.mediaStream.getVideoTracks().length == 0) {
                  that.stream.getVideoTracks().forEach(function (track) {
                    that.mediaStream.addTrack(track);
                  });
                }
                if ((currentMediaType != 'video') || (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'safari')) {
                  streamElement.srcObject = that.mediaStream;
                }
                currentImageDisplay = false;
                currentVideoMuteReason = 'none';
                stremAttached = true;
                audioMuted = videoMuted = false;
              } else {
                __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`reloadPlayer() failed id : ${that.getID()} stream null, medtype - curr: ${currentMediaType} new: ${newMediaType}`);
                //EL.error('stream-event', customEvents.event_general_failed, { message: (`reloadPlayer() failed id : ${that.getID()} stream null, medtype - curr: ${currentMediaType} new: ${newMediaType}`) });
              }
              break;
            default:
              currentVideoMuteReason = talkerInfo.reason;
              audioMuted = videoMuted = true;
              if (shouldDisplayFrozenImage(imageOnVideoMute, remoteClientId, (talkerInfo.reason == 'user'))) {
                currentImageDisplay = true;
                stremAttached = true;
                break;
              }
              streamElement.srcObject = null;
              currentImageDisplay = false;
              stremAttached = true;
              break;
          }
        } catch (error) {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`reloadPlayer() id : ${that.getID()} NULL set medtype - curr: ${currentMediaType} new: ${newMediaType}`);
          //EL.error('stream-event', customEvents.event_general_failed, { message: (`reloadPlayer() id : ${that.getID()} NULL set medtype - curr: ${currentMediaType} new: ${newMediaType}`) });
        }
      });
      if (stremAttached) {
        currentMediaType = newMediaType;
        currentRemoteClientId = remoteClientId;
      }
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`reloadPlayer() id : ${that.getID()} ID selector null medtype - curr: ${currentMediaType} new: ${newMediaType} storing AT req`);
      //EL.error('stream-event', customEvents.event_general_failed, { message: (`reloadPlayer() id : ${that.getID()} ID selector null medtype - curr: ${currentMediaType} new: ${newMediaType} storing AT req`) });
    }
    currentActiveTalkerList = {
      talkerInfo: JSON.parse(JSON.stringify(talkerInfo)),
      imageOnVideoMute,
    };
  };

  that.setBandwidthAlert = (arg) => {
    let lang;
    const streamId = that.getID();
    if (!that.player) { return; }
    if (that.abwdEnabled === true) {
      if (arg.bw === 'low') {
        if (that.abwdNotification === 'sdk') {
          that.player.setBwAlert(true, arg.type, arg.name);
        } else {
          //Fire a stream event to app.
          let Msg = '';
          if (arg.type === 'subscriber') {
            Msg = 'subscriber low';
          } else {
            Msg = `${arg.name} publisher low`;
          }
          //console.log('Pusing the abwd event to server');
          const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({
            type: 'bw-alert',
            stream: that,
            stream_type:arg.type,
            msg: Msg,
          });
          that.dispatchEvent(streamEvent);
        }
      } else if (that.abwdNotification === 'sdk') {
        that.player.setBwAlert(false);
      } else {
        const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({
          type: 'bw-restored',
          stream: that,
        });
        //console.log('Pusing the abwd restore event to server');
        that.dispatchEvent(streamEvent);
      }
    }
  };


  that.setVideoMutedMessage = (arg) => {
    if (that.player == null) return;
    if (arg.videomuted === true && arg.reason === 'bw') {
      that.videoMutedDueToBw = true;
      that.player.setVideoMutedMsg(arg);
    } else if (that.videoMutedDueToBw === true) {
      that.player.setVideoMutedMsg(arg);
    }
  };

  const attachStreamOnPlayerDivs = (stream2Attach) => {
    for (let i = 0; i < that.playerDivs.length; i++) {
      const elem = document.getElementById(that.playerDivs[i].elementId);
      if (elem) {
        const video_tag = elem.querySelectorAll('video');
        if (video_tag.length > 0) {
          const id = video_tag[0].id;
          const domIds = document.querySelectorAll(`#${id}`);
          domIds.forEach((streamElement) => {
            try {
              streamElement.srcObject = stream2Attach;
            } catch (error) {
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Exception:: attachStreamOnPlayerDivs() streamId: ${that.getID()} error: ${error}`);
              //EL.error('stream-event', customEvents.event_general_failed, { message: (`attachStreamOnPlayerDivs() streamId: ${that.getID()} error: ${error}`) });
            }
          });
        }
      }
    }
  };

  that.muteSubscriberStreamVideo = (enable) => {
    if (that.stream && !that.local) {
      that.stream.getVideoTracks().forEach((track) => {
        track.enabled = !enable;
      });
    }
  };

  //reconnection case
  that.updateVideo = (id, player) => {
    let elementID = that.getPlayerId();

    if (document.querySelector(`#${elementID.stream}`) !== undefined &&
        document.querySelector(`#${elementID.stream}`) !== null) {
      if (that.player == undefined && player ) that.player = player;
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Player element exists and playing the video', `${elementID.stream}`);
      if (that.ifScreen() || that.ifCanvas()) that.htmlPlay(`${elementID.stream}`);
      else if(!that.local && that.player && that.player.video) that.player.video.srcObject = that.stream;
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Player element does not exist');
    //EL.error('stream-event', customEvents.event_general_failed, { message: ('updateVideo - Player element does not exist') });
    }
  };

  that.play = (elementID, optionsInput) => {
    if(typeof optionsInput === 'object' && optionsInput.hasOwnProperty('player'))
    {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug(`Element ID is ${elementID}`);
      const options = optionsInput || {};
      that.elementID = elementID;
      let player;
      if (optionsInput.player && optionsInput.player.abwd) {
        if (optionsInput.player.abwd.enabled !== undefined) {
          that.abwdEnabled = optionsInput.player.abwd.enabled;
        }
        if (that.abwdEnabled === true) {
          if (optionsInput.player.abwd.notification) {
            that.abwdNotification = optionsInput.player.abwd.notification;
            if (that.abwdNotification === 'sdk') {
              if (optionsInput.player.abwd.language !== undefined) {
                if (optionsInput.player.abwd.language === 'en' || optionsInput.player.abwd.language === 'zh') {
                  that.abwdLanguage = optionsInput.player.abwd.language;
                } else {
                  that.abwdLanguage = 'en';
                }
              }
            }
          }
        }
      }
      //only one player is required. currently only Video player is used
      // TODO :remove both players and have single player - media player
      if ((that.ifVideo() || that.ifScreen()) || that.audioOnly || that.ifAudio()) {
        // Draw on HTML
        if (elementID !== undefined && (document.getElementById(elementID) !== null)) {
          /*this section of code is responsible to create and play the
          stream in dynamic video tag appended under <div></div>*/
          //-------------------------------------------
          if (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
            const vid = document.getElementById(elementID);
            let video = document.getElementById(elementID);
            if (vid.nodeName !== 'VIDEO') {
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('not video tag');
              video = document.createElement('video');
              video.setAttribute('height', vid.getAttribute('height'));
              video.setAttribute('width', vid.getAttribute('width'));
              vid.appendChild(video);
            }
            that.attachMediaStream(video, that.stream);
          } else {
            const extraPlayerOptions = { autoplay: true };
            if (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'safari') extraPlayerOptions.playsinline = true;
            player = Object(__WEBPACK_IMPORTED_MODULE_2__views_VideoPlayer__["a" /* default */])({
              id: that.getID(),
              stream: that, elementID,
              options, extraPlayerOptions,
              vroom: that.room ? that.room : null,
              videoSource: that.local ? that.inputMediaSource.video[that.inputMediaSource.video.selected] : that.stream,
            });
            if (that.local) player.video.muted = true;
            else that.playerDivs = [];
            that.player = player;
            that.showing = true;
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info ("that.play() video player successfull streamId: " + that.getID());
          }
          that.playerDivs.push({ elementId: elementID, options: optionsInput });
          currentMediaType = 'audiovideo';
          if (currentActiveTalkerList !== undefined) {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug('stream.play currentActiveTalkerList : calling reload player()');
            that.reloadPlayer(currentActiveTalkerList.talkerInfo, currentActiveTalkerList.imageOnVideoMute);
          }
          if (!that.local && that.room != undefined &&
              (that.room.speakerInfo.id != undefined || that.room.speakerInfo.volume != 1)) {
            that.setSpeaker(that.room.speakerInfo.id, that.room.speakerInfo.volume);
          }
        } else {
          __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('that.play() faild, streamId: ' + that.getID() + ' error: ' + ' Element not found ');
        }
      } else if (that.ifAudio() || that.audioOnly) {
        player = Object(__WEBPACK_IMPORTED_MODULE_1__views_AudioPlayer__["a" /* default */])({
          id: that.getID(),
          stream: that,
          elementID,
          options,
          vroom: that.room ? that.room : null
        });
        if (that.local) player.audio.muted = true;
        else that.playerDivs = [];


        that.player = player;
        that.showing = true;
        that.playerDivs.push({ elementId: elementID, options: optionsInput });
        currentMediaType = 'audio';
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info ("that.play() audio player successfull streamId: " + that.getID());
      }else {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error ("that.play() failed invalid stream streamId: " + that.getID());
      }
      if (that.reload) {
        delete that.reload;
      }
      if (that.room !== undefined) {
        // if stats are enabled the show the stats UI on player
        if (that.room.subscribeSessionStats === true) {
          that.ShowSessionStats(true);
        } else {
          that.ShowSessionStats(false);
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('that.play() failed streamId: ' + that.getID() + ' room not allocated to stream , stats UI not shown');
      }
    }
    else{
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('play() invalid param - callback/RoomDefinition');
    }
  };
  that.resetMediaConfiguration = function (mediaConfiguration) {
    that.pc.resetSDP(mediaConfiguration);
  };

  that.htmlPlay = (elementID, optionsInput) => {
    const options = optionsInput || {};
    that.elementID = elementID;
    let player;
    if (that.ifVideo() || that.ifScreen()) {
      // Draw on HTML
      if (elementID !== undefined) {
        /*this section of code is responsible to create and play the
        stream in dynamic video tag appended under <div></div>*/
        //-------------------------------------------
        /*pass the video tag Id here to play the stream in video tag*/
        //-----------------------------------------------------
        // reconnection case handle duplicate video
        /*    var domId=document.getElementById(elementID);
            //------------------------------------------------
                try {
                    domId.srcObject = that.stream;
                } catch (error) {
                    domId.src = URL.createObjectURL(that.stream);
                }
                domId.play().then(() => {

            }).catch((error) => {
            });*/

        const domIds = document.querySelectorAll(`#${elementID}`);
        domIds.forEach((streamElement) => {
          try {
            streamElement.srcObject = that.local ? that.videoStream : that.stream;
            if (that.player !== undefined) that.player.video.srcObject = streamElement.srcObject;
          } catch (error) {
            streamElement.src = URL.createObjectURL(that.local ? that.videoStream : that.stream);
          }
          streamElement.play().then(() => {

          }).catch((error) => {
            __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Error playing video stream: ${error}`);
          //EL.error('stream-event', customEvents.event_general_failed, { message: (`Error playing video stream: ${error}`) });
          });
        });
      }
    }
  };

  // ************************************
  // Public function: stop()
  // It destroys the player object if its already being played
  // ************************************

  that.stop = (elementID) => {
    if (that.showing) {
      if (elementID != undefined){
        //remove element from the playerdivs array
        that.playerDivs = that.playerDivs.filter(entry=>entry.elementId != elementID);
        if (!that.playerDivs.length){
          return;
        }
      }
      if (that.player !== undefined) {
        that.player.destroy();
        that.showing = false;
      }
    }
  };

  that.show = that.play;
  that.hide = that.stop;
  /* ####this is the temporary mapping between the events call of#### */
  /*that.hasAudio = that.ifAudio;
  that.hasVideo = that.ifVideo;
  that.hasData = that.ifData;
  that.isExternal = that.ifExternal;
  that.hasMedia = that.ifMedia;
  that.hasScreen = that.ifScreen;*/


  /************************************
  //Author:Sohom
  //Description:To take a snapshot of video frame and to return a canvas object.
  // Public function: getVideoFrameCanvas()
  //
   ************************************/

  const getVideoFrameCanvas = (domHandle) => {
    if (that.player !== undefined && that.stream !== undefined) {
      const video = that.player.video;
      const style = document.defaultView.getComputedStyle(video);
      const width = parseInt(style.getPropertyValue('width'), 10);
      const height = parseInt(style.getPropertyValue('height'), 10);
      const left = parseInt(style.getPropertyValue('left'), 10);
      const top = parseInt(style.getPropertyValue('top'), 10);

      let div;
      if (typeof that.elementID === 'object' && typeof that.elementID.appendChild === 'function') {
        div = that.elementID;
      } else {
        div = document.getElementById(that.elementID);
      }

      const divStyle = document.defaultView.getComputedStyle(div);
      const divWidth = parseInt(divStyle.getPropertyValue('width'), 10);
      const divHeight = parseInt(divStyle.getPropertyValue('height'), 10);
      let canvas;
      if (!document.getElementById(domHandle)) {
        canvas = document.createElement('canvas');
        canvas.id = domHandle;
        canvas.width = divWidth;
        canvas.height = divHeight;
        canvas.className = 'canvas_input';
        canvas.setAttribute('style', 'position: absolute;top: 15%;left: 45%;z-index: 897;');
        document.body.appendChild(canvas);
      } else {
        canvas = document.getElementById(domHandle);
      }
      that.inputContext = canvas.getContext('2d');
      updateCanvas(height, width);
      return canvas;
    }
    return null;
  };

  const updateCanvas = (height, width) => {
    that.inputContext.drawImage(that.player.video, 0, 0, width, height);
    // requestAnimationFrame( updateCanvas );
  };

  /************************************
   * Author:Sohom
   * Description:
  // Public function: getVideoFrameURL()
  // To take a snapshot of video frame, the snapshot is saved and a URL is returned
   ************************************/

  that.getVideoFrameURL = (format) => {
    const canvas = getVideoFrameCanvas();
    if (canvas !== null) {
      if (format) {
        return canvas.toDataURL(...format);
      }
      return canvas.toDataURL();
    }
    return null;
  };


  /************************************
   * Author:Sohom
   * Description:
  // Public function: getVideoFrameImage()
  // To take a snapshot of video frame and to return an Image in raw format.
  ************************************/

  that.getVideoFrameImage = (domHandle) => {
    const canvas = getVideoFrameCanvas(domHandle);
    if (canvas !== null) {
      return canvas.getContext('2d').getImageData(10, 10, canvas.width, canvas.height);
    }
    return null;
  };


  // ************************************
  // Public function: checkOptions()
  // Check inconsistensy in Options/Attributes
  // ************************************

  that.checkOptions = (configInput, isUpdate) => {
    const config = configInput;

    // TODO: Check for any incompatible options
    if (isUpdate === true) { // We are updating the stream
      if (config.audio || config.screen) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].warning('Error! Cannot update type of subscription');
        config.audio = undefined;
        config.screen = undefined;
      }
    } else if (that.local === false) { // check what we can subscribe to
      if (config.video === true && that.ifVideo() === false) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].warning('Error! Stream doesn\'t have Video Track. Can\'t subscribe to Video');
        config.video = false;
      }
      if (config.audio === true && that.ifAudio() === false) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].warning('Error! Stream doesn\'t have Audio Track. Can\'t subscribe to Audio');
        config.audio = false;
      }
    }
    if (that.local === false) {
      if (!that.ifVideo() && (config.slideShowMode === true)) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].warning('Error! Stream doesn\'t have Video Track. Cannot enable slideShowMode. Check parameters');
        config.slideShowMode = false;
      }
    }
  };


  // ************************************
  // Public function: checkOptions()
  // Check inconsistensy in Options/Attributes
  // ************************************
  const muteStreamAudio = (enable, delay, callback = () => { }) => {
    console.log("Muting the stream : enable " + enable);
    if (!that.negotiatedMedia.audio) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('muteStreamAudio - Stream not found') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
      return;
    }
    if (enable === audioMuted) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('muteStreamAudio - MediaDevice state is already in same state') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
      return;
    }
    if (setTrasactionIfNotExists('setMicrophoneTrack') == false) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('muteStreamAudio - Previous similar request in process') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
      return;
    }
    //console.log("Muting the stream calling setAudioTrack");

    const setAudioTrack = (enable, callback) => {
      try {
        let trackStateEnded = false;
        if (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'safari') {
          const audioSender = that.pc.peerConnection.getSenders().find(s => (s.track && s.track.kind === "audio") || s.track === null);
          if(audioSender) {
            that.audioStream.getAudioTracks().forEach((track) => {
              track.enabled = !enable;
              if (!enable && track.readyState != "live"){
                console.log (" setAudioTrack(): safari trackstate: ended" );
                trackStateEnded = true;
              }else{
                //console.log (" setAudioTrack(): safari trackstate: live" );
                audioSender.replaceTrack(enable ? null : that.audioStream.getAudioTracks()[0]);
              }
            });
          }
        } else {
          that.audioStream.getAudioTracks().forEach((track) => {
            track.enabled = !enable;
            if (!trackStateEnded && track.readyState == "ended") trackStateEnded = true;
            console.log (" setAudioTrack(): trackstate: ended" );
          });
        }
        //console.log("==Muting the stream  trackstateended "+ trackStateEnded);
        audioMuted = enable;
        resetTransaction('setMicrophoneTrack');
        //console.log ("unmute audio check enable: " + enable + " trackStateEnded: " + trackStateEnded );
        if (that.selectedMicId != undefined) console.log ("that.selectedMicId: " + that.selectedMicId);
        if (!enable) {
          if (trackStateEnded){
            let micId = (that.selectedMicId != undefined) ? that.selectedMicId : spec.audio.deviceId;
            if (micId){
              setMediaDevicesTrack(that, micId, undefined, true, (status) => {
                console.log ("setMediaDevicesTrack : audio " + " status: " + status);
                if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result){
                  if (__WEBPACK_IMPORTED_MODULE_3__Pair__["a" /* default */].browserEngineCheck() === 'safari') {
                //console.log ("setMediaDevicesTrack : audio safri setting track " + " status: " + status);
                    const audioSender =
                      that.pc.peerConnection.getSenders().find(s => (s.track && s.track.kind === "audio") || s.track === null);
                    audioSender.replaceTrack(that.audioStream.getAudioTracks()[0]);
                    audioMuted = enable;
                  }
                  callback(status);
                }
              });
              return;
            }
              // in some cases, continious mute/unmute causes stream track state to "ended" state.
              //Try fresh get user media to retry
              //console.log ("setAudioTrack() : trackStateEnded sending event : " + trackStateEnded);
              __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event',__WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed,{message: (`muteStreamAudio - error - stream ended`) });
              callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1191);
              return;
          }
        }
        audioMuted = enable;
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].info('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_success, { message: ('muteStreamAudio - success') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        /* if (enable){
          if (that.audioStream)
            that.audioStream.getAudioTracks().forEach(function(track){track.enabled = false;});
          replaceNewMediaStreamTrack (that, true, false,null);
          audioMuted = enable;
          callback(customErrors.error_000);
        }else{
          setMediaDevicesTrack(that, (spec.audio.deviceId ? spec.audio.deviceId : "none"), undefined,(status) => {
            if (status.result === customErrors.error_000.result) audioMuted = enable;
            callback(status);
          });
        }*/
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error(`Excpetion happend : ${e}`);
        resetTransaction('setMicrophoneTrack');
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: (`muteStreamAudio - error - ${e}`) });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1150);
      }
    };
    if (!delay) setAudioTrack(enable, callback);
    else setTimeout(setAudioTrack, delay, enable, callback);
  };

  const muteStreamVideo = (enable, delay, force, callback = () => { }) => {
    if (enable && !that.negotiatedMedia.video && !force) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('muteStreamVideo - Stream not found') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
      return;
    }
    if (enable === videoMuted && !force) {
      __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed, { message: ('muteStreamVideo - MediaDevice state is already in same state') });
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
      return;
    }
    if (setTrasactionIfNotExists('setCameraTrack') == false) {
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
      return;
    }
    console.log("muteSTreamVideo() enable: " + enable + " localVideoOn: " + localVideoOn);
    const muteVideoTrack = (enable, callback) => {
      try {
        if (enable) {
          //let closeLocalStream = (that.inputMediaSource.video.selected == 'self') && !localVideoOn;
          let closeLocalStream = !localVideoOn;
          replaceNewMediaStreamTrack(that, false, true, null, closeLocalStream);
          videoMuted = enable;
          resetTransaction('setCameraTrack');
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        } else if (!localVideoOn){
          const cam = {};
          if (spec.video.deviceId != undefined) cam.deviceId = spec.video.deviceId;
          else if (spec.video.facingMode !== undefined && __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile') {
            cam.facingMode = spec.video.facingMode;
          }
          if (cam.deviceId == undefined && cam.facingMode == undefined){
            cam.deviceId = 'none';
          }
          setMediaDevicesTrack(that, undefined, cam, true, (status) => {
            if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) videoMuted = enable;
            else {
              const myData = __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.getLocalStorageItem('vcxRTCLib-log');
              if (myData != null) {
                const data = JSON.parse(myData);
                __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', enable?__WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_mute_self_video_failed:
                         __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_unmute_self_video_failed, { message: data});
              }
            }
            resetTransaction('setCameraTrack');
            callback(status);
          });
        }else {
            videoMuted = enable;
            if (that.pc && that.pc.peerConnection) {
              replaceNewMediaStreamTrack(that, false, true, that.videoStream, false);
            }
            resetTransaction('setCameraTrack');
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000 );
        }
      } catch (e) {
        console.log(`Excpetion happend : ${e}`);
        resetTransaction('setCameraTrack');
        const myData = __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.getLocalStorageItem('vcxRTCLib-log');
        if (myData != null) {
          const data = JSON.parse(myData);
          __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].error('stream-event', enable?__WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_mute_self_video_failed:
                   __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_unmute_self_video_failed, { message: data});
        }
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1150);
      }
    };
    if (!delay) muteVideoTrack(enable, callback);
    else setTimeout(muteVideoTrack, delay, enable, callback);
  };
  // ************************************
  // Public function: muteAudio()
  // To mute Audio at local end-point. Callback can be defined at application level
  // ************************************

  that.muteAudio = (callback = () => { }, raiseEvent = true, delay = 0, selfSet = true, pause = false) => {
    if (typeof callback === 'function') {
      console.log("muteAudio() selfSet : " + selfSet + " selfMuteAudio: " + that.selfMuteAudio + " hardAudioMuted: " +
                  that.hardAudioMuted + " audioMuted: " + audioMuted + " paused: " + that.selfPausedAudio +
                  " config.audioMuted: " + that.config.audioMuted );
      if ((selfSet && that.selfMuteAudio) || (!selfSet && (that.hardAudioMuted || that.selfPausedAudio))) {
        if (pause === true) that.selfPausedAudio = true; //Just to make sure that room doesnt get unmuted in case of hard mute is turned off.
        if (raiseEvent) that.sendEvent('user-audio-muted');
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
        return;
      }
      if ((that.pc === undefined || that.pc == null) && that.audioStream != undefined) {
        that.audioStream.getAudioTracks().forEach((atrack) => { atrack.onended = null; atrack.enabled = false; });
        audioMuted = true;
        if (selfSet) {
          that.selfMuteAudio = true;
          that.config.audioMuted = true;
        }else if (pause) that.selfPausedAudio = true;
        else that.hardAudioMuted = true;
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        return;
      }
      muteStreamAudio(true, delay, (resp) => {
        if ((resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) || (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177.result)) {
          if (selfSet) that.selfMuteAudio = true;
          else if (pause) that.selfPausedAudio = true;
          else that.hardAudioMuted = true;
          if (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result && raiseEvent) that.sendEvent('user-audio-muted');
          else if (!raiseEvent) resp = __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000; //already selfmuted but now remotemute and viceversa
        }
        callback(resp);
      });
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('muteAudio() invalid param - callback');
    }
  };
  that.setMediaDeviceMuteState = (isMuteOn, audio, video, raiseEvent, callback) => {
    try {
      if (audio) {
        if (isMuteOn === audioMuted) {
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
          return;
        }
        /*
                  that.pc.peerConnection.getSenders().forEach(function(sender){
                    if(sender.track && sender.track.kind === 'audio'){
                      const parameters = sender.getParameters();
                      if ((parameters != undefined ) && (parameters.encodings != undefined)){
                        for (var cnt=0; cnt < parameters.encodings.length; cnt++){
                          Logger.error("setting encoding cnt " + !isMuteOn);
                          parameters.encodings[cnt].active = !isMuteOn;
                        }
                        sender.setParameters(parameters);
                      }
                    }
                  });*/
        that.audioStream.getAudioTracks().forEach((track) => { track.enabled = !isMuteOn; });
        audioMuted = isMuteOn;
        if (raiseEvent) that.sendEvent(audioMuted ? 'user-audio-muted' : 'user-audio-unmuted');
      }
      if (video) {
        if (isMuteOn === videoMuted) {
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
          return;
        }
        that.stream.getVideoTracks().forEach((track) => { track.enabled = !isMuteOn; });
        videoMuted = isMuteOn;
        if (raiseEvent) that.sendEvent(videoMuted ? 'user-video-muted' : 'user-video-unmuted');
      }
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
    } catch (e) {
      console.log(`Excpetion happend : ${e}`);
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1150);
    }
  };

  that.muteAudioNotSelf = (callback = () => { }, raiseEvent) => {
    // that.sgelfMuteAudio = true;
    muteStreamAudio(true, 0, callback);
    if ((raiseEvent === undefined) || (raiseEvent !== false)) that.sendEvent('user-audio-muted');
  };

  const handleDataAvailable = (event) => {
    if (event.data && event.data.size > 0) {
      that.recordedBlobs.push(event.data);
    }
  };
  that.startLocalRecord = (callback = () => { }) => {
    if (!that.mediaRecorder) {
      try {
        //let options = {mimeType: 'video/webm;codecs=vp8'};
        const options = { mimeType: 'video/webm' };
        that.mediaRecorder = new MediaRecorder(that.stream, options);
        that.mediaRecorder.ondataavailable = handleDataAvailable;
        that.recordedBlobs = [];
        that.mediaRecorder.start(10);
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Exception while creating MediaRecorder:', e);
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      }
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Recording started already:');
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1174);
    }
  };
  that.stopLocalRecord = (callback = () => { }) => {
    if (that.mediaRecorder && that.recordedBlobs.length > 0) {
      const today = new Date();
      const date = `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()}`;
      const time = `${today.getHours()}:${today.getMinutes()}:${today.getSeconds()}`;
      const fileName = `stream_${that.getID()}_${date}::${time}.webm`;
      const blob = new Blob(that.recordedBlobs, { type: 'video/webm' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = fileName;
      a.click();
      window.URL.revokeObjectURL(url);
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
    } else {
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1175);
    }
    that.mediaRecorder = undefined;
    that.recordedBlobs = [];
  };

  that.sendEvent = (type) => {
    if (that.room) {
      that.room.socket.sendEvent(type, (result) => {
      });
    }
  };
  that.sendMessage = (type, options, callback = () => { }) => {
    if (that.room) {
      that.room.socket.emitEvent(type, options, (result) => {
        callback(result);
      });
    }
  };

  // ************************************
  // Public function: unmuteAudio()
  // To unmute Audio at local end-point. Callback can be defined at application level
  // ************************************

  that.unmuteAudio = (callback = () => { }, raiseEvent = true, delay = 0, selfSet = true, pause = false) => {
    if (typeof callback === 'function') {
      console.log("unmuteAudio() selfSet : " + selfSet + " selfMuteAudio: " + that.selfMuteAudio + " hardAudioMuted: " +
                  that.hardAudioMuted + " audioMuted: " + audioMuted + " paused: " + that.selfPausedAudio +
                  " config.audioMuted: " + that.config.audioMuted );
      if ((selfSet && !that.selfMuteAudio && that.hardAudioMuted && !that.selfPausedAudio) ||
          (!selfSet && !(that.hardAudioMuted || that.selfPausedAudio))) {
        console.log (" that.unmuteAudio() error177: selfSet: " + selfSet + "  that.selfMuteAudio: " + that.selfMuteAudio +
                    " that.hardAudioMuted: " + that.hardAudioMuted + " that.selfPausedAudio: "+ that.selfPausedAudio );
        if (raiseEvent && !that.selfMuteAudio && !that.hardAudioMuted) that.sendEvent('user-audio-unmuted');
        if(that.hardAudioMuted) { callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1201); return;}
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
        return;
      }
      if (!selfSet || !that.hardAudioMuted || that.selfPausedAudio || (that.room && that.room.isModerator())) {
        if (!selfSet && that.selfMuteAudio) {
          // if remote unmute but self muted, reset hard. retruning success
          that.hardAudioMuted = false;
          if (pause) that.selfPausedAudio = false;
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
          return;
        }
        if(selfSet && that.selfMuteAudio && that.hardAudioMuted) {
          that.selfMuteAudio = false;
          if (pause) that.selfPausedAudio = false;
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
          return;
        }
        if (pendingUserReqs['switchMicrophone'] != undefined){
          let info = pendingUserReqs['switchMicrophone'];
          that.switchMicrophone(info.newStream,info.deviceInfo,(resp) => {
            delete pendingUserReqs['switchMicrophone'];
            if (resp.result == undefined){
              callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
            }else{
              that.unmuteAudio(callback, raiseEvent, delay, selfSet, pause);
            }
          }, false);
          return;
        }
        if ((that.pc === undefined || that.pc == null) && that.audioStream != undefined) {
          that.audioStream.getAudioTracks().forEach((atrack) => { atrack.enabled = true;});
          if(that.config.audioMuted === true) that.config.audioMuted = false;
          audioMuted = false;
          if (selfSet) that.selfMuteAudio = false;
          else if (pause) that.selfPausedAudio = false;
          else that.hardAudioMuted = false;
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
          return;
        }
        muteStreamAudio(false, delay, (resp) => {
          if ((resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) || (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177.result)) {
            if (selfSet) that.selfMuteAudio = false;
            else if (pause) that.selfPausedAudio = false;
            else that.hardAudioMuted = false;
            if (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result && raiseEvent) that.sendEvent('user-audio-unmuted');
            else if (!raiseEvent) resp = __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000; //already selfunmuted but now remoteunmute and viceversa
          }
          callback(resp);
        });
      } else {
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1176);
      }
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('unmuteAudio() invalid param - callback');
    }
  };

  that.hardMuteAudio = (callback = () => { }) => {
    if (that.room && !that.local) {
      that.sendMessage('hardmute-user-audio', { clientId: that.clientId });
    }
  };
  that.hardUnmuteAudio = (callback = () => { }) => {
    if (that.room && !that.local) {
      that.sendMessage('hardunmute-user-audio', { clientId: that.clientId });
    }
  };
  that.hardMuteVideo = (callback = () => { }) => {
    if (that.room && !that.local) {
      that.sendMessage('hardmute-user-video', { clientId: that.clientId });
    }
  };
  that.hardUnmuteVideo = (callback = () => { }) => {
    if (that.room && !that.local) {
      that.sendMessage('hardunmute-user-video', { clientId: that.clientId });
    }
  };
  // ************************************
  // Public function: muteVideo()
  // To mute Video at local end-point. Callback can be defined at application level
  // ************************************
  that.muteNonATPubVideo = (callback = () => { }) => {
    if (that.videoStream) {
      that.ATVideoMuted = true;
      that.videoStream.getVideoTracks().forEach((track) => {
        track.enabled = false;
      });
    }
  };

  that.unmuteNonATPubVideo = (callback = () => { }) => {
    if (that.videoStream) {
      if (that.hardAudioMuted === false && that.selfMuteVideo === false && that.ATVideoMuted === true) {
        that.ATVideoMuted = false;
        that.videoStream.getVideoTracks().forEach((track) => {
          track.enabled = true;
        });
      }
    }
  };

  that.muteVideo = (callback = () =>{}, raiseEvent = true, delay = 0,
                    selfSet = true, onlySoftMute = false, pause = false, force=false, audioOnlyMode = false) => {
    if (typeof callback === 'function') {
      console.log(`SelfSet:${selfSet}selfMuteVideo${that.selfMuteVideo}selfPausedVideo:${that.selfPausedVideo}`);
      if ((selfSet && that.selfMuteVideo) || (!selfSet && (that.hardVideoMuted || that.selfPausedVideo || that.audioOnlyModeEnabled))) {
        if (pause) that.selfPausedVideo = true;
        if(audioOnlyMode) that.audioOnlyModeEnabled = true;
        if (raiseEvent) that.sendEvent('user-video-muted');
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
        return;
      }
      if ((that.pc === undefined || that.pc == null )&& that.room != undefined && that.videoStream != undefined) {
        if(!localVideoOn)
          that.videoStream.getVideoTracks().forEach((vtrack) => { vtrack.onended = null; vtrack.enabled = false; });
        that.config.videoMuted = true;
        videoMuted = true;
        if (selfSet) that.selfMuteVideo = true;
        else if (pause) that.selfPausedVideo = true;
        else that.hardVideoMuted = true;
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
        return;
      }
      if (onlySoftMute) {
        if(!localVideoOn)
          that.videoStream.getVideoTracks().forEach((vtrack) => { vtrack.enabled = false; });
        that.softVideoMuted = true;
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      } else {
        muteStreamVideo(true, delay, force, (resp) => {
          if ((resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) || (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177.result)) {
            if (selfSet) that.selfMuteVideo = true;
            else if (pause) that.selfPausedVideo = true;
            else that.hardVideoMuted = true;
            if (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) {
              if (!localVideoOn) attachStreamOnPlayerDivs(null);
              if (raiseEvent) that.sendEvent('user-video-muted');
            } else resp = __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000; //already selfmuted but now remotemute and viceversa
          }
          callback(resp);
        });
      }
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('muteVideo() invalid param - callback');
    }
  };

  // ************************************
  // Public function: unmuteVideo()
  // To unmute Video at local end-point. Callback can be defined at application level
  // ************************************

  that.unmuteVideo = (callback = () => { }, raiseEvent = true, delay = 0, selfSet = true, pause = false, force=false) => {
    if (typeof callback === 'function') {
      {

        console.log("unmuteVideo() selfSet : " + selfSet + " that.selfMuteVideo: " + that.selfMuteVideo +
                    " that.softVideoMuted: " + that.softVideoMuted + " that.hardVideoMuted: " +  that.hardVideoMuted +
                    " paused: " + that.selfPausedAudio);
        if (!force &&
            ((selfSet && !that.selfMuteVideo && !that.softVideoMuted && that.hardVideoMuted && !that.selfPausedVideo) ||
            (!selfSet && !(that.hardVideoMuted || that.selfPausedVideo)))) {
          if (raiseEvent && !that.selfMuteVideo && !that.softVideoMuted && !that.hardVideoMuted)
            that.sendEvent('user-video-unmuted');
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
          return;
        }
        if (!selfSet || !that.hardVideoMuted || !that.selfPausedVideo || (that.room && that.room.isModerator())) {
          if (!selfSet && that.selfMuteVideo) {
            // if remote unmute happens but self muted, just respond success and reset hard flag
            that.hardVideoMuted = false;
            if (pause) that.selfPausedVideo = false;
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
            return;
          }
          if (pendingUserReqs['switchCamera'] != undefined){
            let info = pendingUserReqs['switchCamera'];
            that.switchCamera (info.newStream, info.deviceInfo, (resp) => {
              delete pendingUserReqs['switchCamera'];
              if (resp.result == undefined){
                that.softVideoMuted = false;
                videoMuted = false;
                if (selfSet) that.selfMuteVideo = false;
                else if (pause) that.selfPausedVideo = false;
                else that.hardVideoMuted = false;
                  console.log("unmuteVideo() switchCamera () NOT attaching playerdivs");
                //if (!localVideoOn) attachStreamOnPlayerDivs(that.videoStream);
                if (raiseEvent) that.sendEvent('user-video-unmuted');
                callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
              }else{
                that.unmuteVideo(callback, raiseEvent, delay, selfSet, pause);
              }
            }, false, true);
            return;
          }
          if ((that.pc === undefined || that.pc == null) && that.room && that.videoStream != undefined) {
            that.videoStream.getVideoTracks().forEach((vtrack) => { vtrack.enabled = true;});
            if(that.config.videoMuted === true) that.config.videoMuted = false;
            that.softVideoMuted = false;
            videoMuted = false;
            if (selfSet) that.selfMuteVideo = false;
            else if (pause) that.selfPausedVideo = false;
            else that.hardVideoMuted = false;
            callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
            return;
          }
          muteStreamVideo(false, delay, force, (resp) => {
            if ((resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) || (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177.result)) {
              that.softVideoMuted = false;
              if (selfSet) that.selfMuteVideo = false;
              else if (pause) that.selfPausedVideo = false;
              else that.hardVideoMuted = false;
              if (resp.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result) {
                console.log("unmuteVideo() muteStreamVideo() success");
                if (!localVideoOn) {
                  attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
                  //attachStreamOnPlayerDivs(that.videoStream);
                }
                if (raiseEvent) that.sendEvent('user-video-unmuted');
              } else resp = __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000; //already selfunmuted but now remoteunmute and viceversa
                if (that.room && !force){
                  that.room.onMediaDeviceStateChanged(that,{type :'cam', state: 'active'},callback);
                  return;
                }
            }
            callback(resp);
          });
        } else {
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1176);
        }
      }
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('unmuteVideo() invalid param - callback');
    }
  };
  that.setLocalView = (enable,  callback = () => { }) => {
    if (typeof callback === 'function') {
      if (localVideoOn == enable) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('setLocalVideo() already in same state');
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1177);
        return;
      }
      if (setTrasactionIfNotExists('setCameraTrack') == false) {
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed,
                { message: ('setLocalVideo - Previous similar camera request in process') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
        return;
      }
      console.log ("setLocalView() enable : " + enable);
      if (enable ){
        if (that.isVideoMuted()){
          const cam = {};
          if (spec.params && spec.params.set.video){
            if(typeof spec.params.set.video.deviceId === 'object'){
              cam.deviceId = spec.params.set.video.deviceId.exact
            }
          }

          if (pendingUserReqs['switchCamera'] != undefined){
            let info = pendingUserReqs['switchCamera'];
            that.switchCamera (info.newStream, info.deviceInfo, (resp) => {
              delete pendingUserReqs['switchCamera'];
              if (resp.result == undefined){
                localVideoOn = true;
              }else {
                that.setLocalView (enable,  callback);
              }
            }, false, false);
            return;
          }
          let videoOptions = JSON.parse(JSON.stringify(spec.video));
          if (spec.params && spec.params.set && spec.params.set.video){
            if (spec.params.set.video.deviceId)
              videoOptions.deviceId = typeof spec.params.set.video.deviceId  == 'object' ?
                                      spec.params.set.video.deviceId.exact : spec.params.set.video.deviceId;
            else if (spec.params.set.video.facingMode)
              videoOptions.facingMode = typeof spec.params.set.video.facingMode == 'object' ?
                                      spec.params.set.video.facingMode.exact : spec.params.set.video.facingMode;
          }
          if (videoOptions.deviceId != undefined) cam.deviceId = videoOptions.deviceId;
          else if (videoOptions.facingMode !== undefined && __WEBPACK_IMPORTED_MODULE_11__Common_config_js___default.a.browser_info.device_type == 'mobile') {
            cam.facingMode = videoOptions.facingMode;
          }
          if (cam.deviceId == undefined && cam.facingMode == undefined){
            cam.deviceId = 'none';
          }
          setMediaDevicesTrack(that, undefined, cam, false, (status) => {
            if (status.result === __WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000.result){
              console.log ("setMediaDevicesTrack() success attaching playerdiv ");
              localVideoOn = true;
              attachStreamOnPlayerDivs(that.inputMediaSource.video[that.inputMediaSource.video.selected]);
              //attachStreamOnPlayerDivs(that.videoStream);
            }else {
              console.log ("setMediaDevicesTrack() failed ");
              __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info("Error setMediaDevicesTrack(), error: " + JSON.stringify(status) +
                          " cam: " + cam.deviceId);
            }
            resetTransaction("setCameraTrack");
            callback(status, (localVideoOn ? that.videoStream: null));
          });

          /*
          let options = {video: JSON.parse(JSON.stringify(spec.params.set.video))};
          if (pendingUserReqs['switchCamera'] != undefined){
            let info = pendingUserReqs['switchCamera'];
            if (Info.deviceId != undefined && typeof info.deviceId === 'string')
              options.video.deviceId = { exact: info.deviceId};
            if (info.facingMode != undefined && typeof info.facingMode === 'string')
              options.video.facingMode= { exact: info.facingMode};
          }
          getUserMedia(options, (streamGot, error) => {
              console.log ("getUserMedia() callback error: " + error);
            if (error == undefined) {
              console.log ("getUserMedia() success attaching playerdiv ");
              localVideoOn = true;
              attachStreamOnPlayerDivs(streamGot);
              resetTransaction("setCameraTrack");
              callback(customErrors.error_000, streamGot);
            } else {
              console.log ("getUserMedia() failed ");
              Logger.info("Error getUserMedia(), error: " + error + " cam: " + cam.deviceId, " mic: ", mic_id);
              EL.error('stream-event', customEvents.event_gum_failed, { cam_id: cam.deviceId, mic_id: mic_id });
              resetTransaction("setCameraTrack");
              callback(error);
            }
          });
        */
        }else if ( that.negotiatedMedia.video && that.videoStream != undefined){
          localVideoOn = true;
          //attachStreamOnPlayerDivs(that.videoStream);
          resetTransaction("setCameraTrack");
          console.log ("not muted sending stream ");
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000, that.videoStream);
        }else {
          resetTransaction("setCameraTrack");
          console.log ("error not muted but no video stream");
          callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1159);
        }
      }else {
        localVideoOn = false;
        if (that.isVideoMuted()){
          console.log ("muted disabling localview by replace track");
          //replaceNewMediaStreamTrack(that, false, true, null, true);
          if (that.videoStream !== undefined)
            that.videoStream.getTracks().forEach((track) => { track.enabled = false;track.onended = null; track.stop();});
        }
         console.log ("disabling localview detaching player divs");
        attachStreamOnPlayerDivs(null);
        resetTransaction("setCameraTrack");
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      }
    }else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('setLocalView() invalid param - callback');
    }
  };

  // ************************************
  // Public function: _setStaticQualityLayer()
  // eslint-disable-next-line no-underscore-dangle
  // ************************************

  that._setStaticQualityLayer = (spatialLayer, temporalLayer, callback = () => { }) => {
    if (that.room && that.room.p2p) {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].warning('Error! p2p streams don\'t support setStaticQualityLayer');
      callback('error');
      return;
    }

    const config = { qualityLayer: { spatialLayer, temporalLayer } };
    that.checkOptions(config, true);
    that.pc.updateSpec(config, callback);
  };


  // ************************************
  // Public function: _setDynamicQualityLayer()
  // eslint-disable-next-line no-underscore-dangle
  // ************************************

  that._setDynamicQualityLayer = (callback) => {
    if (that.room && that.room.p2p) {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].warning('Error! p2p streams don\'t support setDynamicQualityLayer');
      callback('error');
      return;
    }
    const config = { qualityLayer: { spatialLayer: -1, temporalLayer: -1 } };
    that.checkOptions(config, true);
    that.pc.updateSpec(config, callback);
  };


  // ************************************
  // Function: controlHandler()
  // eslint-disable-next-line no-underscore-dangle
  // ************************************

  const controlHandler = (handlersInput, publisherSideInput, enable) => {
    let publisherSide = publisherSideInput;
    let handlers = handlersInput;
    if (publisherSide !== true) {
      publisherSide = false;
    }

    handlers = (typeof handlers === 'string') ? [handlers] : handlers;
    handlers = (handlers instanceof Array) ? handlers : [];

    if (handlers.length > 0) {
      that.room.sendControlMessage(that, 'control', {
        name: 'controlhandlers',
        enable,
        publisherSide,
        handlers,
      });
    }
  };


  // ************************************
  // Function: disableHandlers()
  // desc:
  // ************************************

  that.disableHandlers = (handlers, publisherSide) => {
    controlHandler(handlers, publisherSide, false);
  };


  // ************************************
  // Function: enableHandlers()
  // desc:
  // ************************************

  that.enableHandlers = (handlers, publisherSide) => {
    controlHandler(handlers, publisherSide, true);
  };


  that.updateSimulcastLayersBitrate = (bitrates, byServer) => {
    if (that.pc && that.local) {
      that.pc.updateSimulcastLayersBitrate(bitrates);
      if (byServer) {
        config.maxVideoLayeredBitrates = bitrates;
      }
    }
  };

  // ************************************
  // Public Function: updateConfiguration()
  // desc: To update configuraiton of stream on peer connection
  // ************************************

  that.updateConfiguration = (config, callback = () => { }) => {
    if (config === undefined) { return; }
    if (that.pc) {
      that.checkOptions(config, true);
      if (that.local) {
        if (that.room.p2p) {
          for (let index = 0; index < that.pc.length; index += 1) {
            that.pc[index].updateSpec(config, callback);
          }
        } else if (config.maxVideoBW != undefined || config.minVideoBW != undefined ||
          config.maxVideoFps != undefined || config.minVideoFps != undefined) {
          if (that.maxVideoLayers <= 1) {
            //console.log(`updateConfiguration id: ${that.getID()} config:: ${JSON.stringify(config)}`);
            that.setVideoParamsRange(
              config.maxVideoBW, config.minVideoBW,
              config.maxVideoFps, config.minVideoFps, false,
            );
          }
        } else {
          that.pc.updateSpec(config, callback);
        }
      } else {
        that.pc.updateSpec(config, callback);
      }
    } else {
      callback('Error! This stream has no peerConnection attached, Skipping');
    }
  };

  that.ShowSessionStats = (statsEnabled) => {
    if (statsEnabled === true) {
      if (that.player !== undefined) {
        that.player.ShowSessionStats(true);
      } else {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('stream does not have a player to show stats');
      }
    } else if (that.player !== undefined) {
      that.player.ShowSessionStats(false);
    } else {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('stream does not have a player to hide stats');
    }
  };

  that.changeInputMediaSource = (options, callback = () => { }) => {
    if (typeof callback !== 'function'){
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('changeInputMediaSource() invalid param - callback');
      return;
    }
    if (!that.local || that.ifCanvas() || that.ifScreen()){
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('changeInputMediaSource() not supported ');
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1156);
      return;
    }
    if (options == undefined || typeof options !== 'object' || (options.video == undefined && options.audio == undefined)){
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('changeInputMediaSource() invalid param - options');
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1155);
      return;
    }
    if (options.video){
      if (options.stream && (!options.stream.getVideoTracks() || !options.stream.getVideoTracks().length)){
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('changeInputMediaSource() video tracks not found');
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1156);
        return;
      }
      if (setTrasactionIfNotExists('setCameraTrack') == false) {
        __WEBPACK_IMPORTED_MODULE_10__EventLogger__["a" /* default */].warn('stream-event', __WEBPACK_IMPORTED_MODULE_9__customEvents__["a" /* default */].event_general_failed,
                { message: ('changeInputMediaSource() - Previous similar camera request in process') });
        callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1140);
        return;
      }
      that.inputMediaSource.video.user = (options.stream != undefined && options.stream != null) ? options.stream: null;
      let reqMediaSource, selected ;
      if (that.inputMediaSource.video.user != null){
        reqMediaSource = that.inputMediaSource.video.user;
        selected = 'user';
      }else {
        reqMediaSource = that.inputMediaSource.video.self;
        selected = 'self';
      }
      if (!that.isVideoMuted() ){
        if (that.inputMediaSource.video.selected != selected){
          replaceNewMediaStreamTrack(that, false, true, reqMediaSource, false);
          attachStreamOnPlayerDivs(reqMediaSource);
        }
      }
      that.inputMediaSource.video.selected = selected;
      resetTransaction("setCameraTrack");
      callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);

    }
  };
  /**
   * Replace track method
   */

  that.replaceLocalTrack = (localStreamObject, newStream) => {

    localStreamObject.pc.peerConnection.getSenders().forEach((sender, index) => {
      if (sender.track) {
        if (sender.track.kind === 'video') {
          if (newStream) {
            newStream.getVideoTracks().forEach((vtrack) => {
              console.log(vtrack);
              vtrack.enabled = true;
              sender.replaceTrack(vtrack);
            });
          }

        }
        else if (sender.track.kind === 'audio') {
          if (localStreamObject) {
            localStreamObject.audioStream.getAudioTracks().forEach((atrack) => {
              console.log(atrack);
              atrack.enabled = true;
              sender.replaceTrack(atrack);
            });
          }
        }
      }
    });
  }

  that.enableNoiseSuppression = (callback = () => { }) => {
    // Check if callback is of type function or not.
    if (typeof callback != 'function') {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Incorrect type for callback, it should be a function');
      return;
    }
    // If noiseEffects object doesn't get initiated.
    if (!noiseEffects) {
      return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1170);
    }
    //When there are no audio stream/tracks available.
    if (that.audioStream == undefined) {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].debug("audio stream/tracks coming as undefined !!");
      return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1198);
    }
    // If audio muted
    // if (that.selfMuteAudio == true) {
    //   if (false == noiseEffects.isAlreadyStarted()) {
    //     // If noise suppression isn't on.
    //     return callback(customErrors.error_1198);
    //   } else if (true == noiseEffects.isAlreadyStarted()) {
    //     // If noise suppression was on.
    //     return callback(customErrors.error_1199);
    //   }
    // }
    if (false == noiseEffects.isAlreadyStarted()) {
      //If noise suppression wasn't enabled.
      noiseEffects.startNoiseProcessing(that.audioStream).then(modifiedStream => {
        replaceNewMediaStreamTrack(that, true, false, modifiedStream, false, false);
        //Dispatched noise suppression successfully enabled callback.
        return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      }).catch(() => {
        // Dispatch noise suppression failed callback.
        return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1198);
      });
    } else {
      // If noise suppression was on.
      return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1188);
    }
  }

  that.disableNoiseSuppression = (callback = () => { }) => {
    // Check if callback is of type function or not.
    if (typeof callback != 'function') {
      __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].error('Incorrect type for callback, it should be a function');
      return;
    }
    // If noiseEffects object doesn't get initiated.
    if (!noiseEffects) {
      return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1170);
    }
    if (false == noiseEffects.isAlreadyStarted()) {
      //If noise suppression wasn't enabled.
      return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1188);
    } else if (true == noiseEffects.isAlreadyStarted()) {
      noiseEffects.stopNoiseProcessing().then(() => {
        replaceNewMediaStreamTrack(that, true, false, that.audioStream, false, false);
         //Dispatched noise suppression successfully disabled callback.
        return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_000);
      }).catch(() => {
        // failed to stop noise suppression.
        return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1199);
      });
    }
  }

  that.noiseProcessingFeatureExists = () => {
    // If noiseEffects object doesn't get initiated.
    if (!noiseEffects) {
      return callback(__WEBPACK_IMPORTED_MODULE_6__customErrors__["a" /* default */].error_1170);
    }
    return new Promise((resolve, reject) => {
      noiseEffects.checkFileExists()
        .then((response) => {
          resolve(response);
        })
        .catch((excp) => {
          reject(excp);
        });
    });
  };

  function getAverage(valueArray) {
    return valueArray.length > 0 ? valueArray.reduce((a, b) => a + b) / valueArray.length : 0
  }

  function filterPositiveValues(valueArray) {
    return valueArray.filter(value => value >= 0);
  }

  function processAudioScoreForVoice() {

    if(that.scoreArrayVoice.length > 0) {
      const avg_score = getAverage(that.scoreArrayVoice).toFixed(2);
      if (avg_score > VOICE_AVG_THRESHOLD) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('Your microphone is muted');
        const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'talking-while-muted', stream: that });
        that.dispatchEvent(streamEvent);
        //that.lastNoiseEventTime = new Date();
      }
      that.scoreArrayVoice.length = 0;
      that.processing_voice_while_mute = false;
    }
  }

  function processAudioScoreForNoise() {

    if(that.scoreArrayNoise.length > 0) {

      const scoreAvg = getAverage(that.scoreArrayNoise);
      const audioLevelAverage = getAverage(that.audioLevelArray);

      if (scoreAvg < NOISE_AVG_THRESHOLD && audioLevelAverage > NOISE_AUDIO_LEVEL_THRESHOLD) {
        __WEBPACK_IMPORTED_MODULE_4__utils_Logger__["default"].info('noise-detected');
        const streamEvent = Object(__WEBPACK_IMPORTED_MODULE_0__Events__["f" /* StreamEvent */])({ type: 'noise-detection', stream: that });
        that.dispatchEvent(streamEvent);
      }
      that.scoreArrayNoise.length = 0;
      that.processing_noise_detection = false;
    }
  }

  function recordValues(score, avgAudioLevel) {
    that.scoreArrayNoise.push(score);
    that.audioLevelArray.push(avgAudioLevel);
  }
  return that;
};
/* harmony default export */ __webpack_exports__["a"] = (Stream);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
This file is for View Properties.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/
/*
 * ViewProperties class stores some default constant value of View
 */
const ViewProperties = () => {
    const that = {
        player: {
            default: {
                autoplay: 'autoplay',
                name: '',
                nameDisplayMode: '',
                frameFitMode: 'bestFit',
                skin: 'default',
                class: '',
                height: '240px',
                width: '320px',
                minHeight: '200px',
                minWidth: '250px',
                aspectRatio: '16:9',
                volume: 5,
                media: '',
                loader: {
                    show: true,
                    style: 'default',
                    class: '',
                },
            },
        },
        brand: {
            default: {
                display: true,
                url: 'http://www.vcloudx.com',
                logo: '/assets/favicon.png',
                show: true,
                target: '_blank',
                title: 'VCloudX Infotech',
            },
        },
        toolbar: {
            default: {
                skin: 'default',
                buttons: {
                    play: true,
                    resize: true,
                    share: true,
                    mic: true,
                    volume: true,
                    mute: true,
                    record: true,
                    playtime: true,
                    zoom: true,
                },
                position: 'bottom',
                class: '',
                displayMode: true,
                autoDisplayTimeout: 0,
            },
        },
    };

    return that;
};
/* harmony default export */ __webpack_exports__["a"] = (ViewProperties);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export setFileProtocolWssUrl */
/* unused harmony export getFileProtocolWssUrl */
/* harmony export (immutable) */ __webpack_exports__["d"] = getApiUrl;
/* unused harmony export setApiUrlPrefix */
/* unused harmony export getApiCallInfoParams */
/* unused harmony export setApiCallInfoParams */
/* harmony export (immutable) */ __webpack_exports__["f"] = setFileShareServiceEndPoint;
/* unused harmony export parseNonce */
/* harmony export (immutable) */ __webpack_exports__["a"] = del;
/* harmony export (immutable) */ __webpack_exports__["g"] = setParams;
/* harmony export (immutable) */ __webpack_exports__["c"] = fileInfo;
/* harmony export (immutable) */ __webpack_exports__["e"] = metadata;
/* harmony export (immutable) */ __webpack_exports__["h"] = setPassword;
/* harmony export (immutable) */ __webpack_exports__["i"] = uploadWs;
/* unused harmony export downloadStream */
/* harmony export (immutable) */ __webpack_exports__["b"] = downloadFile;
/* unused harmony export getFileList */
/* unused harmony export setFileList */
/* unused harmony export sendMetrics */
/* unused harmony export getConstants */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ece__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Logger__ = __webpack_require__(0);




const fileShareService = {};
let fileProtocolWssUrl = null;
let host = '';
let port = '';

if (!fileProtocolWssUrl) {
  // fileProtocolWssUrl = 'wss://vc-manu.vcloudx.com:9090/api/ws';
  fileProtocolWssUrl = '';
}

class ConnectionError extends Error {
  constructor(cancelled, duration, size) {
    super(cancelled ? '0' : 'connection closed');
    this.cancelled = cancelled;
    this.duration = duration;
    this.size = size;
  }
}
/* unused harmony export ConnectionError */


function setFileProtocolWssUrl(url) {
  fileProtocolWssUrl = url;
}

function getFileProtocolWssUrl() {
  return fileProtocolWssUrl;
}

//let apiUrlPrefix = 'https://vc-manu.vcloudx.com:9090'
let apiUrlPrefix = '';
function getApiUrl(path) {
  return apiUrlPrefix + path;
}

function setApiUrlPrefix(prefix) {
  apiUrlPrefix = prefix;
}

// callInfo params for every fsAPI call info
// currently setting callinfo from client , we may need to change it and once utality token comes in picture we can fetch at server side from dapi
const callInfo = {};
/*
callInfo ={
  "userName":'',
  "trans_dt":'',
  "room_id":'',
  "service_id":"",
  "conf_num":"",
  "call_num":"",
  "file_meta":{}
} */

function getApiCallInfoParams(file_meta = {}) {
  callInfo.file_meta = file_meta;
  callInfo.trans_dt = Date.now();
  // Logger.info('getApiCallInfoParams ', callInfo);
  return callInfo;
}

function setApiCallInfoParams(callDetails) {
  __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info(' file sharing service call details', callDetails);
  callInfo.userName = callDetails.userName;
  callInfo.room_id = callDetails.room_id;
  callInfo.conf_num = callDetails.conf_num;
  callInfo.call_num = callDetails.call_num;
  callInfo.service_id = callDetails.service_id;
}

function setFileShareServiceEndPoint(fileShareService) {
  if (fileShareService != undefined && fileShareService.url != undefined && fileShareService.hostName != undefined && fileShareService.port != undefined) {
    setApiUrlPrefix(fileShareService.url);
    host = fileShareService.hostName;
    port = fileShareService.port;
    setFileProtocolWssUrl(`${'wss' + ':' + '//'}${host}:${port}/api/ws`);
    // Logger.info(' file server end points ' + host + port + apiUrlPrefix + fileProtocolWssUrl);
    setApiCallInfoParams(fileShareService.callInfo);
  }
}

function post(obj, bearerToken) {
  const h = {
    'Content-Type': 'application/json',
  };

  if (bearerToken) {
    h.Authentication = `Bearer ${bearerToken}`;
  }

  return {
    method: 'POST',
    headers: new Headers(h),
    body: JSON.stringify(obj),
  };
}

function parseNonce(header) {
  header = header || '';
  return header.split(' ')[1];
}

async function fetchWithAuth(url, params, keychain) {
  const result = {};
  params = params || {};
  const h = await keychain.authHeader();
  params.headers = new Headers({ Authorization: h });
  //params.mode = 'cors';
  const response = await fetch(url, params);
  result.response = response;
  result.ok = response.ok;
  const nonce = parseNonce(response.headers.get('WWW-Authenticate'));
  result.shouldRetry = response.status === 401 && nonce !== keychain.nonce;
  keychain.nonce = nonce;
  return result;
}

async function fetchWithAuthAndRetry(url, params, keychain) {
  const result = await fetchWithAuth(url, params, keychain);
  if (result.shouldRetry) {
    return fetchWithAuth(url, params, keychain);
  }
  return result;
}

async function del(id, owner_token) {
  const response = await fetch(
    getApiUrl(`/api/delete/${id}`),
    post({ owner_token }),
  );
  return response.ok;
}

async function setParams(id, owner_token, bearerToken, params) {
  const response = await fetch(
    getApiUrl(`/api/params/${id}`),
    post(
      {
        owner_token,
        dlimit: params.dlimit,
      },
      bearerToken,
    ),
  );
  return response.ok;
}

async function fileInfo(id, owner_token) {
  const response = await fetch(
    getApiUrl(`/api/info/${id}`),
    post({ owner_token }),
  );

  if (response.ok) {
    const obj = await response.json();
    return obj;
  }

  throw new Error(response.status);
}

async function metadata(id, keychain) {
  const result = await fetchWithAuthAndRetry(
    getApiUrl(`/api/metadata/${id}`),
    { method: 'GET' },
    keychain,
  );
  if (result.ok) {
    const data = await result.response.json();
    const meta = await keychain.decryptMetadata(Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(data.metadata));
    return {
      size: meta.size,
      ttl: data.ttl,
      iv: meta.iv,
      name: meta.name,
      type: meta.type,
      manifest: meta.manifest,
    };
  }
  throw new Error(result.response.status);
}

async function setPassword(id, owner_token, keychain) {
  const auth = await keychain.authKeyB64();
  const response = await fetch(
    getApiUrl(`/api/password/${id}`),
    post({ owner_token, auth }),
  );
  return response.ok;
}

function asyncInitWebSocket(server) {
  return new Promise((resolve, reject) => {
    try {
      const ws = new WebSocket(server);
      ws.addEventListener('open', () => resolve(ws), { once: true });
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info('asyncInitWebSocket exception while creating websocket', e);
      reject(new ConnectionError(false));
    }
  });
}

function listenForResponse(ws, canceller) {
  return new Promise((resolve, reject) => {
    function handleClose(event) {
      // a 'close' event before a 'message' event means the request failed
      ws.removeEventListener('message', handleMessage);
      reject(new ConnectionError(canceller.cancelled));
    }
    function handleMessage(msg) {
      ws.removeEventListener('close', handleClose);
      try {
        const response = JSON.parse(msg.data);
        if (response.error) {
          __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error(' listenForResponse throw exception ', response.error);
          throw new Error(response.error);
        } else {
          resolve(response);
        }
      } catch (e) {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error(' listenForResponse exception ', e);

        reject(e);
      }
    }
    ws.addEventListener('message', handleMessage, { once: true });
    ws.addEventListener('close', handleClose, { once: true });
  });
}

async function upload(
  stream,
  metadata,
  verifierB64,
  timeLimit,
  dlimit,
  bearerToken,
  file_info,
  onprogress,
  canceller,
) {
  let size = 0;
  const start = Date.now();

  //const host ='vc-manu.vcloudx.com';//'192.168.200.110';
  //const port = '9090'
  const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
  const endpoint =
    window.location.protocol === 'file:'
      ? fileProtocolWssUrl
      : `${protocol}//${host}${port ? ':' : ''}${port}/api/ws`;

  //Logger.info('web socket end point for file server ',endpoint);
  const ws = await asyncInitWebSocket(endpoint);

  try {
    const metadataHeader = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["arrayToB64"])(new Uint8Array(metadata));
    // get the room meta
    let callInfo = {};
    callInfo = getApiCallInfoParams(file_info);

    const fileMeta = {
      fileMetadata: metadataHeader,
      authorization: `send-v1 ${verifierB64}`,
      bearer: bearerToken,
      timeLimit,
      dlimit,
      callInfo,
    };
    const uploadInfoResponse = listenForResponse(ws, canceller);
    ws.send(JSON.stringify(fileMeta));
    const uploadInfo = await uploadInfoResponse;

    const completedResponse = listenForResponse(ws, canceller);

    const reader = stream.getReader();
    let state = await reader.read();
    while (!state.done) {
      if (canceller.cancelled) {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info(' websocket upload cancelled');
        ws.close();
      }
      if (ws.readyState !== WebSocket.OPEN) {
        break;
      }
      const buf = state.value;
      ws.send(buf);
      onprogress(size);
      size += buf.length;
      state = await reader.read();
      while (
        ws.bufferedAmount > __WEBPACK_IMPORTED_MODULE_1__ece__["a" /* ECE_RECORD_SIZE */] * 2 &&
        ws.readyState === WebSocket.OPEN &&
        !canceller.cancelled
      ) {
        await Object(__WEBPACK_IMPORTED_MODULE_0__utils__["delay"])();
      }
    }
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(new Uint8Array([0])); //EOF
    }

    await completedResponse;
    uploadInfo.duration = Date.now() - start;
    return uploadInfo;
  } catch (e) {
    e.size = size;
    e.duration = Date.now() - start;
    __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info(' websocket upload failed', e);
    throw e;
  } finally {
    if (![WebSocket.CLOSED, WebSocket.CLOSING].includes(ws.readyState)) {
      ws.close();
    }
  }
}

function uploadWs(
  encrypted,
  metadata,
  verifierB64,
  timeLimit,
  dlimit,
  bearerToken,
  file_info,
  onprogress,
) {
  const canceller = { cancelled: false };

  return {
    cancel() {
      canceller.cancelled = true;
    },

    result: upload(
      encrypted,
      metadata,
      verifierB64,
      timeLimit,
      dlimit,
      bearerToken,
      file_info,
      onprogress,
      canceller,
    ),
  };
}

////////////////////////

async function downloadS(id, keychain, signal) {
  const auth = await keychain.authHeader();

  const response = await fetch(getApiUrl(`/api/download/${id}`), {
    signal,
    method: 'GET',
    headers: { Authorization: auth },
  });

  const authHeader = response.headers.get('WWW-Authenticate');
  if (authHeader) {
    keychain.nonce = parseNonce(authHeader);
  }

  if (response.status !== 200) {
    throw new Error(response.status);
  }

  return response.body;
}

async function tryDownloadStream(id, keychain, signal, tries = 2) {
  try {
    const result = await downloadS(id, keychain, signal);
    return result;
  } catch (e) {
    if (e.message === '401' && --tries > 0) {
      return tryDownloadStream(id, keychain, signal, tries);
    }
    if (e.name === 'AbortError') {
      throw new Error('0');
    }
    throw e;
  }
}

function downloadStream(id, keychain) {
  const controller = new AbortController();
  function cancel() {
    controller.abort();
  }
  return {
    cancel,
    result: tryDownloadStream(id, keychain, controller.signal),
  };
}

//////////////////

async function download(id, keychain, onprogress, canceller) {
  const auth = await keychain.authHeader();
  const xhr = new XMLHttpRequest();
  canceller.oncancel = () => {
    xhr.abort();
  };
  return new Promise(((resolve, reject) => {
    xhr.addEventListener('loadend', () => {
      canceller.oncancel = () => { };
      const authHeader = xhr.getResponseHeader('WWW-Authenticate');
      if (authHeader) {
        keychain.nonce = parseNonce(authHeader);
      }
      if (xhr.status !== 200) {
        return reject(new Error(xhr.status));
      }

      const blob = new Blob([xhr.response]);
      resolve(blob);
    });

    xhr.addEventListener('progress', (event) => {
      if (event.target.status === 200) {
        onprogress(event.loaded);
      }
    });
    xhr.open('get', getApiUrl(`/api/download/blob/${id}`));
    xhr.setRequestHeader('Authorization', auth);
    xhr.responseType = 'blob';
    xhr.send();
    onprogress(0);
  }));
}

async function tryDownload(id, keychain, onprogress, canceller, tries = 2) {
  try {
    const result = await download(id, keychain, onprogress, canceller);
    return result;
  } catch (e) {
    if (e.message === '401' && --tries > 0) {
      return tryDownload(id, keychain, onprogress, canceller, tries);
    }
    throw e;
  }
}

function downloadFile(id, keychain, onprogress) {
  const canceller = {
    oncancel() { }, // download() sets this
  };
  function cancel() {
    canceller.oncancel();
  }
  return {
    cancel,
    result: tryDownload(id, keychain, onprogress, canceller),
  };
}

async function getFileList(bearerToken, kid) {
  const headers = new Headers({ Authorization: `Bearer ${bearerToken}` });
  const response = await fetch(getApiUrl(`/api/filelist/${kid}`), { headers });
  if (response.ok) {
    const encrypted = await response.blob();
    return encrypted;
  }
  throw new Error(response.status);
}

async function setFileList(bearerToken, kid, data) {
  const headers = new Headers({ Authorization: `Bearer ${bearerToken}` });
  const response = await fetch(getApiUrl(`/api/filelist/${kid}`), {
    headers,
    method: 'POST',
    body: data,
  });
  return response.ok;
}

function sendMetrics(blob) {
  if (!navigator.sendBeacon) {
    return;
  }
  try {
    navigator.sendBeacon(getApiUrl('/api/metrics'), blob);
  } catch (e) {
    console.error(e);
  }
}

async function getConstants() {
  const response = await fetch(getApiUrl('/config'));

  if (response.ok) {
    const obj = await response.json();
    return obj;
  }

  throw new Error(response.status);
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(28)
var ieee754 = __webpack_require__(54)
var isArray = __webpack_require__(55)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
//'use strict';
//import enumerateStats from './util';
const util = __webpack_require__(13);
const enxConfig = __webpack_require__(1);
function Call(config, test) {
  this.test = test;
  this.statsGatheringRunning = false;

  this.pc1 = new RTCPeerConnection(config);
  this.pc2 = new RTCPeerConnection(config);

  this.pc1.addEventListener('icecandidate', this.onIceCandidate_.bind(
    this,
    this.pc2,
  ));
  this.pc2.addEventListener('icecandidate', this.onIceCandidate_.bind(
    this,
    this.pc1,
  ));

  this.iceCandidateFilter_ = Call.noFilter;
}

Call.prototype = {
  establishConnection() {
    //this.traceEvent({state: 'start'});
    this.pc1.createOffer().then(
         this.gotOffer_.bind(this),
         this.test.reportFatal.bind(this.test),
    );
  },

  close() {
    //this.traceEvent({state: 'end'});
    this.pc1.close();
    this.pc2.close();
  },

  setIceCandidateFilter(filter) {
    this.iceCandidateFilter_ = filter;
  },

  // Constraint max video bitrate by modifying the SDP when creating an answer.
  constrainVideoBitrate(maxVideoBitrateKbps) {
    this.constrainVideoBitrateKbps_ = maxVideoBitrateKbps;
  },

  // Remove video FEC if available on the offer.
  disableVideoFec() {
    this.constrainOfferToRemoveVideoFec_ = true;
  },

  // When the peerConnection is closed the statsCb is called once with an array
  // of gathered stats.
  gatherStats(peerConnection, peerConnection2, localStream, statsCb) {
    const stats = [];
    const stats2 = [];
    const statsCollectTime = [];
    const statsCollectTime2 = [];
    const self = this;
    const statStepMs = 100;
    self.localTrackIds = {
      audio: '',
      video: '',
    };
    self.remoteTrackIds = {
      audio: '',
      video: '',
    };

    peerConnection.getSenders().forEach(((sender) => {
      if (sender.track.kind === 'audio') {
        self.localTrackIds.audio = sender.track.id;
      } else if (sender.track.kind === 'video') {
        self.localTrackIds.video = sender.track.id;
      }
    }));

    if (peerConnection2) {
      peerConnection2.getReceivers().forEach(((receiver) => {
        if (receiver.track.kind === 'audio') {
          self.remoteTrackIds.audio = receiver.track.id;
        } else if (receiver.track.kind === 'video') {
          self.remoteTrackIds.video = receiver.track.id;
        }
      }));
    }

    this.statsGatheringRunning = true;
    getStats_();

    function getStats_() {
      if (peerConnection.signalingState === 'closed') {
        self.statsGatheringRunning = false;
        statsCb(stats, statsCollectTime, stats2, statsCollectTime2);
        return;
      }
      peerConnection.getStats()
          .then(gotStats_)
          .catch(((error) => {
            self.test.reportError(`Could not gather stats: ${error}`);
            self.statsGatheringRunning = false;
            statsCb(stats, statsCollectTime);
          }));
      if (peerConnection2) {
        peerConnection2.getStats()
            .then(gotStats2_);
      }
    }
    // Stats for pc2, some stats are only available on the receiving end of a
    // peerconnection.
    function gotStats2_(response) {
      if (adapter.browserDetails.browser === 'chrome') {
        const enumeratedStats = util.enumerateStats(
          response, self.localTrackIds,
          self.remoteTrackIds,
        );
        stats2.push(enumeratedStats);
        statsCollectTime2.push(Date.now());
      } else if (adapter.browserDetails.browser === 'firefox') {
        const enumeratedStats = util.enumerateStatsFirefox(response);
        stats2.push(enumeratedStats);
        statsCollectTime2.push(Date.now());
      } else {
        self.test.reportError('Only Firefox and Chrome getStats ' +
            'implementations are supported.');
      }
    }

    function gotStats_(response) {
      // TODO: Remove browser specific stats gathering hack once adapter.js or
      // browsers converge on a standard.
      if (adapter.browserDetails.browser === 'chrome') {
        const enumeratedStats = util.enumerateStats(
          response, self.localTrackIds,
          self.remoteTrackIds,
        );
        stats.push(enumeratedStats);
        statsCollectTime.push(Date.now());
      } else if (adapter.browserDetails.browser === 'firefox') {
        const enumeratedStats = util.enumerateStatsFirefox(response);
        stats.push(enumeratedStats);
        statsCollectTime.push(Date.now());
      } else {
        self.test.reportError('Only Firefox and Chrome getStats ' + 'implementations are supported.');
      }
      setTimeout(getStats_, statStepMs);
    }
  },

  gotOffer_(offer) {
    if (this.constrainOfferToRemoveVideoFec_) {
      offer.sdp = offer.sdp.replace(
        /(m=video 1 [^\r]+)(116 117)(\r\n)/g,
        '$1\r\n',
      );
      offer.sdp = offer.sdp.replace(/a=rtpmap:116 red\/90000\r\n/g, '');
      offer.sdp = offer.sdp.replace(/a=rtpmap:117 ulpfec\/90000\r\n/g, '');
      offer.sdp = offer.sdp.replace(/a=rtpmap:98 rtx\/90000\r\n/g, '');
      offer.sdp = offer.sdp.replace(/a=fmtp:98 apt=116\r\n/g, '');
    }
    this.pc1.setLocalDescription(offer);
    this.pc2.setRemoteDescription(offer);
    this.pc2.createAnswer().then(
         this.gotAnswer_.bind(this),
         this.test.reportFatal.bind(this.test),
     );
  },

  gotAnswer_(answer) {
    if (this.constrainVideoBitrateKbps_) {
      answer.sdp = answer.sdp.replace(
        /a=mid:video\r\n/g,
        `a=mid:video\r\nb=AS:${this.constrainVideoBitrateKbps_}\r\n`,
      );
    }
    this.pc2.setLocalDescription(answer);
    this.pc1.setRemoteDescription(answer);
  },

  onIceCandidate_(otherPeer, event) {
    if (event.candidate) {
      const parsed = Call.parseCandidate(event.candidate.candidate);
      if (this.iceCandidateFilter_(parsed)) {
        otherPeer.addIceCandidate(event.candidate);
      }
    }
  },
};

Call.noFilter = function () {
  return true;
};

Call.isRelay = function (candidate) {
  return candidate.type === 'relay';
};

Call.isNotHostCandidate = function (candidate) {
  return candidate.type !== 'host';
};

Call.isReflexive = function (candidate) {
  return candidate.type === 'srflx';
};

Call.isHost = function (candidate) {
  return candidate.type === 'host';
};

Call.isIpv6 = function (candidate) {
  return candidate.address !== undefined && candidate.address.indexOf(':') !== -1;
};

// Parse a 'candidate:' line into a JSON object.
Call.parseCandidate = function (text) {
  const candidateStr = 'candidate:';
  const pos = text.indexOf(candidateStr) + candidateStr.length;
  const fields = text.substr(pos).split(' ');
  return {
    type: fields[7],
    protocol: fields[2],
    address: fields[4],
  };
};

// Store the ICE server response from the network traversal server.
Call.cachedIceServers_ = null;
// Keep track of when the request was made.
Call.cachedIceConfigFetchTime_ = null;

// Get a TURN config, either from settings or from network traversal server.
Call.asyncCreateTurnConfig = function (onSuccess, onError, region) {
  const settings = enxConfig.ice_servers[region];
  //console.log(`region: ${region} server: TURN`);
  if (settings.turnURI !== '') {
    const iceServer = {
      username: settings.turnUsername,
      credential: settings.turnCredential,
      urls: settings.turnURI,
    };
    const config = { iceServers: [iceServer] };
    //report.traceEventInstant('turn-config', config);
    setTimeout(onSuccess.bind(null, config), 0);
  }

};

// Get a STUN config, either from settings or from network traversal server.
Call.asyncCreateStunConfig = function (onSuccess, onError, region) {
  //console.log(`region: ${region} server: STUN`);
  const settings = enxConfig.ice_servers[region];
  if (settings.stunURI !== '') {
    const iceServer = {
      urls: settings.stunURI,
    };
    const config = { iceServers: [iceServer] };
    //report.traceEventInstant('stun-config', config);
    setTimeout(onSuccess.bind(null, config), 0);
  }

};


if (true) {
  module.exports = Call;
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* global unescape */

const Base64 = (() => {
  let base64Str;
  let base64Count;

  const END_OF_INPUT = -1;
  const base64Chars = [
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', '+', '/',
  ];

  const reverseBase64Chars = [];

  for (let i = 0; i < base64Chars.length; i += 1) {
    reverseBase64Chars[base64Chars[i]] = i;
  }

  const setBase64Str = (str) => {
    base64Str = str;
    base64Count = 0;
  };

  const readBase64 = () => {
    if (!base64Str) {
      return END_OF_INPUT;
    }
    if (base64Count >= base64Str.length) {
      return END_OF_INPUT;
    }
    const c = base64Str.charCodeAt(base64Count) & 0xff; // eslint-disable-line no-bitwise
    base64Count += 1;
    return c;
  };

  const encodeBase64 = (str) => {
    let result;
    let lineCount;
    let done;
    setBase64Str(str);
    result = '';
    const inBuffer = new Array(3);
    lineCount = 0;
    done = false;
    while (!done && (inBuffer[0] = readBase64()) !== END_OF_INPUT) {
      inBuffer[1] = readBase64();
      inBuffer[2] = readBase64();
      // eslint-disable-next-line no-bitwise
      result += (base64Chars[inBuffer[0] >> 2]);
      if (inBuffer[1] !== END_OF_INPUT) {
        // eslint-disable-next-line no-bitwise
        result += (base64Chars[((inBuffer[0] << 4) & 0x30) | (inBuffer[1] >> 4)]);
        if (inBuffer[2] !== END_OF_INPUT) {
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[((inBuffer[1] << 2) & 0x3c) | (inBuffer[2] >> 6)]);
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[inBuffer[2] & 0x3F]);
        } else {
          // eslint-disable-next-line no-bitwise
          result += (base64Chars[((inBuffer[1] << 2) & 0x3c)]);
          result = `${result}=`;
          done = true;
        }
      } else {
        // eslint-disable-next-line no-bitwise
        result += (base64Chars[((inBuffer[0] << 4) & 0x30)]);
        result = `${result}=`;
        result = `${result}=`;
        done = true;
      }
      lineCount += 4;
      if (lineCount >= 76) {
        result = `${result}\n`;
        lineCount = 0;
      }
    }
    return result;
  };

  const readReverseBase64 = () => {
    if (!base64Str) {
      return END_OF_INPUT;
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
      if (base64Count >= base64Str.length) {
        return END_OF_INPUT;
      }
      const nextCharacter = base64Str.charAt(base64Count);
      base64Count += 1;
      if (reverseBase64Chars[nextCharacter]) {
        return reverseBase64Chars[nextCharacter];
      }
      if (nextCharacter === 'A') {
        return 0;
      }
    }
  };

  const ntos = (value) => {
    let n = value.toString(16);
    if (n.length === 1) {
      n = `0${n}`;
    }
    n = `%${n}`;
    return unescape(n);
  };

  const decodeBase64 = (str) => {
    let result;
    let done;
    setBase64Str(str);
    result = '';
    const inBuffer = new Array(4);
    done = false;
    while (!done &&
      (inBuffer[0] = readReverseBase64()) !== END_OF_INPUT &&
      (inBuffer[1] = readReverseBase64()) !== END_OF_INPUT) {
      inBuffer[2] = readReverseBase64();
      inBuffer[3] = readReverseBase64();
      // eslint-disable-next-line no-bitwise,no-mixed-operators
      result += ntos((((inBuffer[0] << 2) & 0xff) | inBuffer[1] >> 4));
      if (inBuffer[2] !== END_OF_INPUT) {
        // eslint-disable-next-line no-bitwise,no-mixed-operators
        result += ntos((((inBuffer[1] << 4) & 0xff) | inBuffer[2] >> 2));
        if (inBuffer[3] !== END_OF_INPUT) {
          // eslint-disable-next-line no-bitwise
          result += ntos((((inBuffer[2] << 6) & 0xff) | inBuffer[3]));
        } else {
          done = true;
        }
      } else {
        done = true;
      }
    }
    return result;
  };

  return {
    encodeBase64,
    decodeBase64,
  };
})();

/* harmony default export */ __webpack_exports__["a"] = (Base64);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = transformStream;
/* harmony export (immutable) */ __webpack_exports__["a"] = blobStream;
/* harmony export (immutable) */ __webpack_exports__["b"] = concatStream;
/* global TransformStream */

function transformStream(readable, transformer, oncancel) {
  try {
    return readable.pipeThrough(new TransformStream(transformer));
  } catch (e) {
    const reader = readable.getReader();
    return new ReadableStream({
      start(controller) {
        if (transformer.start) {
          return transformer.start(controller);
        }
      },
      async pull(controller) {
        let enqueued = false;
        const wrappedController = {
          enqueue(d) {
            enqueued = true;
            controller.enqueue(d);
          },
        };
        while (!enqueued) {
          const data = await reader.read();
          if (data.done) {
            if (transformer.flush) {
              await transformer.flush(controller);
            }
            return controller.close();
          }
          await transformer.transform(data.value, wrappedController);
        }
      },
      cancel(reason) {
        readable.cancel(reason);
        if (oncancel) {
          oncancel(reason);
        }
      },
    });
  }
}

class BlobStreamController {
  constructor(blob, size) {
    this.blob = blob;
    this.index = 0;
    this.chunkSize = size || 1024 * 64;
  }

  pull(controller) {
    return new Promise((resolve, reject) => {
      const bytesLeft = this.blob.size - this.index;
      if (bytesLeft <= 0) {
        controller.close();
        return resolve();
      }
      const size = Math.min(this.chunkSize, bytesLeft);
      const slice = this.blob.slice(this.index, this.index + size);
      const reader = new FileReader();
      reader.onload = () => {
        controller.enqueue(new Uint8Array(reader.result));
        resolve();
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(slice);
      this.index += size;
    });
  }
}

function blobStream(blob, size) {
  return new ReadableStream(new BlobStreamController(blob, size));
}

class ConcatStreamController {
  constructor(streams) {
    this.streams = streams;
    this.index = 0;
    this.reader = null;
    this.nextReader();
  }

  nextReader() {
    const next = this.streams[this.index++];
    this.reader = next && next.getReader();
  }

  async pull(controller) {
    if (!this.reader) {
      return controller.close();
    }
    const data = await this.reader.read();
    if (data.done) {
      this.nextReader();
      return this.pull(controller);
    }
    controller.enqueue(data.value);
  }
}

function concatStream(streams) {
  return new ReadableStream(new ConcatStreamController(streams));
}


/***/ }),
/* 21 */
/***/ (function(module, exports) {

assert.notEqual = notEqual
assert.notOk = notOk
assert.equal = equal
assert.ok = assert

module.exports = assert

function equal (a, b, m) {
  assert(a == b, m) // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert(a != b, m) // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert(!t, m)
}

function assert (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ece_js__ = __webpack_require__(29);



const encoder = new TextEncoder();
const decoder = new TextDecoder();

class Keychain {
  constructor(secretKeyB64, nonce) {
    this._nonce = nonce || 'yRCdyQ1EMSA3mo4rqSkuNQ==';
    if (secretKeyB64) {
      this.rawSecret = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(secretKeyB64);
    } else {
      this.rawSecret = crypto.getRandomValues(new Uint8Array(16));
    }
    this.secretKeyPromise = crypto.subtle.importKey(
      'raw',
      this.rawSecret,
      'HKDF',
      false,
      ['deriveKey'],
    );
    this.metaKeyPromise = this.secretKeyPromise.then(secretKey => crypto.subtle.deriveKey(
      {
        name: 'HKDF',
        salt: new Uint8Array(),
        info: encoder.encode('metadata'),
        hash: 'SHA-256',
      },
      secretKey,
      {
        name: 'AES-GCM',
        length: 128,
      },
      false,
      ['encrypt', 'decrypt'],
    ));
    this.authKeyPromise = this.secretKeyPromise.then(secretKey => crypto.subtle.deriveKey(
      {
        name: 'HKDF',
        salt: new Uint8Array(),
        info: encoder.encode('authentication'),
        hash: 'SHA-256',
      },
      secretKey,
      {
        name: 'HMAC',
        hash: { name: 'SHA-256' },
      },
      true,
      ['sign'],
    ));
  }

  get nonce() {
    return this._nonce;
  }

  set nonce(n) {
    if (n && n !== this._nonce) {
      this._nonce = n;
    }
  }

  setPassword(password, shareUrl) {
    this.authKeyPromise = crypto.subtle
      .importKey('raw', encoder.encode(password), { name: 'PBKDF2' }, false, [
        'deriveKey',
      ])
      .then(passwordKey =>
        crypto.subtle.deriveKey(
          {
            name: 'PBKDF2',
            salt: encoder.encode(shareUrl),
            iterations: 100,
            hash: 'SHA-256',
          },
          passwordKey,
          {
            name: 'HMAC',
            hash: 'SHA-256',
          },
          true,
          ['sign'],
        ));
  }

  setAuthKey(authKeyB64) {
    this.authKeyPromise = crypto.subtle.importKey(
      'raw',
      Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(authKeyB64),
      {
        name: 'HMAC',
        hash: 'SHA-256',
      },
      true,
      ['sign'],
    );
  }

  async authKeyB64() {
    const authKey = await this.authKeyPromise;
    const rawAuth = await crypto.subtle.exportKey('raw', authKey);
    return Object(__WEBPACK_IMPORTED_MODULE_0__utils__["arrayToB64"])(new Uint8Array(rawAuth));
  }

  async authHeader() {
    const authKey = await this.authKeyPromise;
    const sig = await crypto.subtle.sign(
      {
        name: 'HMAC',
      },
      authKey,
      Object(__WEBPACK_IMPORTED_MODULE_0__utils__["b64ToArray"])(this.nonce),
    );
    return `send-v1 ${Object(__WEBPACK_IMPORTED_MODULE_0__utils__["arrayToB64"])(new Uint8Array(sig))}`;
  }

  async encryptMetadata(metadata) {
    const metaKey = await this.metaKeyPromise;
    const ciphertext = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv: new Uint8Array(12),
        tagLength: 128,
      },
      metaKey,
      encoder.encode(JSON.stringify({
        name: metadata.name,
        size: metadata.size,
        type: metadata.type || 'application/octet-stream',
        manifest: metadata.manifest || {},
        roomMeta: metadata.roomMeta || {},
      })),
    );
    return ciphertext;
  }

  encryptStream(plainStream) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__ece_js__["c" /* encryptStream */])(plainStream, this.rawSecret);
  }

  decryptStream(cryptotext) {
    return Object(__WEBPACK_IMPORTED_MODULE_1__ece_js__["b" /* decryptStream */])(cryptotext, this.rawSecret);
  }

  async decryptMetadata(ciphertext) {
    const metaKey = await this.metaKeyPromise;
    const plaintext = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: new Uint8Array(12),
        tagLength: 128,
      },
      metaKey,
      ciphertext,
    );
    return JSON.parse(decoder.decode(plaintext));
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Keychain;



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Pair__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__customEvents__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__EventLogger__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Common_config_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Common_config_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__Common_config_js__);
/* global RTCSessionDescription, RTCIceCandidate, RTCPeerConnection */









const BaseStack = (specInput) => {
    const that = {};
    const specBase = specInput;
    let localDesc;
    that.remoteDesc = undefined;
    __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info('Starting Base stack', specBase);

    that.pcConfig = {
        iceServers: [],
    };

    that.con = {};
    if (specBase.iceServers !== undefined) {
        that.pcConfig.iceServers = specBase.iceServers;
    }
    if (specBase.forceTurn === true) {
        that.pcConfig.iceTransportPolicy = 'relay';
    }
    if (specBase.audio === undefined) {
        specBase.audio = true;
    }
    if (specBase.video === undefined) {
        specBase.video = true;
    }
    specBase.remoteCandidates = [];
    specBase.localCandidates = [];
    specBase.remoteDescriptionSet = false;

    that.mediaConstraints = {
        offerToReceiveVideo: (specBase.video !== undefined && specBase.video !== false),
        offerToReceiveAudio: (specBase.audio !== undefined && specBase.audio !== false),
    };

    function getPlugin() {
        return document.getElementById('WebrtcEverywherePluginId');
    }

    const IERTCSessionDescription = function (RTCSessionDescriptionInit) {
        return getPlugin().createSessionDescription(RTCSessionDescriptionInit);
    };

    const IERTCPeerConnection = function (configuration, constraints) {
        return getPlugin().createPeerConnection(configuration, constraints);
    };

    // creating peer connection object
    if (__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
        that.peerConnection = IERTCPeerConnection(that.pcConfig, that.con);
    } else {
        that.peerConnection = new RTCPeerConnection(that.pcConfig, that.con);
    }

    const gotDescriptionLocalForPublish = function (desc) {
        localDesc = desc;
        localDesc.sdp = localDesc.sdp.replace('a=sendrecv', 'a=sendonly');
        setLocalDescForOffer(false, desc);
    };

    const gotDescriptionLocalForSubscribe = function (desc) {
        localDesc = desc;
        setLocalDescForOffer(true, desc);
    };

    function maybeFixConfiguration(pcConfig) {
        if (!pcConfig) {
            return;
        }
        for (let i = 0; i < pcConfig.iceServers.length; i++) {
            if (pcConfig.iceServers[i].hasOwnProperty('urls')) {
                pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;
                delete pcConfig.iceServers[i].urls;
            }
        }
    }

    // Aux functions
    const errorCallback = (where, errorcb, message) => {
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].error('message:', message, 'in baseStack at', where);
        if (errorcb !== undefined) {
            errorcb('error');
        }
    };

    const successCallback = (message) => {
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info('Success in BaseStack', message);
    };

    const onIceCandidate = (event) => {
        let candidateObject = {};
        const candidate = event.candidate;
        if (!candidate) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info('Gathered all candidates. Sending END candidate');
            candidateObject = {
                sdpMLineIndex: -1,
                sdpMid: 'end',
                candidate: 'end',
            };
        } else {
            /* if (!candidate.candidate.match(/a=/)) {
                 candidate.candidate = `a=${candidate.candidate}`;
             }*/

            candidateObject = {
                sdpMLineIndex: candidate.sdpMLineIndex,
                sdpMid: candidate.sdpMid,
                candidate: `a=${candidate.candidate}`,
            };
        }

        if (specBase.remoteDescriptionSet) {
            specBase.callback({ type: 'candidate', candidate: candidateObject });
        } else {
            specBase.localCandidates.push(candidateObject);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info('Storing candidate: ', specBase.localCandidates.length, candidateObject);
        }
    };

    const setLocalDescForOffer = (isSubscribe, sessionDescription) => {
        localDesc = sessionDescription;
        if (!isSubscribe) {
            localDesc.sdp = that.enableSimulcast(localDesc.sdp);
        }
        if (!isSubscribe && (__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'safari')) {
            localDesc.sdp = localDesc.sdp.replace('a=sendrecv', 'a=sendonly');
        }
        localDesc.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(localDesc.sdp, specBase);
        specBase.callback({
            type: localDesc.type,
            sdp: localDesc.sdp,
        });
        //EL.info('webrtc-stack-event', customEvents.event_set_local_description, {localDesc: localDesc});
    };
    function getCodecFromMedia(medias, mediaType, codecName) {
        for (const media of medias) {
            if (media.media.toLowerCase() === mediaType.toLowerCase()) {
                for (const codec of media.codecs) {
                    if (codec.name.toLowerCase() === codecName.toLowerCase()) {
                        return codec;
                    }
                }
            }
        }
    }
    const getSDP = function (sdp, type) {
        let codecToRemove;
        let codecToKeep;
        const msg = new Object();
        msg.sdp = sdp.sdp;
        msg.type = sdp.type;
        if (type === __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC) {
            codecToRemove = getCodecFromMedia(sdp.media, 'video', 'vp8');
            codecToKeep = getCodecFromMedia(sdp.media, 'video', 'h264');
        } else if (type === __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.default) {
            codecToRemove = getCodecFromMedia(sdp.media, 'video', 'h264');
            codecToKeep = getCodecFromMedia(sdp.media, 'video', 'vp8');
            if (codecToRemove != undefined) {
                msg.sdp = msg.sdp.replace(`a=fmtp:${codecToRemove.payload} level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\r\n`, '');
            }
        } else {
            return msg;
        }
        if (codecToRemove != undefined) {
            msg.sdp = msg.sdp.replace(`a=rtpmap:${codecToRemove.payload} ${codecToRemove.name}/90000\r\n`, '');
            msg.sdp = msg.sdp.replace(`m=video 1 UDP/TLS/RTP/SAVPF ${codecToKeep.payload} ${codecToRemove.payload}\r\n`, `m=video 1 UDP/TLS/RTP/SAVPF ${codecToKeep.payload}\r\n`);
            msg.sdp = msg.sdp.replace(`m=video 1 UDP/TLS/RTP/SAVPF ${codecToRemove.payload} ${codecToKeep.payload}\r\n`, `m=video 1 UDP/TLS/RTP/SAVPF ${codecToKeep.payload}\r\n`);
            msg.sdp = msg.sdp.replace(`a=rtcp-fb:${codecToRemove.payload} ccm fir\r\n`, '');
            msg.sdp = msg.sdp.replace(`a=rtcp-fb:${codecToRemove.payload} nack\r\n`, '');
            msg.sdp = msg.sdp.replace(`a=rtcp-fb:${codecToRemove.payload} nack pli\r\n`, '');
            msg.sdp = msg.sdp.replace(`a=rtcp-fb:${codecToRemove.payload} goog-remb\r\n`, '');
        }
        return msg;
    };
    that.resetSDP = function (mediaConfiguration) {
        const msg = getSDP(that.remoteDesc, mediaConfiguration);
        that.peerConnection.createOffer({ offerToReceiveVideo: true, offerToReceiveAudio: true, iceRestart: false }).then((offer) => {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info(`OFFER: - \n${offer.sdp}`);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info(`RECVD ANSWER B4: - \n${that.remoteDesc.sdp}`);
            that.peerConnection.setLocalDescription(offer).then(() => {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info(`ANSWER: - \n${msg.sdp}`);
                that.peerConnection.setRemoteDescription(new RTCSessionDescription(msg));
            }).catch(errorCallback.bind(null, 'processAnswer', undefined));
        }).catch((reason) => {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info(reason);
        });
    };
    const processAnswer = (message, mediaConfiguration) => {
        let msg = message;
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info('Set remote and local description');
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Remote Description', msg.sdp);
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Local Description', localDesc.sdp);
        msg.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(msg.sdp, specBase);
        that.remoteDesc = JSON.parse(JSON.stringify(msg));
        if (__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
            that.peerConnection.setLocalDescription(localDesc);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info(`Remote msg details for sdp:- ${JSON.stringify(msg)}`);
            that.peerConnection.setRemoteDescription(IERTCSessionDescription(msg));
            specBase.remoteDescriptionSet = true;
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info(
                'Candidates to be added: ', specBase.remoteCandidates.length,
                specBase.remoteCandidates,
            );
            while (specBase.remoteCandidates.length > 0) {
                // IMPORTANT: preserve ordering of candidates
                that.peerConnection.addIceCandidate(specBase.remoteCandidates.shift());
            }
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info('Local candidates to send:', specBase.localCandidates.length);
            while (specBase.localCandidates.length > 0 && !that.peerConnection) {
                // IMPORTANT: preserve ordering of candidates
                specBase.callback({ type: 'candidate', candidate: specBase.localCandidates.shift() });
            }
        } else {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Remote Description', that.remoteDesc.sdp);
            that.peerConnection.setLocalDescription(localDesc).then(() => {
                // browser === safari,   version >= 12.1, mediaConfiguration === default/vp8
                // browser === safari,  browser version <= 12.0, mediaConfig === default/vp8
                // browser !== safari, mediaConfig === h264 or VP8

                if ((__WEBPACK_IMPORTED_MODULE_6__Common_config_js___default.a.browser_info.name === 'safari' && __WEBPACK_IMPORTED_MODULE_6__Common_config_js___default.a.browser_info.version >= __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_SUPPORTING_VP8 && mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC)) {
                    msg = getSDP(msg, __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.default);
                } else if ((__WEBPACK_IMPORTED_MODULE_6__Common_config_js___default.a.browser_info.name === 'safari' && __WEBPACK_IMPORTED_MODULE_6__Common_config_js___default.a.browser_info.version <= __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.SAFARI_VERSION_NOT_SUPPORTING_VP8 && mediaConfiguration !== __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC)) {
                    msg = getSDP(msg, __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.H264_CODEC);
                } else {
                    msg = getSDP(msg, __WEBPACK_IMPORTED_MODULE_3__vcxEventProperties__["a" /* default */].constant.default);
                }
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Remote Description', that.remoteDesc.sdp);
                that.peerConnection.setRemoteDescription(new RTCSessionDescription(msg)).then(() => {
                    specBase.remoteDescriptionSet = true;
                    __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info(
                        'Candidates to be added: ', specBase.remoteCandidates.length,
                        specBase.remoteCandidates,
                    );
                    //while (specBase.remoteCandidates.length > 0 && (!that.peerConnection || !that.peerConnection.remoteDescription.type)) {
                    while (specBase.remoteCandidates.length > 0 ) {
                       let cand = specBase.remoteCandidates.shift();
                        // IMPORTANT: preserve ordering of candidates
                        that.peerConnection.addIceCandidate(cand)
                        //that.peerConnection.addIceCandidate(specBase.remoteCandidates.shift())
                        .then(() => {__WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug("process answer adding remote ice cand Success: " + JSON.stringify(cand))})
                        .catch(e => {
                          __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].error("process answer Failed addIceCandidate(): " + e  + " cand: " + JSON.stringify(cand));
                        });
                    }
                    __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info('Local candidates to send:', specBase.localCandidates.length);
                    while (specBase.localCandidates.length > 0) {
                        // IMPORTANT: preserve ordering of candidates
                        specBase.callback({ type: 'candidate', candidate: specBase.localCandidates.shift() });
                    }
                }).catch(errorCallback.bind(null, 'processAnswer', undefined));
            }).catch(errorCallback.bind(null, 'processAnswer', undefined));
        }
    };
    const IERTCIceCandidate = function (RTCIceCandidateInit) {
        return getPlugin().createIceCandidate(RTCIceCandidateInit);
    };
    const processNewCandidate = (message) => {
        const msg = message;
       try {
            let obj;
            if (typeof (msg.candidate) === 'object') {
                obj = msg.candidate;
            } else {
                obj = JSON.parse(msg.candidate);
            }
            if (obj.candidate === 'end') {
                // ignore the end candidate for chrome
                console.log ("end candidates: ignore");
                return;
            }
            obj.candidate = obj.candidate.replace(/a=/g, '');
            obj.sdpMLineIndex = parseInt(obj.sdpMLineIndex, 10);
            obj.sdpMid  = (obj.sdpMid == "audio" || !specBase.audio) ? 0 : 1;
           // obj.candidate = obj.candidate.replace('a=', '');
            //obj.sdpMLineIndex = parseInt(obj.sdpMLineIndex, 10);
            const candidate =  new RTCIceCandidate(obj);
            if (specBase.remoteDescriptionSet ) {
                that.peerConnection.addIceCandidate(candidate)
                .then(() => {__WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].info("IN adding remote ice candidate Success: " + JSON.stringify(obj))})
                .catch(e => {
                  __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].error("addIceCandidate() Failed err: " + e + " cand: " + JSON.stringify(obj));
                });
            } else {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug("queuing candidates since remote description not set: " + JSON.stringify(obj));
                specBase.remoteCandidates.push(candidate);
            }
        } catch (e) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].error('Error parsing candidate error: ' + e + ' cand:' + msg.candidate);
        }
    };

    // Peerconnection events

    that.peerConnection.onicecandidate = onIceCandidate;
    that.peerConnection.onaddstream = (stream) => {
        if (that.onaddstream) {
            that.onaddstream(stream);
        }
    };
    that.peerConnection.onremovestream = (stream) => {
        if (that.onremovestream) {
            that.onremovestream(stream);
        }
    };

    that.peerConnection.oniceconnectionstatechange = (ev) => {
        if (that.oniceconnectionstatechange) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('ICE connection state changed', ev.currentTarget.iceConnectionState);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('ICE gathering state changed', ev.currentTarget.iceGatheringState);
            that.oniceconnectionstatechange(ev.currentTarget.iceConnectionState);
        }
    };
    that.peerConnection.onconnectionstatechange = (ev) => {
        if (that.onconnectionstatechange) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Peer connection state changed', that.peerConnection.connectionState);
            that.onconnectionstatechange(that.peerConnection.connectionState);
        }
    };

    // public functions

    that.enableSimulcast = (sdpInput) => {
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].error('Simulcast not implemented');
        return sdpInput;
    };
    that.updateSimulcastLayersBitrate = (bitrates) => {
        if (that.simulcast) {
            that.simulcast.spatialLayerBitrates = bitrates;
            that.setSimulcastLayersBitrate();
        }
    };

    that.setSimulcastLayersBitrate = () => {
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].error('Simulcast not implemented');
    };
    that.setSimulcast = (enable) => {
        that.simulcast = enable;
    };

    that.close = () => {
        that.state = 'closed';
        that.peerConnection.close();
    };

    that.updateSpec = (configInput, callback = () => { }) => {
        const config = configInput;
        if (config.maxVideoBW || config.maxAudioBW) {
            if (config.maxVideoBW) {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug(
                    'Maxvideo Requested:', config.maxVideoBW,
                    'limit:', specBase.limitMaxVideoBW,
                );
                if (config.maxVideoBW > specBase.limitMaxVideoBW) {
                    config.maxVideoBW = specBase.limitMaxVideoBW;
                }
                specBase.maxVideoBW = config.maxVideoBW;
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Result', specBase.maxVideoBW);
            }
            if (config.maxAudioBW) {
                if (config.maxAudioBW > specBase.limitMaxAudioBW) {
                    config.maxAudioBW = specBase.limitMaxAudioBW;
                }
                specBase.maxAudioBW = config.maxAudioBW;
            }

            localDesc.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(localDesc.sdp, specBase);
            if (config.Sdp || config.maxAudioBW) {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Updating with SDP renegotiation', specBase.maxVideoBW, specBase.maxAudioBW);
                that.peerConnection.setLocalDescription(localDesc)
                    .then(() => {
                        that.remoteDesc.sdp = __WEBPACK_IMPORTED_MODULE_0__utils_SdpHelpers__["a" /* default */].setMaxBW(that.remoteDesc.sdp, specBase);
                        return that.peerConnection.setRemoteDescription(new RTCSessionDescription(that.remoteDesc));
                    }).then(() => {
                        specBase.remoteDescriptionSet = true;
                        specBase.callback({ type: 'updatestream', sdp: localDesc.sdp });
                    }).catch(errorCallback.bind(null, 'updateSpec', callback));
            } else {
                __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug(
                    'Updating without SDP renegotiation, ' +
                    'newVideoBW:', specBase.maxVideoBW,
                    'newAudioBW:', specBase.maxAudioBW,
                );
                specBase.callback({ type: 'updatestream', sdp: localDesc.sdp });
            }
        }
        if (config.minVideoBW || (config.slideShowMode !== undefined) ||
            (config.muteStream !== undefined) || (config.qualityLayer !== undefined) ||
            (config.video !== undefined)) {
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('MinVideo Changed to ', config.minVideoBW);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('SlideShowMode Changed to ', config.slideShowMode);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('muteStream changed to ', config.muteStream);
            __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug('Video Constraints', config.video);
            specBase.callback({ type: 'updatestream', config });
        }
    };

    that.createOffer = (isSubscribe, iceRestart) => {
        if (isSubscribe !== true) {
            that.mediaConstraints = {
                offerToReceiveVideo: false,
                offerToReceiveAudio: false,
            };
        }
        if (iceRestart) {
            that.mediaConstraints.iceRestart = iceRestart;
        }
        __WEBPACK_IMPORTED_MODULE_1__utils_Logger__["default"].debug(`Creating offer :-${JSON.stringify(that.mediaConstraints)}`);
        if (__WEBPACK_IMPORTED_MODULE_2__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
            if (isSubscribe !== true) {
                that.peerConnection.createOffer(gotDescriptionLocalForPublish, errorCallback);
            } else {
                const offerConstraints = {
                    optional: [
                        { OfferToReceiveAudio: true },
                        { OfferToReceiveVideo: true },
                    ],
                };
                that.peerConnection.createOffer(gotDescriptionLocalForSubscribe, errorCallback, offerConstraints);
            }
        } else {
            that.peerConnection.createOffer(that.mediaConstraints)
                .then(setLocalDescForOffer.bind(null, isSubscribe))
                .catch(errorCallback.bind(null, 'Create Offer', undefined));
        }
    };

    that.addStream = (stream) => {
        that.peerConnection.addStream(stream);
    };
    that.addTrack = (track) => {
        that.peerConnection.addTrack(track);
    };

    that.processSignalingMessage = (msgInput, mediaConfiguration) => {
        if (msgInput.type === 'answer') {
            processAnswer(msgInput, mediaConfiguration);
        } else if (msgInput.type === 'candidate') {
            processNewCandidate(msgInput);
        }
    };

    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (BaseStack);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const SdpHelpers = {};

SdpHelpers.addSim = (spatialLayers) => {
  let line = 'a=ssrc-group:SIM';
  spatialLayers.forEach((spatialLayerId) => {
    line += ` ${spatialLayerId}`;
  });
  return `${line}\r\n`;
};

SdpHelpers.addGroup = (spatialLayerId, spatialLayerIdRtx) =>
  `a=ssrc-group:FID ${spatialLayerId} ${spatialLayerIdRtx}\r\n`;

SdpHelpers.addSpatialLayer = (cname, msid, mslabel,label, spatialLayerId, spatialLayerIdRtx) =>
  `a=ssrc:${spatialLayerId} cname:${cname}\r\n` +
  `a=ssrc:${spatialLayerId} msid:${msid}\r\n` +
  `a=ssrc:${spatialLayerId} mslabel:${mslabel}\r\n` +
  `a=ssrc:${spatialLayerId} label:${label}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} cname:${cname}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} msid:${msid}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} mslabel:${mslabel}\r\n` +
  `a=ssrc:${spatialLayerIdRtx} label:${label}\r\n`;

SdpHelpers.setMaxBW = (sdpInput, spec) => {
  let r;
  let a;
  let sdp = sdpInput;
  if (spec.video && spec.maxVideoBW) {
    sdp = sdp.replace(/b=AS:.*\r\n/g, '');
    a = sdp.match(/m=video.*\r\n/);
    if (a == null) {
      a = sdp.match(/m=video.*\n/);
    }
    if (a && (a.length > 0)) {
      r = `${a[0]}b=AS:${spec.maxVideoBW}\r\n`;
      sdp = sdp.replace(a[0], r);
    }
  }

  if (spec.audio && spec.maxAudioBW) {
    a = sdp.match(/m=audio.*\r\n/);
    if (a == null) {
      a = sdp.match(/m=audio.*\n/);
    }
    if (a && (a.length > 0)) {
      r = `${a[0]}b=AS:${spec.maxAudioBW}\r\n`;
      sdp = sdp.replace(a[0], r);
    }
  }
  return sdp;
};

SdpHelpers.enableOpusNacks = (sdpInput) => {
  let sdp = sdpInput;
  const sdpMatch = sdp.match(/a=rtpmap:(.*)opus.*\r\n/);
  if (sdpMatch !== null) {
    const theLine = `${sdpMatch[0]}a=rtcp-fb:${sdpMatch[1]}nack\r\n`;
    sdp = sdp.replace(sdpMatch[0], theLine);
  }

  return sdp;
};

/* harmony default export */ __webpack_exports__["a"] = (SdpHelpers);

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__customErrors__ = __webpack_require__(6);


const GUMErrorHandler = (err) => {
    let error = null;
    if (err.name === 'OverconstrainedError' && err.constraint === 'deviceId') {
        // device id not matched
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1142;
    } else if ((err.name == 'OverconstrainedError' || err.name == 'ConstraintNotSatisfiedError') && err.constraint === 'width') {
        //constraints can not be satisfied by devices
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1147;
    } else if ((err.name == 'OverconstrainedError' || err.name == 'ConstraintNotSatisfiedError') && err.constraint === 'height') {
        //constraints can not be satisfied by devices
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1148;
    } else if ((err.name == 'OverconstrainedError' || err.name == 'ConstraintNotSatisfiedError') && !err.constraint) {
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1149;
    } else if (err.name == 'NotFoundError' || err.name == 'DevicesNotFoundError') {
        // Device not found
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1143;
    } else if (err.name == 'NotReadableError' || err.name == 'TrackStartError') {
        //webcam or mic are already in use
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1145;
    } else if (err.name == 'NotAllowedError' || err.name == 'PermissionDeniedError') {
        // Permission denied
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1144;
    } else if (err.name == 'TypeError' || err.name == 'TypeError') {
        //empty constraints object
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1146;
    } else {
        error = __WEBPACK_IMPORTED_MODULE_0__customErrors__["a" /* default */].error_1150;
    }
    return error;
};

/* harmony default export */ __webpack_exports__["a"] = (GUMErrorHandler);


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ViewProperties__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Localization__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__Common_config__);
/*
This file is for handle VideoPlayer.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/

/* global document, L */



// import Bar from './Bar';



/*
 * VideoPlayer represents a video component that shows either a local or a remote video.
 * Ex.: const player = VideoPlayer({id: id, stream: stream, elementID: elementID});
 * A VideoPlayer is also a View component.
 */
const VideoPlayer = (spec) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__View__["a" /* default */])({});

  // Variables
  const player = Object(__WEBPACK_IMPORTED_MODULE_1__ViewProperties__["a" /* default */])().player.default;
  if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(spec.options) && __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(spec.options.player)) {
    const playerOptions = spec.options.player;
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.autoplay)) { player.autoplay = playerOptions.autoplay; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.name)) { player.name = playerOptions.name; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.nameDisplayMode)) { player.nameDisplayMode = playerOptions.nameDisplayMode; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.frameFitMode)) { player.frameFitMode = playerOptions.frameFitMode; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.skin)) { player.skin = playerOptions.skin; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.class)) { player.class = playerOptions.class; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.height)) { player.height = playerOptions.height; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.width)) { player.width = playerOptions.width; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.minHeight)) { player.minHeight = playerOptions.minHeight; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.minWidth)) { player.minWidth = playerOptions.minWidth; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.aspectRatio)) { player.aspectRatio = playerOptions.aspectRatio; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.volume)) { player.volume = playerOptions.volume; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.backgroundImg)) { player.backgroundImg = playerOptions.backgroundImg; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.media)) { player.media = playerOptions.media; }
    if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(playerOptions.loader)) {
      const loaderProp = playerOptions.loader;
      if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(loaderProp.url)) { player.loader.url = loaderProp.url; }
      player.loader.show = loaderProp.show;
      if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(loaderProp.class)) { player.loader.class = loaderProp.class; }
      if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(loaderProp.style)) { player.loader.style = loaderProp.style; }
    }
  }

  // VideoPlayer ID
  that.id = spec.id;
  // Stream that the VideoPlayer will play
  that.stream = spec.videoSource;
  // DOM element in which the VideoPlayer will be appended
  that.elementID = spec.elementID;

  // Private functions
  that.abwd = {};
  that.abwd.notification = true;
  that.abwd.lang = 'en';


  if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(spec.options) &&
    __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(spec.options.player) &&
    __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(spec.options.player.abwd)) {
    const abwdOption = spec.options.player.abwd;
    if (abwdOption.enabled === false) { that.abwd.notification = false; } else if (abwdOption.enabled === true && abwdOption.notification === 'sdk') {
      that.abwd.notification = true;
      if (abwdOption.language === 'en' || abwdOption.language === 'zh') {
        that.abwd.lang = abwdOption.language;
      } else { that.abwd.lang = 'en'; }
    } else if (abwdOption.enabled === true && abwdOption.notification === 'app') {
      that.abwd.notification = false;
      that.abwd.lang = '';
    }
  }

  const container = __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getById(spec.elementID);
  container.style.height = player.height;
  container.style.width = player.width;//that.id
  container.style.minHeight = player.minHeight;
  container.style.minWidth = player.minWidth;


  const applyRatio = (ratio, width, height, reverse) => {
    const condition = !reverse ? width * (1 / ratio) < height : width * (1 / ratio) > height;
    if (condition) {
      that.video.style.width = `${width}px`;
      that.video.style.height = `${(1 / ratio) * width}px`;

      that.video.style.top = `${-((((1 / ratio) * width) / 2) - (height / 2))}px`;
      that.video.style.left = '0px';
    } else {
      that.video.style.height = `${height}px`;
      that.video.style.width = `${ratio * height}px`;

      that.video.style.left = `${-(((ratio * height) / 2) - (width / 2))}px`;
      that.video.style.top = '0px';
    }
    that.video.style.overflow = 'hidden';
  };

  // Public functions

  // It will stop the VideoPlayer and remove it from the HTML
  that.destroy = () => {
    console.log('video player destroy ');
    that.video.pause();
    if(!__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.csp_enabled) {
      delete that.resizer;
      try {
        that.div.removeChild(bwNotContainer);
        that.div.removeChild(statsOverlay);
      } catch (error) {
        console.log ("error videoplayer.destroy() removeChild err: " + error );
      }
    } else {
    that.container.removeChild(that.div);
    }
  };

  that.resize = () => {
    const width = that.container.offsetWidth;
    const height = that.container.offsetHeight;

    if (spec.stream.screen || spec.options.crop === false || spec.stream.canvas) {
      applyRatio(16 / 9, width, height, false);
    } else if (width !== that.containerWidth || height !== that.containerHeight) {
      applyRatio(4 / 3, width, height, true);
    }
    that.containerWidth = width;
    that.containerHeight = height;
  };

  /* window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
      document.getElementById(key).value = unescape(value);
  }); */

  let elementId = spec.stream.getPlayerId(spec.vroom ? spec.vroom : spec.stream.room);
  // Container
  if(!__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.csp_enabled) {
  that.div = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({ name: 'div', id: `${elementId.player}`, class: 'vcx_player ' + player.skin + '_vcx_player' ,
                       style: {'object-position': '65% 50%'}});
                       //style: {overflow : 'hidden', 'object-position': '65% 50%'}});
  } else {
  that.div = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({ name: 'div', id: `${elementId.player}`, class: 'vcx_player ' + player.skin + '_vcx_player'});
  }

  // Loader icon
  if (player.loader.url) {
    that.loader = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({
      name: 'img', src: player.loader.url, id: `back_${that.id}`, class: `vcx_player_loader ${player.loader.class} ${player.skin}_vcx_player_loader`,
    });
    if (!player.loader.show) { that.loader.style.display = 'none'; }
  }


  //BackGround Image
  if (player.backgroundImg) {
    that.screenSaver = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({
      name: 'img', src: player.backgroundImg, id: `screen_saver_${that.id}`, class: `vcx_player_screen_saver ${player.skin}_vcx_player_screen_saver`,
    });
    that.screenSaver.style.display = 'none';
  }


  // Video tag
  let elementOptions = { name: 'video', id: `${elementId.stream}`, class: `vcx_stream ${player.skin}_vcx_stream` };
  if (spec.extraPlayerOptions.autoplay) elementOptions.autoplay = spec.extraPlayerOptions.autoplay;
  if (spec.extraPlayerOptions.playsinline) elementOptions.playsinline = spec.extraPlayerOptions.playsinline;
  that.video = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])(elementOptions);
  if (spec.stream.local) { that.video.volume = 0; }

  if (that.elementID !== undefined) {
    // Check for a passed DOM node.
    if (typeof that.elementID === 'object' &&
      typeof that.elementID.appendChild === 'function') {
      that.container = that.elementID;
    } else {
      that.container = __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getById(that.elementID);
    }
  } else {
    that.container = document.body;
  }
  that.container.appendChild(that.div);

  that.parentNode = that.div.parentNode;

  let bwNotContainer = undefined;
  let bwAlertIcon;
  let statsContainer = undefined;
  let playerButton = undefined;
  let statsOverlay = undefined;
  let statsOverlayInner = undefined;
  let leftPartition = undefined;
  let rightPartition = undefined;
  // player stats button
  if(!__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.csp_enabled) {
  statsContainer = document.createElement('div');
  statsContainer.setAttribute('id', `stats-container-${that.id}`);
  statsContainer.setAttribute('class', 'stats-container');
  statsContainer.setAttribute('style', 'display:none;');

  bwNotContainer = document.createElement('div');
  bwNotContainer.setAttribute('id', `bw-notif-${that.id}`);
  bwNotContainer.setAttribute('class', 'bw-notification');
  bwNotContainer.setAttribute('style', 'display:none;');
  if (__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo && __WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.mode && __WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.mode == 'image'){
    bwAlertIcon = document.createElement('div');
    bwAlertIcon.setAttribute('id', `icon-bw-low-${that.id}`);
    bwAlertIcon.setAttribute('class', 'icon-bw');
    //bwAlertIcon.setAttribute('title', 'low bw');
    bwAlertIcon.innerHTML = window.lowBwIcon;
    bwNotContainer.appendChild(bwAlertIcon);
  }
  playerButton = document.createElement('div');
  playerButton.setAttribute('id', `stats-button-${that.id}`);
  playerButton.setAttribute('class', 'stats-button');
  playerButton.setAttribute('title', 'Click to see stats');
  playerButton.innerHTML = window.statsIcon;

  statsContainer.appendChild(playerButton);

  statsOverlay = document.createElement('div');
  statsOverlay.setAttribute('class', 'stats-overlay');
  statsOverlay.setAttribute('id', `stats-overlay-${that.id}`);
  statsOverlay.setAttribute('style', `display: none;
            position: absolute;z-index: 3;
            padding: 5px;top: 0px;right: 0px;
            background: linear-gradient(90deg,rgb(204 41 42 / 62%),#a20a90b0);
            border-radius: 5px;color: #fff;width: 100%;`
            );

  statsOverlayInner = document.createElement('div');
  statsOverlayInner.setAttribute('class', 'stats-overlay-inner');
  statsOverlayInner.setAttribute('id', `stats-overlay-inner-${that.id}`);


  leftPartition = document.createElement('div'),
  rightPartition = document.createElement('div');
  leftPartition.setAttribute('class', 'stats-left-partition');
  leftPartition.setAttribute('id', `stats-left-part-${that.id}`);

  rightPartition.setAttribute('class', 'stats-right-partition');
  rightPartition.setAttribute('id', `stats-right-part-${that.id}`);

  playerButton.addEventListener('click', () => {
    if (statsOverlay.style.display === 'none'){
      statsOverlay.style.display = 'block';
    }
    else{
      statsOverlay.style.display = 'none';
    }
  });

  that.div.parentNode.style.position = 'relative';
  // Appending Stats container to main player container
  that.div.appendChild(statsContainer);
  // appending overlay to container
  that.div.appendChild(statsOverlay);
  statsOverlay.appendChild(statsOverlayInner);

  //Appending bw notification button
  that.div.appendChild(bwNotContainer);


  // partitions of overlay
  statsOverlayInner.appendChild(leftPartition);
  statsOverlayInner.appendChild(rightPartition);
  }

  if (that.loader) {
    that.div.appendChild(that.loader);
  }
  if (that.screenSaver) {
    that.div.appendChild(that.screenSaver);
  }

  that.div.appendChild(that.video);

  that.containerWidth = 0;
  that.containerHeight = 0;
  if(!__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.csp_enabled) {
  if (spec.options && spec.options.resizer !== false) {
    that.resizer = L.ResizeSensor(that.container, that.resize);

    that.resize();
  }
}

  // Bottom Bar
  if (spec.options.bar !== false) {
    // that.bar = Bar({
    //   elementID: `${elementId.player}`,
    //   id: that.id,
    //   stream: spec.stream,
    //   media: that.video,
    //   options: spec.options
    // });
  } else {
    // Expose a consistent object to manipulate the media.
    that.media = that.video;
  }
  //attachMediaStream(that.video,that.stream);
  that.video.srcObject = that.stream;
  // show or hide stats
  that.ShowSessionStats = (statsEnabled) => {
    if(!__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.csp_enabled) {
    if (statsEnabled === true) {
      // show stats UI
      statsContainer.setAttribute('style', 'display:block;');
      statsOverlay.setAttribute('style', 'display:block;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
    } else {
      // hide stats UI
      statsContainer.setAttribute('style', 'display:none;');
      statsOverlay.setAttribute('style', 'display:none;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
    }
  }
  };

  that.streamUpdated =  (id) =>{
    if (id != that.id){
      that.id = id;
      if (that.video){
        let elementId = spec.stream.getPlayerId(spec.vroom ? spec.vroom : spec.stream.room);
        that.div.setAttribute('id', `${elementId.player}`);
        that.video.setAttribute('id', `${elementId.stream}`);
        if (that.loader != undefined) that.loader.setAttribute('id',`back_${that.id}`);
        if (that.screenSaver != undefined) that.screenSaver.setAttribute('id',`screen_saver_${that.id}`);
        if (statsContainer != undefined) statsContainer.setAttribute('id', `stats-container-${that.id}`);
        if (bwNotContainer != undefined) bwNotContainer.setAttribute('id', `bw-notif-${that.id}`);
        if (bwAlertIcon != undefined) bwAlertIcon.setAttribute('id', `icon-bw-low-${that.id}`);
        if (playerButton != undefined) playerButton.setAttribute('id', `bw-notif-${that.id}`);
        if (statsOverlay != undefined) statsOverlay.setAttribute('id', `stats-overlay-${that.id}`);
        if (statsOverlayInner != undefined) statsOverlayInner.setAttribute('id', `stats-overlay-inner-${that.id}`);
        if (leftPartition != undefined) leftPartition.setAttribute('id', `stats-left-part-${that.id}`);
        if (rightPartition != undefined) rightPartition.setAttribute('id', `stats-right-part-${that.id}`);
      }
    }
  }
  that.setBwAlert = (enabled, type, name) => {
    if (that.abwd.notification === false) { return; }
    if(!__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.csp_enabled) {
      if (enabled === true) {
        let text = 'Low Bandwidth';
        if (__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.customLowBw) text = __WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.customLowBw;
        else if (that.abwd.lang && that.abwd.lang != ''){
          if (type === 'subscriber') text = __WEBPACK_IMPORTED_MODULE_3__Localization__["a" /* default */].abwd[that.abwd.lang].bw_alert_subscriber;
          else text = name + __WEBPACK_IMPORTED_MODULE_3__Localization__["a" /* default */].abwd[that.abwd.lang].bw_alert_publisher;
        }
        if (__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.mode == 'text'){
          console.log ("videoPlayer - setBwAlert(): setting  text id: " + that.id );
          bwNotContainer.innerText = text;
          bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px 10px;top:50%;right:50%');
          bwNotContainer.setAttribute('style','transform:translateX(50%);background:rgba(0,0,0,0.29)');
          bwNotContainer.setAttribute('style','border-radius:5px;color:rgb(255,255,255)');
        }else if (__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.mode == 'image'){
          console.log ("videoPlayer - setBwAlert(): setting  image id: "  + that.id);
          bwAlertIcon.setAttribute('title', text);
          //bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px;top:0;right:0');
          bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px;bottom:5%;right:5%');
          //bwNotContainer.setAttribute('style', 'background:rgba(0,0,0,0.29);');
          //bwNotContainer.setAttribute('style', 'background:rgba(0, 0, 0, 0.75);');
        }
      } else {
          console.log ("videoPlayer - setBwAlert(): removing image/text  id: "  + that.id);
          bwNotContainer.setAttribute('style', 'display:none');
      }
    }
  };

  that.setVideoMutedMsg = (arg) => {
    if (that.abwd.notification === false) { return; }
    if(!__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.csp_enabled) {
      if (arg.videomuted === true && arg.reason === 'bw') {
        let text = 'Video Muted';
        if (__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.customVideoMute) text = __WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.customVideoMute;
        else if (that.abwd.lang && that.abwd.lang != ''){
          text = `${arg.name} ${__WEBPACK_IMPORTED_MODULE_3__Localization__["a" /* default */].abwd[that.abwd.lang].video_muted}`;
        }
        if (__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.mode == 'text'){
          bwNotContainer.innerText = text;
          bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px 10px;top:50%;right:50%');
          bwNotContainer.setAttribute('style','transform:translateX(50%);background:rgba(0,0,0,0.29)');
          bwNotContainer.setAttribute('style','border-radius:5px;color:rgb(255,255,255)');
        }else if (__WEBPACK_IMPORTED_MODULE_4__Common_config___default.a.alertNotifyInfo.mode == 'image'){
          bwAlertIcon.setAttribute('title', text);
          //bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px;bottom:5%;right:5%');
          bwNotContainer.setAttribute('style', 'display:block;position:absolute;z-index:3;padding:5px');
          //bwNotContainer.setAttribute('style', 'background:rgba(0, 0, 0, 0.75);');
        }
      } else {
        bwNotContainer.setAttribute('style', 'display:none');
      }
    }
  };

  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (VideoPlayer);


//////////////////
// WEBPACK FOOTER
// ./src/views/VideoPlayer.js
// module id = 139
// module chunks = 0


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const localization = {
  abwd: {
    en: {
      bw_alert_publisher: ' Low upload bandwidth',
      bw_alert_subscriber: ' Low Download bandwidth',
      video_muted: ' Video muted due to low bandwidth',
    },
    zh: {
      bw_alert_publisher: ' ',
      bw_alert_subscriber: '',
      video_muted: ' ',
    },
  },
};

/* harmony default export */ __webpack_exports__["a"] = (localization);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (immutable) */ __webpack_exports__["c"] = encryptStream;
/* harmony export (immutable) */ __webpack_exports__["b"] = decryptStream;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__streams__ = __webpack_require__(20);



const NONCE_LENGTH = 12;
const TAG_LENGTH = 16;
const KEY_LENGTH = 16;
const MODE_ENCRYPT = 'encrypt';
const MODE_DECRYPT = 'decrypt';
const ECE_RECORD_SIZE = 1024 * 64;
/* harmony export (immutable) */ __webpack_exports__["a"] = ECE_RECORD_SIZE;


const encoder = new TextEncoder();

function generateSalt(len) {
  const randSalt = new Uint8Array(len);
  crypto.getRandomValues(randSalt);
  return randSalt.buffer;
}

class ECETransformer {
  constructor(mode, ikm, rs, salt) {
    this.mode = mode;
    this.prevChunk;
    this.seq = 0;
    this.firstchunk = true;
    this.rs = rs;
    this.ikm = ikm.buffer;
    this.salt = salt;
  }

  async generateKey() {
    const inputKey = await crypto.subtle.importKey(
      'raw',
      this.ikm,
      'HKDF',
      false,
      ['deriveKey'],
    );

    return crypto.subtle.deriveKey(
      {
        name: 'HKDF',
        salt: this.salt,
        info: encoder.encode('Content-Encoding: aes128gcm\0'),
        hash: 'SHA-256',
      },
      inputKey,
      {
        name: 'AES-GCM',
        length: 128,
      },
      true, // Edge polyfill requires key to be extractable to encrypt :/
      ['encrypt', 'decrypt'],
    );
  }

  async generateNonceBase() {
    const inputKey = await crypto.subtle.importKey(
      'raw',
      this.ikm,
      'HKDF',
      false,
      ['deriveKey'],
    );

    const base = await crypto.subtle.exportKey(
      'raw',
      await crypto.subtle.deriveKey(
        {
          name: 'HKDF',
          salt: this.salt,
          info: encoder.encode('Content-Encoding: nonce\0'),
          hash: 'SHA-256',
        },
        inputKey,
        {
          name: 'AES-GCM',
          length: 128,
        },
        true,
        ['encrypt', 'decrypt'],
      ),
    );

    return Buffer.from(base.slice(0, NONCE_LENGTH));
  }

  generateNonce(seq) {
    if (seq > 0xffffffff) {
      throw new Error('record sequence number exceeds limit');
    }
    const nonce = Buffer.from(this.nonceBase);
    const m = nonce.readUIntBE(nonce.length - 4, 4);
    const xor = (m ^ seq) >>> 0; //forces unsigned int xor
    nonce.writeUIntBE(xor, nonce.length - 4, 4);

    return nonce;
  }

  pad(data, isLast) {
    const len = data.length;
    if (len + TAG_LENGTH >= this.rs) {
      throw new Error('data too large for record size');
    }

    if (isLast) {
      const padding = Buffer.alloc(1);
      padding.writeUInt8(2, 0);
      return Buffer.concat([data, padding]);
    }
    const padding = Buffer.alloc(this.rs - len - TAG_LENGTH);
    padding.fill(0);
    padding.writeUInt8(1, 0);
    return Buffer.concat([data, padding]);
  }

  unpad(data, isLast) {
    for (let i = data.length - 1; i >= 0; i--) {
      if (data[i]) {
        if (isLast) {
          if (data[i] !== 2) {
            throw new Error('delimiter of final record is not 2');
          }
        } else if (data[i] !== 1) {
          throw new Error('delimiter of not final record is not 1');
        }
        return data.slice(0, i);
      }
    }
    throw new Error('no delimiter found');
  }

  createHeader() {
    const nums = Buffer.alloc(5);
    nums.writeUIntBE(this.rs, 0, 4);
    nums.writeUIntBE(0, 4, 1);
    return Buffer.concat([Buffer.from(this.salt), nums]);
  }

  readHeader(buffer) {
    if (buffer.length < 21) {
      throw new Error('chunk too small for reading header');
    }
    const header = {};
    header.salt = buffer.buffer.slice(0, KEY_LENGTH);
    header.rs = buffer.readUIntBE(KEY_LENGTH, 4);
    const idlen = buffer.readUInt8(KEY_LENGTH + 4);
    header.length = idlen + KEY_LENGTH + 5;
    return header;
  }

  async encryptRecord(buffer, seq, isLast) {
    const nonce = this.generateNonce(seq);
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv: nonce },
      this.key,
      this.pad(buffer, isLast),
    );
    return Buffer.from(encrypted);
  }

  async decryptRecord(buffer, seq, isLast) {
    const nonce = this.generateNonce(seq);
    const data = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: nonce,
        tagLength: 128,
      },
      this.key,
      buffer,
    );

    return this.unpad(Buffer.from(data), isLast);
  }

  async start(controller) {
    if (this.mode === MODE_ENCRYPT) {
      this.key = await this.generateKey();
      this.nonceBase = await this.generateNonceBase();
      controller.enqueue(this.createHeader());
    } else if (this.mode !== MODE_DECRYPT) {
      throw new Error('mode must be either encrypt or decrypt');
    }
  }

  async transformPrevChunk(isLast, controller) {
    if (this.mode === MODE_ENCRYPT) {
      controller.enqueue(await this.encryptRecord(this.prevChunk, this.seq, isLast));
      this.seq++;
    } else {
      if (this.seq === 0) {
        //the first chunk during decryption contains only the header
        const header = this.readHeader(this.prevChunk);
        this.salt = header.salt;
        this.rs = header.rs;
        this.key = await this.generateKey();
        this.nonceBase = await this.generateNonceBase();
      } else {
        controller.enqueue(await this.decryptRecord(this.prevChunk, this.seq - 1, isLast));
      }
      this.seq++;
    }
  }

  async transform(chunk, controller) {
    if (!this.firstchunk) {
      await this.transformPrevChunk(false, controller);
    }
    this.firstchunk = false;
    this.prevChunk = Buffer.from(chunk.buffer);
  }

  async flush(controller) {
    //console.log('ece stream ends')
    if (this.prevChunk) {
      await this.transformPrevChunk(true, controller);
    }
  }
}

class StreamSlicer {
  constructor(rs, mode) {
    this.mode = mode;
    this.rs = rs;
    this.chunkSize = mode === MODE_ENCRYPT ? rs - 17 : 21;
    this.partialChunk = new Uint8Array(this.chunkSize); //where partial chunks are saved
    this.offset = 0;
  }

  send(buf, controller) {
    controller.enqueue(buf);
    if (this.chunkSize === 21 && this.mode === MODE_DECRYPT) {
      this.chunkSize = this.rs;
    }
    this.partialChunk = new Uint8Array(this.chunkSize);
    this.offset = 0;
  }

  //reslice input into record sized chunks
  transform(chunk, controller) {
    //console.log('Received chunk with %d bytes.', chunk.byteLength)
    let i = 0;

    if (this.offset > 0) {
      const len = Math.min(chunk.byteLength, this.chunkSize - this.offset);
      this.partialChunk.set(chunk.slice(0, len), this.offset);
      this.offset += len;
      i += len;

      if (this.offset === this.chunkSize) {
        this.send(this.partialChunk, controller);
      }
    }

    while (i < chunk.byteLength) {
      const remainingBytes = chunk.byteLength - i;
      if (remainingBytes >= this.chunkSize) {
        const record = chunk.slice(i, i + this.chunkSize);
        i += this.chunkSize;
        this.send(record, controller);
      } else {
        const end = chunk.slice(i, i + remainingBytes);
        i += end.byteLength;
        this.partialChunk.set(end);
        this.offset = end.byteLength;
      }
    }
  }

  flush(controller) {
    if (this.offset > 0) {
      controller.enqueue(this.partialChunk.slice(0, this.offset));
    }
  }
}

/*
input: a ReadableStream containing data to be transformed
key:  Uint8Array containing key of size KEY_LENGTH
rs:   int containing record size, optional
salt: ArrayBuffer containing salt of KEY_LENGTH length, optional
*/
function encryptStream(
  input,
  key,
  rs = ECE_RECORD_SIZE,
  salt = generateSalt(KEY_LENGTH),
) {
  const mode = 'encrypt';
  const inputStream = Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(input, new StreamSlicer(rs, mode));
  return Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(inputStream, new ECETransformer(mode, key, rs, salt));
}

/*
input: a ReadableStream containing data to be transformed
key:  Uint8Array containing key of size KEY_LENGTH
rs:   int containing record size, optional
*/
function decryptStream(input, key, rs = ECE_RECORD_SIZE) {
  const mode = 'decrypt';
  const inputStream = Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(input, new StreamSlicer(rs, mode));
  return Object(__WEBPACK_IMPORTED_MODULE_1__streams__["c" /* transformStream */])(inputStream, new ECETransformer(mode, key, rs));
}

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(17).Buffer))

/***/ }),
/* 30 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var splice = __webpack_require__(57)
var nanotiming = __webpack_require__(58)
var assert = __webpack_require__(21)

module.exports = Nanobus

function Nanobus (name) {
  if (!(this instanceof Nanobus)) return new Nanobus(name)

  this._name = name || 'nanobus'
  this._starListeners = []
  this._listeners = {}
}

Nanobus.prototype.emit = function (eventName) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.emit: eventName should be type string or symbol')

  var data = []
  for (var i = 1, len = arguments.length; i < len; i++) {
    data.push(arguments[i])
  }

  var emitTiming = nanotiming(this._name + "('" + eventName.toString() + "')")
  var listeners = this._listeners[eventName]
  if (listeners && listeners.length > 0) {
    this._emit(this._listeners[eventName], data)
  }

  if (this._starListeners.length > 0) {
    this._emit(this._starListeners, eventName, data, emitTiming.uuid)
  }
  emitTiming()

  return this
}

Nanobus.prototype.on = Nanobus.prototype.addListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.on: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.on: listener should be type function')

  if (eventName === '*') {
    this._starListeners.push(listener)
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = []
    this._listeners[eventName].push(listener)
  }
  return this
}

Nanobus.prototype.prependListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.prependListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.prependListener: listener should be type function')

  if (eventName === '*') {
    this._starListeners.unshift(listener)
  } else {
    if (!this._listeners[eventName]) this._listeners[eventName] = []
    this._listeners[eventName].unshift(listener)
  }
  return this
}

Nanobus.prototype.once = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.once: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.once: listener should be type function')

  var self = this
  this.on(eventName, once)
  function once () {
    listener.apply(self, arguments)
    self.removeListener(eventName, once)
  }
  return this
}

Nanobus.prototype.prependOnceListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.prependOnceListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.prependOnceListener: listener should be type function')

  var self = this
  this.prependListener(eventName, once)
  function once () {
    listener.apply(self, arguments)
    self.removeListener(eventName, once)
  }
  return this
}

Nanobus.prototype.removeListener = function (eventName, listener) {
  assert.ok(typeof eventName === 'string' || typeof eventName === 'symbol', 'nanobus.removeListener: eventName should be type string or symbol')
  assert.equal(typeof listener, 'function', 'nanobus.removeListener: listener should be type function')

  if (eventName === '*') {
    this._starListeners = this._starListeners.slice()
    return remove(this._starListeners, listener)
  } else {
    if (typeof this._listeners[eventName] !== 'undefined') {
      this._listeners[eventName] = this._listeners[eventName].slice()
    }

    return remove(this._listeners[eventName], listener)
  }

  function remove (arr, listener) {
    if (!arr) return
    var index = arr.indexOf(listener)
    if (index !== -1) {
      splice(arr, index, 1)
      return true
    }
  }
}

Nanobus.prototype.removeAllListeners = function (eventName) {
  if (eventName) {
    if (eventName === '*') {
      this._starListeners = []
    } else {
      this._listeners[eventName] = []
    }
  } else {
    this._starListeners = []
    this._listeners = {}
  }
  return this
}

Nanobus.prototype.listeners = function (eventName) {
  var listeners = eventName !== '*'
    ? this._listeners[eventName]
    : this._starListeners

  var ret = []
  if (listeners) {
    var ilength = listeners.length
    for (var i = 0; i < ilength; i++) ret.push(listeners[i])
  }
  return ret
}

Nanobus.prototype._emit = function (arr, eventName, data, uuid) {
  if (typeof arr === 'undefined') return
  if (arr.length === 0) return
  if (data === undefined) {
    data = eventName
    eventName = null
  }

  if (eventName) {
    if (uuid !== undefined) {
      data = [eventName].concat(data, uuid)
    } else {
      data = [eventName].concat(data)
    }
  }

  var length = arr.length
  for (var i = 0; i < length; i++) {
    var listener = arr[i]
    listener.apply(listener, data)
  }
}


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Room__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Stream__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__views_ViewProperties__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__views_VideoPlayer__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__Common_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__clientHealth__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__applicationData__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__hlsStreaming__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__hlsStreaming___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10__hlsStreaming__);











// eslint-disable-next-line
__webpack_require__(80);
// eslint-disable-next-line
if(!__WEBPACK_IMPORTED_MODULE_7__Common_config___default.a.csp_enabled) {
  __webpack_require__(82);
}
const EnxRtc = {
  Logger: __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"],
  clientDiagnostics: __WEBPACK_IMPORTED_MODULE_8__clientHealth__["a" /* default */].clientDiagnostics,
  clientBitrate: __WEBPACK_IMPORTED_MODULE_8__clientHealth__["a" /* default */].clientBitrate,
  appData: __WEBPACK_IMPORTED_MODULE_9__applicationData__["a" /* default */],
  audience: __WEBPACK_IMPORTED_MODULE_10__hlsStreaming___default.a,
  EnxRoom: __WEBPACK_IMPORTED_MODULE_1__Room__["a" /* default */].bind(null, undefined, undefined),
  Event: __WEBPACK_IMPORTED_MODULE_2__Events__["b" /* Event */],
  RoomEvent: __WEBPACK_IMPORTED_MODULE_2__Events__["e" /* RoomEvent */],
  StreamEvent: __WEBPACK_IMPORTED_MODULE_2__Events__["f" /* StreamEvent */],
  EnxStream: __WEBPACK_IMPORTED_MODULE_3__Stream__["a" /* default */].bind(null, undefined),
  VideoPlayer: __WEBPACK_IMPORTED_MODULE_5__views_VideoPlayer__["a" /* default */],
  ViewProperties: __WEBPACK_IMPORTED_MODULE_4__views_ViewProperties__["a" /* default */],
  isSupported: __WEBPACK_IMPORTED_MODULE_7__Common_config___default.a.is_supported,
  version: __WEBPACK_IMPORTED_MODULE_7__Common_config___default.a.product.version,
  getDevices: __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].getDevice,
  switchMediaDevice: __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].switchMediaDevice,
  notifyDeviceUpdate: __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].notifyDeviceUpdate,
  joinRoom: __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].joinRoom,
  listParticipants: __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].listParticipants,
  getRoom: __WEBPACK_IMPORTED_MODULE_6__VcxQuickApi__["a" /* default */].getRoom,
  browserInfo: __WEBPACK_IMPORTED_MODULE_7__Common_config___default.a.browser_info,
};
/* harmony default export */ __webpack_exports__["default"] = (EnxRtc);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},v="en",D={};D[v]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return v;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(v=i),i||!r&&v},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var v=this.$locale().weekStart||0,D=(y<v?y+7:y)-v;return $(r?m-D:m+(6-D),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,v=O.m(this,M);return v=(l={},l[c]=v/12,l[f]=v,l[h]=v/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?v:O.a(v)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[v],w.Ls=D,w.p={},w}));

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if(!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true,
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BaseStack__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Logger__ = __webpack_require__(0);




const ChromeStableStack = (specInput) => {
  __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info('Starting Chrome stable stack', specInput);
  const spec = specInput;
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__BaseStack__["a" /* default */])(specInput);
  const defaultSimulcastSpatialLayers = 2;

  that.enableSimulcast = (sdpInput) => {
    let result;
    let sdp = sdpInput;
    if (!spec.video) {
      return sdp;
    }
    if (!spec.simulcast) {
      return sdp;
    }
    that.simulcast = spec.simulcast;

    // TODO(javier): Improve the way we check for current video ssrcs
    const matchGroup = sdp.match(/a=ssrc-group:FID ([0-9]*) ([0-9]*)\r?\n/);
    if (!matchGroup || (matchGroup.length <= 0)) {
      return sdp;
    }
    // TODO (pedro): Consider adding these to SdpHelpers
    const numSpatialLayers = spec.simulcast.numSpatialLayers || defaultSimulcastSpatialLayers;
    const baseSsrc = parseInt(matchGroup[1], 10);
    const baseSsrcRtx = parseInt(matchGroup[2], 10);
    const cname = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} cname:(.*)\r?\n`))[1];
    const msid = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} msid:(.*)\r?\n`))[1];
    const mslabels = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} mslabel:(.*)\r?\n`));
    const mslabel = mslabels != null ? mslabels[1]: undefined;
    const labels = sdp.match(new RegExp(`a=ssrc:${matchGroup[1]} label:(.*)\r?\n`));
    const label = labels != null ? labels[1] : undefined;

    sdp.match(new RegExp(`a=ssrc:${matchGroup[1]}.*\r?\n`, 'g')).forEach((line) => {
      sdp = sdp.replace(line, '');
    });
    sdp.match(new RegExp(`a=ssrc:${matchGroup[2]}.*\r?\n`, 'g')).forEach((line) => {
      sdp = sdp.replace(line, '');
    });

    const spatialLayers = [baseSsrc];
    const spatialLayersRtx = [baseSsrcRtx];

    for (let i = 1; i < numSpatialLayers; i += 1) {
      spatialLayers.push(baseSsrc + (i * 1000));
      spatialLayersRtx.push(baseSsrcRtx + (i * 1000));
    }

    result = __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].addSim(spatialLayers);
    let spatialLayerId;
    let spatialLayerIdRtx;
    for (let i = 0; i < spatialLayers.length; i += 1) {
      spatialLayerId = spatialLayers[i];
      spatialLayerIdRtx = spatialLayersRtx[i];
      result += __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].addGroup(spatialLayerId, spatialLayerIdRtx);
    }

    for (let i = 0; i < spatialLayers.length; i += 1) {
      spatialLayerId = spatialLayers[i];
      spatialLayerIdRtx = spatialLayersRtx[i];
      result += __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].addSpatialLayer(
        cname,
        msid, mslabel, label, spatialLayerId, spatialLayerIdRtx,
      );
    }
    result += 'a=x-google-flag:conference\r\n';
    return sdp.replace(matchGroup[0], result);
  };
  const setBitrateForVideoLayers = (sender) => {
    if (typeof sender.getParameters !== 'function' || typeof sender.setParameters !== 'function') {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning('Cannot set simulcast layers bitrate: getParameters or setParameters is not available');
      return;
    }
    const parameters = sender.getParameters();
    Object.keys(that.simulcast.spatialLayerBitrates).forEach((key) => {
      if (parameters.encodings[key] !== undefined) {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error(`Setting bitrate for layer ${key}, bps: ${that.simulcast.spatialLayerBitrates[key]}`);
        parameters.encodings[key].maxBitrate = that.simulcast.spatialLayerBitrates[key];
        console.log(`setting bitrate for layer ${key} bitratebps: ${JSON.stringify(that.simulcast.spatialLayerBitrates[key])}`);
      }
    });
    sender.setParameters(parameters)
      .then((result) => {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info('Success setting simulcast layer bitrates', result);
      })
      .catch((e) => {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning('Error setting simulcast layer bitrates', e);
      });
  };

  that.setSimulcastLayersBitrate = () => {
    if (that.simulcast && that.simulcast.spatialLayerBitrates) {
      that.peerConnection.getSenders().forEach((sender) => {
        if (sender.track.kind === 'video') {
          setBitrateForVideoLayers(sender);
        }
      });
    }
  };
  that.setStartVideoBW = (sdpInfo) => {
    if (that.video && spec.startVideoBW) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug(`startVideoBW requested: ${spec.startVideoBW}`);
      __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].setParamForCodecs(sdpInfo, 'video', 'x-google-start-bitrate', spec.startVideoBW);
    }
  };

  that.setHardMinVideoBW = (sdpInfo) => {
    if (that.video && spec.hardMinVideoBW) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug(`hardMinVideoBW requested: ${spec.hardMinVideoBW}`);
      __WEBPACK_IMPORTED_MODULE_1__utils_SdpHelpers__["a" /* default */].setParamForCodecs(sdpInfo, 'video', 'x-google-min-bitrate', spec.hardMinVideoBW);
    }
  };


  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (ChromeStableStack);


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__BaseStack__ = __webpack_require__(23);



const FirefoxStack = (specInput) => {
  __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('Starting Firefox stack');
  const that = Object(__WEBPACK_IMPORTED_MODULE_1__BaseStack__["a" /* default */])(specInput);
  const spec = specInput;

  that.enableSimulcast = (sdp) => {
    if (!spec.video || !spec.simulcast) {
      return sdp;
    }
    that.peerConnection.getSenders().forEach((sender) => {
      if (sender.track.kind === 'video') {
        sender.getParameters();
        sender.setParameters({
          encodings: [{
            rid: 'spam',
            active: true,
            priority: 'high',
            maxBitrate: 40000,
            maxHeight: 640,
            maxWidth: 480,
          }, {
            rid: 'egg',
            active: true,
            priority: 'medium',
            maxBitrate: 10000,
            maxHeight: 320,
            maxWidth: 240,
          }],
        });
      }
    });
    return sdp;
  };
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (FirefoxStack);


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(0);


const FcStack = (spec) => {
  /*
  spec.callback({
      type: sessionDescription.type,
      sdp: sessionDescription.sdp
  });
  */
  const that = {};

  that.pcConfig = {};

  that.peerConnection = {};
  that.desc = {};
  that.signalCallback = undefined;

  that.close = () => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('Close FcStack');
  };

  that.createOffer = () => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug('FCSTACK: CreateOffer');
  };

  that.addStream = (stream) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug('FCSTACK: addStream', stream);
  };
  that.addTrack = (track) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug('FCSTACK: addTrack', stream);
  };

  that.processSignalingMessage = (msg) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug('FCSTACK: processSignaling', msg);
    if (that.signalCallback !== undefined) { that.signalCallback(msg); }
  };

  that.sendSignalingMessage = (msg) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug('FCSTACK: Sending signaling Message', msg);
    spec.callback(msg);
  };

  that.setSignalingCallback = (callback = () => { }) => {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug('FCSTACK: Setting signalling callback');
    that.signalCallback = callback;
  };
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (FcStack);


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SocketEvent */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Socket; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_socket_io_esm_min__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__customEvents__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EventLogger__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__customErrors__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__Common_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Events__ = __webpack_require__(4);
/*
This file is for handle socket events.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date : 28/11/2017 11:14 AM
*/

/* global */
 // This package is for fetch global event nameProp
 // This package is to use socket library functions
 // This package is for manage console log.






// This package is needed for managing events
const SocketEvent = (type, specInput) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["b" /* Event */])({ type });
  that.args = specInput.args;
  return that; // This is a object of events handler
};

/*
 * Class Stream represents a local or a remote Stream in the Room. It will handle the WebRTC
 * stream and identify the stream and where it should be drawn.
 */
const Socket = (newIo) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["c" /* EventDispatcher */])();
  const defaultCallback = () => { };
  const messageBuffer = []; // This is an array to store event message as a buffer.

  that.CONNECTING = Symbol('connecting');
  that.CONNECTED = Symbol('connected');
  that.RECONNECTING = Symbol('reconnecting');
  that.DISCONNECTED = Symbol('disconnected');

  const WEBSOCKET_NORMAL_CLOSURE = 1000; // This is a variable used to store socket closure status code in normal state
  // This can be modified and varry denpendending on webscket closure resons
  that.state = that.DISCONNECTED;
  that.IO = newIo === undefined ? __WEBPACK_IMPORTED_MODULE_1__lib_socket_io_esm_min__["a" /* default */] : newIo;

  let socket;

  const emit = (type, ...args) => { // Function that calls Events' emit function
    that.emit(SocketEvent(type, { args }));
  };

  const addToBuffer = (type, message, callback, error) => { // Function defination that store a message in buffer array
    messageBuffer.push([type, message, callback, error]);
  };

  const removeFromBuffer = (type, message, callback, error) => { // Function defination that removes a message from buffer array
    const index = messageBuffer.indexOf([type, message, callback, error]);
    if (index !== -1) { // Checking : If the message sent to remove is present in buffer array or not
      messageBuffer.splice(index, 1);
    }
  };

  const executeBuffer = () => {
    __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info('execute buffer');					// Function to send all message to connected socket stored in buffer
    if (that.state !== that.CONNECTED) {
      return;
    }
    messageBuffer.forEach((message) => {
      that.sendMessage(...message);
    });
  };

  const checkSSL = () => ((window.location.protocol == 'https:'));
  that.connect = (args, callback = defaultCallback, error = defaultCallback) => {
    let token = args.token;
    const options = {
      timeout: args.timeoutMs,
      //reconnection: false,
      //  reconnectionAttempts: 3,
      secure: token.secure,
      forceNew: true,
      allowEIO4:true,
      transports: ['websocket'],
      rejectUnauthorized: true,
    };
    if (args.retryAttempts) {
      options.reconnection = true;
      options.reconnectionAttempts = args.reconnectionAttempts;
    }else options.reconnection = false;
     options.reconnection = (args.retryAttempts ? true: false);

    if(__WEBPACK_IMPORTED_MODULE_6__Common_config___default.a.socketiopath != undefined) {
      options.path = __WEBPACK_IMPORTED_MODULE_6__Common_config___default.a.socketiopath;
    }
    const transport = checkSSL() ? 'wss://' : 'ws://';
    let host = token.host;
    if (token.gateway == undefined || token.gateway == null || token.gateway == '') {
      host = token.host;
    } else {
      host = token.gateway;
      options.query = `X-Forwarded-Host=${token.host}`;
    }
    __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].info(`Connecting socket with option:- ${JSON.stringify(options)}`);
    console.log(`Connecting socket with host:- ${host}`);
    that.state = that.CONNECTING;
    socket = that.IO.connect(transport + host, options);

    // Hack to know the exact reason of the WS closure (socket.io does not publish it)
    let closeCode = WEBSOCKET_NORMAL_CLOSURE;
    const socketOnCloseFunction = socket.io.engine.transport.ws.onclose;
    socket.io.engine.transport.ws.onclose = (closeEvent) => {
      if (!that.socket || that.socket.connected == false || that.socket.disconnected == true){
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning('WebSocket closed, code: ' + closeEvent.code + ' curr sock undefined  or disconnected' );
        closeCode = closeEvent.code;
        socketOnCloseFunction(closeEvent);
        emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.error);
        if (that.state == that.CONNECTING){
          callback(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1161);
        }
        that.state = that.DISCONNECTED;
      }else {
        __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning('WebSocket closed, Ignoring old sock code: ' + closeEvent.code + ' curr sock id ' + that.socket.id +
                       ' connected: ' + that.socket.connected + ' disconnected: ' + that.socket.disconnected);
      }
    };
    socket.io.engine.transport.ws.onerror = (errorEvent) => { };
    that.socket = socket;

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_awaited, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_awaited));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_joined, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_joined));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_connected, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_connected));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_disconnected, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_disconnected));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.new_active_talker, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.new_active_talker));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onAddStream));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.signaling_message_peer, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.signaling_message_peer));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.publish_me, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.publish_me));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.unpublish_me, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.unpublish_me));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthAlert, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthAlert));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthEvents, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onBandwidthEvents));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onSelfBandwidthAlert, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onSelfBandwidthAlert));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveTrack, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveTrack));
    // We receive an event of new data in one of the streams
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onDataStream, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onDataStream));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_awaited, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_awaited));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_record_on, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_record_on));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_record_off, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_record_off));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_audio, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_audio));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_audio, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_audio));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_video, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_mute_video));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_video, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.hard_unmute_video));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.auxilary_publish_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.auxilary_publish_events));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.share_started, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.share_started));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.share_stopped, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.share_stopped));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.screen_share_override, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.screen_share_override));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.stop_sharing, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.stop_sharing));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.update_layout, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.update_layout));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.custom_data_saved, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.custom_data_saved));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.custom_data_updated, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.custom_data_updated));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.streaming_uri, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.streaming_uri));

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.canvas_started, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.canvas_started));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.canvas_stopped, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.canvas_stopped));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.invite_breakout_room, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.invite_breakout_room));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.user_joined_breakout_room, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.user_joined_breakout_room));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.user_left_breakout_room, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.user_left_breakout_room));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.breakout_room_destroyed, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.breakout_room_destroyed));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.transcription_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.transcription_events));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.analytics_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.analytics_events));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.meeting_summary_subscription_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.meeting_summary_subscription_events));

    //Dial State Events
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.dial_state_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.dial_state_events));

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_audio_muted, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_audio_muted));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_audio_unmuted, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_audio_unmuted));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_video_muted, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_video_muted));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_video_unmuted, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].UserEvent.user_video_unmuted));

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.media_engine_connecting));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onUpdateAttributeStream, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onUpdateAttributeStream));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRemoveStream));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_connected, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_connected));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_updated, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_updated));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_disconnected));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.user_subscribed));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_requested, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_requested));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_granted, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_granted));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_not_granted, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_not_granted));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_released, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_released));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute_room, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.hard_mute_room));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.hard_unmute_room, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.hard_unmute_room));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.switched_room, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.switched_room));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.data_stream_room, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.data_stream_room));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.user_role_changed, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.user_role_changed));
    // manu stats
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onStatSubscription, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onStatSubscription));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onStreamingNotification, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onStreamingNotification));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onHlsStreamingNotification, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onHlsStreamingNotification));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onHlsStreamingNotificationToPublisher, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onHlsStreamingNotificationToPublisher));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onLiveRecordingNotification, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onLiveRecordingNotification));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingOn, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingOn));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingOff, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingOff));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingFailed, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.onRoomLiveRecordingFailed));

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.switch_codec, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.switch_codec));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.generic_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.generic_events));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.room_management_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.room_management_events));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_management_events, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.floor_management_events));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_on, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_on));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_on, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_on));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_off, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.room_transcription_off));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.self_transcription_on, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.self_transcription_on));
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.self_transcription_off, emit.bind(that, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].RoomEvent.self_transcription_off));


    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, (reason) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, that.id, reason);
      if (closeCode !== WEBSOCKET_NORMAL_CLOSURE) {
        socket.close();
        emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, reason);
        return;
        /*  emit( VcxEventProperties.SocketEvent.disconnect, reason );
          that.state = that.RECONNECTING;
          return;  */
      }
      socket.close();
      emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, reason);
    });

    /*  From here starts hadling different socket events which are called on socket   */
    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.connect_timeout, (err) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.connect_timeout}, id:`, that.id, ', error:', err.message);
      socket.close();
      emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, err.message);
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.connection_failed, () => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.connection_failed}, id:`, that.id);
      emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.connection_failed, { streamId: that.id });
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.connect_error, (err) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.connect_error}, id:`, that.id, ', error:', err.message);
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.error, (err) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.error}, id:`, that.id, ', error:', err.message);
      emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.error);
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnecting, (attemptNumber) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnecting}, id:`, that.id, ', attempt:', attemptNumber);
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect, (attemptNumber) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnected}, id:`, that.id, ', attempt:', attemptNumber);
      that.state = that.CONNECTED;
      socket.emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnected, that.id);
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].info('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_reconnect_socket_success, { error: {} });
      executeBuffer();
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect_attempt, (attemptNumber) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect_attempt}, id:`, that.id, ', attempt:', attemptNumber);
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect_failed, () => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].warning(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect_failed}, id:`, that.id);
      that.state = that.DISCONNECTED;
      emit(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.disconnect, __WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect_failed);
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_reconnect_socket_failed, { error: {} });
    });

    socket.on(__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect_error, (err) => {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug(`${__WEBPACK_IMPORTED_MODULE_0__vcxEventProperties__["a" /* default */].SocketEvent.reconnect_error}, id:`, that.id, ', error:', err.message);
    });

    // First message with the token to the connected socket
    that.sendMessage('token', token, (response) => {
      that.state = that.CONNECTED;
      that.id = response.clientId;
      callback(response);
    }, error);
  };

  that.disconnect = () => {
    __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug('socket js disconnect the socket');
    that.state = that.DISCONNECTED;
    socket.disconnect();
  };

  // Function to send a message to the server socket using socket.io
  that.sendMessage = (type, msg, callback = defaultCallback, error = defaultCallback) => {
    if (that.state === that.DISCONNECTED && type !== 'token') {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error('Trying to send a message over a disconnected Socket');
      callback(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1163);
      return;
    }
    if (that.state === that.RECONNECTING) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug('sendmessage socket state is reconnecting');
      addToBuffer(type, msg, callback, error);
      callback(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1164);
      return;
    }

    if (msg) {
      socket.emit(type, msg, (respType, resp) => {
        if (respType === 'success') {
          callback(resp);
        } else if (respType === 'error') {
          __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].error('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, { type, respType, resp });
          error(resp);
        } else if ((resp == undefined || resp == null) && respType != undefined && (respType === true || (typeof respType == 'object' &&
                    respType.result != undefined && respType.result == __WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_000.result) || (respType.status != undefined))){
          __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug (" sendMessage() resp undefined but respType has result with sucees: " + JSON.stringify(respType));
          callback(respType);
        }else {
          __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].debug (" sendMessage() not sucess : respType: " + JSON.stringify(respType) + " resp: " + JSON.stringify(resp));
          callback((resp == undefined ? respType: resp));
        }
      });
    } else {
      error(__WEBPACK_IMPORTED_MODULE_5__customErrors__["a" /* default */].error_1155);
    }
  };

  // It sends a SDP message to the server using socket.io
  that.sendSDP = (type, options, sdp, callback = defaultCallback) => {
    if (that.state === that.DISCONNECTED) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error('Trying to send a message over a disconnected Socket');
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].info('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, { error: 'Trying to send a message over a disconnected Socket' });
      return;
    }
    socket.emit(type, options, sdp, (response, respCallback) => {
      callback(response, respCallback);
    });
  };

  that.emitEvent = (type, options, callback = defaultCallback) => {
    if (that.state === that.DISCONNECTED) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error('Trying to send a message over a disconnected Socket');
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].info('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, { error: 'Trying to send a message over a disconnected Socket' });
      return;
    }
    socket.emit(type, options, (response, respCallback) => {
      callback(response, respCallback);
    });
  };

  that.sendEvent = (type, callback = defaultCallback) => {
    if (that.state === that.DISCONNECTED) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error('Trying to send a message over a disconnected Socket');
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].info('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, { error: 'Trying to send a message over a disconnected Socket' });
      return;
    }
    socket.emit(type, (response) => {
      callback(response);
    });
  };

  that.sendParamEvent = (type, clientId, callback = defaultCallback) => {
    if (that.state === that.DISCONNECTED) {
      __WEBPACK_IMPORTED_MODULE_2__utils_Logger__["default"].error('Trying to send a message over a disconnected Socket');
      __WEBPACK_IMPORTED_MODULE_4__EventLogger__["a" /* default */].info('socket-event', __WEBPACK_IMPORTED_MODULE_3__customEvents__["a" /* default */].event_send_message_failed, { error: 'Trying to send a message over a disconnected Socket' });
      return;
    }
    socket.emit(type, clientId, (response) => {
      callback(response);
    });
  };
  return that;
};



/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Manager */
/* unused harmony export Socket */
/* unused harmony export connect */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return gt; });
/* unused harmony export io */
/* unused harmony export protocol */
/*!
 * Socket.IO v4.4.1
 * (c) 2014-2022 Guillermo Rauch
 * Released under the MIT License.
 */
var t=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,e=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],s=function(s){var n=s,r=s.indexOf("["),i=s.indexOf("]");-1!=r&&-1!=i&&(s=s.substring(0,r)+s.substring(r,i).replace(/:/g,";")+s.substring(i,s.length));for(var o,a,h=t.exec(s||""),c={},p=14;p--;)c[e[p]]=h[p]||"";return-1!=r&&-1!=i&&(c.source=n,c.host=c.host.substring(1,c.host.length-1).replace(/;/g,":"),c.authority=c.authority.replace("[","").replace("]","").replace(/;/g,":"),c.ipv6uri=!0),c.pathNames=function(t,e){var s=/\/{2,9}/g,n=e.replace(s,"/").split("/");"/"!=e.substr(0,1)&&0!==e.length||n.splice(0,1);"/"==e.substr(e.length-1,1)&&n.splice(n.length-1,1);return n}(0,c.path),c.queryKey=(o=c.query,a={},o.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,(function(t,e,s){e&&(a[e]=s)})),a),c};var n={exports:{}};try{n.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(t){n.exports=!1}var r=n.exports,i="undefined"!=typeof self?self:"undefined"!=typeof window?window:Function("return this")();function o(t){const e=t.xdomain;try{if("undefined"!=typeof XMLHttpRequest&&(!e||r))return new XMLHttpRequest}catch(t){}if(!e)try{return new(i[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}function a(t,...e){return e.reduce(((e,s)=>(t.hasOwnProperty(s)&&(e[s]=t[s]),e)),{})}const h=setTimeout,c=clearTimeout;function p(t,e){e.useNativeTimers?(t.setTimeoutFn=h.bind(i),t.clearTimeoutFn=c.bind(i)):(t.setTimeoutFn=setTimeout.bind(i),t.clearTimeoutFn=clearTimeout.bind(i))}var u=l;function l(t){if(t)return function(t){for(var e in l.prototype)t[e]=l.prototype[e];return t}(t)}l.prototype.on=l.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},l.prototype.once=function(t,e){function s(){this.off(t,s),e.apply(this,arguments)}return s.fn=e,this.on(t,s),this},l.prototype.off=l.prototype.removeListener=l.prototype.removeAllListeners=l.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var s,n=this._callbacks["$"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var r=0;r<n.length;r++)if((s=n[r])===e||s.fn===e){n.splice(r,1);break}return 0===n.length&&delete this._callbacks["$"+t],this},l.prototype.emit=function(t){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),s=this._callbacks["$"+t],n=1;n<arguments.length;n++)e[n-1]=arguments[n];if(s){n=0;for(var r=(s=s.slice(0)).length;n<r;++n)s[n].apply(this,e)}return this},l.prototype.emitReserved=l.prototype.emit,l.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},l.prototype.hasListeners=function(t){return!!this.listeners(t).length};const d=Object.create(null);d.open="0",d.close="1",d.ping="2",d.pong="3",d.message="4",d.upgrade="5",d.noop="6";const f=Object.create(null);Object.keys(d).forEach((t=>{f[d[t]]=t}));const y={type:"error",data:"parser error"},m="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===Object.prototype.toString.call(Blob),g="function"==typeof ArrayBuffer,b=({type:t,data:e},s,n)=>{return m&&e instanceof Blob?s?n(e):v(e,n):g&&(e instanceof ArrayBuffer||(r=e,"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(r):r&&r.buffer instanceof ArrayBuffer))?s?n(e):v(new Blob([e]),n):n(d[t]+(e||""));var r},v=(t,e)=>{const s=new FileReader;return s.onload=function(){const t=s.result.split(",")[1];e("b"+t)},s.readAsDataURL(t)};for(var k="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",w="undefined"==typeof Uint8Array?[]:new Uint8Array(256),E=0;E<k.length;E++)w[k.charCodeAt(E)]=E;const _="function"==typeof ArrayBuffer,A=(t,e)=>{if("string"!=typeof t)return{type:"message",data:R(t,e)};const s=t.charAt(0);if("b"===s)return{type:"message",data:C(t.substring(1),e)};return f[s]?t.length>1?{type:f[s],data:t.substring(1)}:{type:f[s]}:y},C=(t,e)=>{if(_){const s=function(t){var e,s,n,r,i,o=.75*t.length,a=t.length,h=0;"="===t[t.length-1]&&(o--,"="===t[t.length-2]&&o--);var c=new ArrayBuffer(o),p=new Uint8Array(c);for(e=0;e<a;e+=4)s=w[t.charCodeAt(e)],n=w[t.charCodeAt(e+1)],r=w[t.charCodeAt(e+2)],i=w[t.charCodeAt(e+3)],p[h++]=s<<2|n>>4,p[h++]=(15&n)<<4|r>>2,p[h++]=(3&r)<<6|63&i;return c}(t);return R(s,e)}return{base64:!0,data:t}},R=(t,e)=>"blob"===e&&t instanceof ArrayBuffer?new Blob([t]):t,T=String.fromCharCode(30);class B extends u{constructor(t){super(),this.writable=!1,p(this,t),this.opts=t,this.query=t.query,this.readyState="",this.socket=t.socket}onError(t,e){const s=new Error(t);return s.type="TransportError",s.description=e,super.emit("error",s),this}open(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this}close(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this}send(t){"open"===this.readyState&&this.write(t)}onOpen(){this.readyState="open",this.writable=!0,super.emit("open")}onData(t){const e=A(t,this.socket.binaryType);this.onPacket(e)}onPacket(t){super.emit("packet",t)}onClose(){this.readyState="closed",super.emit("close")}}var N,O="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),x={},S=0,L=0;function q(t){var e="";do{e=O[t%64]+e,t=Math.floor(t/64)}while(t>0);return e}function P(){var t=q(+new Date);return t!==N?(S=0,N=t):t+"."+q(S++)}for(;L<64;L++)x[O[L]]=L;P.encode=q,P.decode=function(t){var e=0;for(L=0;L<t.length;L++)e=64*e+x[t.charAt(L)];return e};var j=P,D={encode:function(t){var e="";for(var s in t)t.hasOwnProperty(s)&&(e.length&&(e+="&"),e+=encodeURIComponent(s)+"="+encodeURIComponent(t[s]));return e},decode:function(t){for(var e={},s=t.split("&"),n=0,r=s.length;n<r;n++){var i=s[n].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}};class I extends B{constructor(){super(...arguments),this.polling=!1}get name(){return"polling"}doOpen(){this.poll()}pause(t){this.readyState="pausing";const e=()=>{this.readyState="paused",t()};if(this.polling||!this.writable){let t=0;this.polling&&(t++,this.once("pollComplete",(function(){--t||e()}))),this.writable||(t++,this.once("drain",(function(){--t||e()})))}else e()}poll(){this.polling=!0,this.doPoll(),this.emit("poll")}onData(t){((t,e)=>{const s=t.split(T),n=[];for(let t=0;t<s.length;t++){const r=A(s[t],e);if(n.push(r),"error"===r.type)break}return n})(t,this.socket.binaryType).forEach((t=>{if("opening"===this.readyState&&"open"===t.type&&this.onOpen(),"close"===t.type)return this.onClose(),!1;this.onPacket(t)})),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState&&this.poll())}doClose(){const t=()=>{this.write([{type:"close"}])};"open"===this.readyState?t():this.once("open",t)}write(t){this.writable=!1,((t,e)=>{const s=t.length,n=new Array(s);let r=0;t.forEach(((t,i)=>{b(t,!1,(t=>{n[i]=t,++r===s&&e(n.join(T))}))}))})(t,(t=>{this.doWrite(t,(()=>{this.writable=!0,this.emit("drain")}))}))}uri(){let t=this.query||{};const e=this.opts.secure?"https":"http";let s="";!1!==this.opts.timestampRequests&&(t[this.opts.timestampParam]=j()),this.supportsBinary||t.sid||(t.b64=1),this.opts.port&&("https"===e&&443!==Number(this.opts.port)||"http"===e&&80!==Number(this.opts.port))&&(s=":"+this.opts.port);const n=D.encode(t);return e+"://"+(-1!==this.opts.hostname.indexOf(":")?"["+this.opts.hostname+"]":this.opts.hostname)+s+this.opts.path+(n.length?"?"+n:"")}}function F(){}const M=null!=new o({xdomain:!1}).responseType;class U extends u{constructor(t,e){super(),p(this,e),this.opts=e,this.method=e.method||"GET",this.uri=t,this.async=!1!==e.async,this.data=void 0!==e.data?e.data:null,this.create()}create(){const t=a(this.opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");t.xdomain=!!this.opts.xd,t.xscheme=!!this.opts.xs;const e=this.xhr=new o(t);try{e.open(this.method,this.uri,this.async);try{if(this.opts.extraHeaders){e.setDisableHeaderCheck&&e.setDisableHeaderCheck(!0);for(let t in this.opts.extraHeaders)this.opts.extraHeaders.hasOwnProperty(t)&&e.setRequestHeader(t,this.opts.extraHeaders[t])}}catch(t){}if("POST"===this.method)try{e.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{e.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in e&&(e.withCredentials=this.opts.withCredentials),this.opts.requestTimeout&&(e.timeout=this.opts.requestTimeout),e.onreadystatechange=()=>{4===e.readyState&&(200===e.status||1223===e.status?this.onLoad():this.setTimeoutFn((()=>{this.onError("number"==typeof e.status?e.status:0)}),0))},e.send(this.data)}catch(t){return void this.setTimeoutFn((()=>{this.onError(t)}),0)}"undefined"!=typeof document&&(this.index=U.requestsCount++,U.requests[this.index]=this)}onSuccess(){this.emit("success"),this.cleanup()}onData(t){this.emit("data",t),this.onSuccess()}onError(t){this.emit("error",t),this.cleanup(!0)}cleanup(t){if(void 0!==this.xhr&&null!==this.xhr){if(this.xhr.onreadystatechange=F,t)try{this.xhr.abort()}catch(t){}"undefined"!=typeof document&&delete U.requests[this.index],this.xhr=null}}onLoad(){const t=this.xhr.responseText;null!==t&&this.onData(t)}abort(){this.cleanup()}}if(U.requestsCount=0,U.requests={},"undefined"!=typeof document)if("function"==typeof attachEvent)attachEvent("onunload",V);else if("function"==typeof addEventListener){addEventListener("onpagehide"in i?"pagehide":"unload",V,!1)}function V(){for(let t in U.requests)U.requests.hasOwnProperty(t)&&U.requests[t].abort()}const H="function"==typeof Promise&&"function"==typeof Promise.resolve?t=>Promise.resolve().then(t):(t,e)=>e(t,0),K=i.WebSocket||i.MozWebSocket,Y="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase();class z extends B{constructor(t){super(t),this.supportsBinary=!t.forceBase64}get name(){return"websocket"}doOpen(){if(!this.check())return;const t=this.uri(),e=this.opts.protocols,s=Y?{}:a(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(s.headers=this.opts.extraHeaders);try{this.ws=Y?new K(t,e,s):e?new K(t,e):new K(t)}catch(t){return this.emit("error",t)}this.ws.binaryType=this.socket.binaryType||"arraybuffer",this.addEventListeners()}addEventListeners(){this.ws.onopen=()=>{this.opts.autoUnref&&this.ws._socket.unref(),this.onOpen()},this.ws.onclose=this.onClose.bind(this),this.ws.onmessage=t=>this.onData(t.data),this.ws.onerror=t=>this.onError("websocket error",t)}write(t){this.writable=!1;for(let e=0;e<t.length;e++){const s=t[e],n=e===t.length-1;b(s,this.supportsBinary,(t=>{try{this.ws.send(t)}catch(t){}n&&H((()=>{this.writable=!0,this.emit("drain")}),this.setTimeoutFn)}))}}doClose(){void 0!==this.ws&&(this.ws.close(),this.ws=null)}uri(){let t=this.query||{};const e=this.opts.secure?"wss":"ws";let s="";this.opts.port&&("wss"===e&&443!==Number(this.opts.port)||"ws"===e&&80!==Number(this.opts.port))&&(s=":"+this.opts.port),this.opts.timestampRequests&&(t[this.opts.timestampParam]=j()),this.supportsBinary||(t.b64=1);const n=D.encode(t);return e+"://"+(-1!==this.opts.hostname.indexOf(":")?"["+this.opts.hostname+"]":this.opts.hostname)+s+this.opts.path+(n.length?"?"+n:"")}check(){return!(!K||"__initialize"in K&&this.name===z.prototype.name)}}const W={websocket:z,polling:class extends I{constructor(t){if(super(t),"undefined"!=typeof location){const e="https:"===location.protocol;let s=location.port;s||(s=e?"443":"80"),this.xd="undefined"!=typeof location&&t.hostname!==location.hostname||s!==t.port,this.xs=t.secure!==e}const e=t&&t.forceBase64;this.supportsBinary=M&&!e}request(t={}){return Object.assign(t,{xd:this.xd,xs:this.xs},this.opts),new U(this.uri(),t)}doWrite(t,e){const s=this.request({method:"POST",data:t});s.on("success",e),s.on("error",(t=>{this.onError("xhr post error",t)}))}doPoll(){const t=this.request();t.on("data",this.onData.bind(this)),t.on("error",(t=>{this.onError("xhr poll error",t)})),this.pollXhr=t}}};class $ extends u{constructor(t,e={}){super(),t&&"object"==typeof t&&(e=t,t=null),t?(t=s(t),e.hostname=t.host,e.secure="https"===t.protocol||"wss"===t.protocol,e.port=t.port,t.query&&(e.query=t.query)):e.host&&(e.hostname=s(e.host).host),p(this,e),this.secure=null!=e.secure?e.secure:"undefined"!=typeof location&&"https:"===location.protocol,e.hostname&&!e.port&&(e.port=this.secure?"443":"80"),this.hostname=e.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=e.port||("undefined"!=typeof location&&location.port?location.port:this.secure?"443":"80"),this.transports=e.transports||["polling","websocket"],this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!0},e),this.opts.path=this.opts.path.replace(/\/$/,"")+"/","string"==typeof this.opts.query&&(this.opts.query=D.decode(this.opts.query)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingTimeoutTimer=null,"function"==typeof addEventListener&&(this.opts.closeOnBeforeunload&&addEventListener("beforeunload",(()=>{this.transport&&(this.transport.removeAllListeners(),this.transport.close())}),!1),"localhost"!==this.hostname&&(this.offlineEventListener=()=>{this.onClose("transport close")},addEventListener("offline",this.offlineEventListener,!1))),this.open()}createTransport(t){const e=function(t){const e={};for(let s in t)t.hasOwnProperty(s)&&(e[s]=t[s]);return e}(this.opts.query);e.EIO=4,e.transport=t,this.id&&(e.sid=this.id);const s=Object.assign({},this.opts.transportOptions[t],this.opts,{query:e,socket:this,hostname:this.hostname,secure:this.secure,port:this.port});return new W[t](s)}open(){let t;if(this.opts.rememberUpgrade&&$.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket"))t="websocket";else{if(0===this.transports.length)return void this.setTimeoutFn((()=>{this.emitReserved("error","No transports available")}),0);t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)}setTransport(t){this.transport&&this.transport.removeAllListeners(),this.transport=t,t.on("drain",this.onDrain.bind(this)).on("packet",this.onPacket.bind(this)).on("error",this.onError.bind(this)).on("close",(()=>{this.onClose("transport close")}))}probe(t){let e=this.createTransport(t),s=!1;$.priorWebsocketSuccess=!1;const n=()=>{s||(e.send([{type:"ping",data:"probe"}]),e.once("packet",(t=>{if(!s)if("pong"===t.type&&"probe"===t.data){if(this.upgrading=!0,this.emitReserved("upgrading",e),!e)return;$.priorWebsocketSuccess="websocket"===e.name,this.transport.pause((()=>{s||"closed"!==this.readyState&&(c(),this.setTransport(e),e.send([{type:"upgrade"}]),this.emitReserved("upgrade",e),e=null,this.upgrading=!1,this.flush())}))}else{const t=new Error("probe error");t.transport=e.name,this.emitReserved("upgradeError",t)}})))};function r(){s||(s=!0,c(),e.close(),e=null)}const i=t=>{const s=new Error("probe error: "+t);s.transport=e.name,r(),this.emitReserved("upgradeError",s)};function o(){i("transport closed")}function a(){i("socket closed")}function h(t){e&&t.name!==e.name&&r()}const c=()=>{e.removeListener("open",n),e.removeListener("error",i),e.removeListener("close",o),this.off("close",a),this.off("upgrading",h)};e.once("open",n),e.once("error",i),e.once("close",o),this.once("close",a),this.once("upgrading",h),e.open()}onOpen(){if(this.readyState="open",$.priorWebsocketSuccess="websocket"===this.transport.name,this.emitReserved("open"),this.flush(),"open"===this.readyState&&this.opts.upgrade&&this.transport.pause){let t=0;const e=this.upgrades.length;for(;t<e;t++)this.probe(this.upgrades[t])}}onPacket(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emitReserved("packet",t),this.emitReserved("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"ping":this.resetPingTimeout(),this.sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong");break;case"error":const e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emitReserved("data",t.data),this.emitReserved("message",t.data)}}onHandshake(t){this.emitReserved("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&this.resetPingTimeout()}resetPingTimeout(){this.clearTimeoutFn(this.pingTimeoutTimer),this.pingTimeoutTimer=this.setTimeoutFn((()=>{this.onClose("ping timeout")}),this.pingInterval+this.pingTimeout),this.opts.autoUnref&&this.pingTimeoutTimer.unref()}onDrain(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emitReserved("drain"):this.flush()}flush(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emitReserved("flush"))}write(t,e,s){return this.sendPacket("message",t,e,s),this}send(t,e,s){return this.sendPacket("message",t,e,s),this}sendPacket(t,e,s,n){if("function"==typeof e&&(n=e,e=void 0),"function"==typeof s&&(n=s,s=null),"closing"===this.readyState||"closed"===this.readyState)return;(s=s||{}).compress=!1!==s.compress;const r={type:t,data:e,options:s};this.emitReserved("packetCreate",r),this.writeBuffer.push(r),n&&this.once("flush",n),this.flush()}close(){const t=()=>{this.onClose("forced close"),this.transport.close()},e=()=>{this.off("upgrade",e),this.off("upgradeError",e),t()},s=()=>{this.once("upgrade",e),this.once("upgradeError",e)};return"opening"!==this.readyState&&"open"!==this.readyState||(this.readyState="closing",this.writeBuffer.length?this.once("drain",(()=>{this.upgrading?s():t()})):this.upgrading?s():t()),this}onError(t){$.priorWebsocketSuccess=!1,this.emitReserved("error",t),this.onClose("transport error",t)}onClose(t,e){"opening"!==this.readyState&&"open"!==this.readyState&&"closing"!==this.readyState||(this.clearTimeoutFn(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),"function"==typeof removeEventListener&&removeEventListener("offline",this.offlineEventListener,!1),this.readyState="closed",this.id=null,this.emitReserved("close",t,e),this.writeBuffer=[],this.prevBufferLen=0)}filterUpgrades(t){const e=[];let s=0;const n=t.length;for(;s<n;s++)~this.transports.indexOf(t[s])&&e.push(t[s]);return e}}$.protocol=4,$.protocol;const J="function"==typeof ArrayBuffer,X=Object.prototype.toString,G="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===X.call(Blob),Q="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===X.call(File);function Z(t){return J&&(t instanceof ArrayBuffer||(t=>"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):t.buffer instanceof ArrayBuffer)(t))||G&&t instanceof Blob||Q&&t instanceof File}function tt(t,e){if(!t||"object"!=typeof t)return!1;if(Array.isArray(t)){for(let e=0,s=t.length;e<s;e++)if(tt(t[e]))return!0;return!1}if(Z(t))return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return tt(t.toJSON(),!0);for(const e in t)if(Object.prototype.hasOwnProperty.call(t,e)&&tt(t[e]))return!0;return!1}function et(t){const e=[],s=t.data,n=t;return n.data=st(s,e),n.attachments=e.length,{packet:n,buffers:e}}function st(t,e){if(!t)return t;if(Z(t)){const s={_placeholder:!0,num:e.length};return e.push(t),s}if(Array.isArray(t)){const s=new Array(t.length);for(let n=0;n<t.length;n++)s[n]=st(t[n],e);return s}if("object"==typeof t&&!(t instanceof Date)){const s={};for(const n in t)t.hasOwnProperty(n)&&(s[n]=st(t[n],e));return s}return t}function nt(t,e){return t.data=rt(t.data,e),t.attachments=void 0,t}function rt(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(Array.isArray(t))for(let s=0;s<t.length;s++)t[s]=rt(t[s],e);else if("object"==typeof t)for(const s in t)t.hasOwnProperty(s)&&(t[s]=rt(t[s],e));return t}const it=5;var ot;!function(t){t[t.CONNECT=0]="CONNECT",t[t.DISCONNECT=1]="DISCONNECT",t[t.EVENT=2]="EVENT",t[t.ACK=3]="ACK",t[t.CONNECT_ERROR=4]="CONNECT_ERROR",t[t.BINARY_EVENT=5]="BINARY_EVENT",t[t.BINARY_ACK=6]="BINARY_ACK"}(ot||(ot={}));class at extends u{constructor(){super()}add(t){let e;if("string"==typeof t)e=this.decodeString(t),e.type===ot.BINARY_EVENT||e.type===ot.BINARY_ACK?(this.reconstructor=new ht(e),0===e.attachments&&super.emitReserved("decoded",e)):super.emitReserved("decoded",e);else{if(!Z(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");e=this.reconstructor.takeBinaryData(t),e&&(this.reconstructor=null,super.emitReserved("decoded",e))}}decodeString(t){let e=0;const s={type:Number(t.charAt(0))};if(void 0===ot[s.type])throw new Error("unknown packet type "+s.type);if(s.type===ot.BINARY_EVENT||s.type===ot.BINARY_ACK){const n=e+1;for(;"-"!==t.charAt(++e)&&e!=t.length;);const r=t.substring(n,e);if(r!=Number(r)||"-"!==t.charAt(e))throw new Error("Illegal attachments");s.attachments=Number(r)}if("/"===t.charAt(e+1)){const n=e+1;for(;++e;){if(","===t.charAt(e))break;if(e===t.length)break}s.nsp=t.substring(n,e)}else s.nsp="/";const n=t.charAt(e+1);if(""!==n&&Number(n)==n){const n=e+1;for(;++e;){const s=t.charAt(e);if(null==s||Number(s)!=s){--e;break}if(e===t.length)break}s.id=Number(t.substring(n,e+1))}if(t.charAt(++e)){const n=function(t){try{return JSON.parse(t)}catch(t){return!1}}(t.substr(e));if(!at.isPayloadValid(s.type,n))throw new Error("invalid payload");s.data=n}return s}static isPayloadValid(t,e){switch(t){case ot.CONNECT:return"object"==typeof e;case ot.DISCONNECT:return void 0===e;case ot.CONNECT_ERROR:return"string"==typeof e||"object"==typeof e;case ot.EVENT:case ot.BINARY_EVENT:return Array.isArray(e)&&e.length>0;case ot.ACK:case ot.BINARY_ACK:return Array.isArray(e)}}destroy(){this.reconstructor&&this.reconstructor.finishedReconstruction()}}class ht{constructor(t){this.packet=t,this.buffers=[],this.reconPack=t}takeBinaryData(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){const t=nt(this.reconPack,this.buffers);return this.finishedReconstruction(),t}return null}finishedReconstruction(){this.reconPack=null,this.buffers=[]}}var ct=Object.freeze({__proto__:null,protocol:5,get PacketType(){return ot},Encoder:class{encode(t){return t.type!==ot.EVENT&&t.type!==ot.ACK||!tt(t)?[this.encodeAsString(t)]:(t.type=t.type===ot.EVENT?ot.BINARY_EVENT:ot.BINARY_ACK,this.encodeAsBinary(t))}encodeAsString(t){let e=""+t.type;return t.type!==ot.BINARY_EVENT&&t.type!==ot.BINARY_ACK||(e+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(e+=t.nsp+","),null!=t.id&&(e+=t.id),null!=t.data&&(e+=JSON.stringify(t.data)),e}encodeAsBinary(t){const e=et(t),s=this.encodeAsString(e.packet),n=e.buffers;return n.unshift(s),n}},Decoder:at});function pt(t,e,s){return t.on(e,s),function(){t.off(e,s)}}const ut=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class lt extends u{constructor(t,e,s){super(),this.connected=!1,this.disconnected=!0,this.receiveBuffer=[],this.sendBuffer=[],this.ids=0,this.acks={},this.flags={},this.io=t,this.nsp=e,s&&s.auth&&(this.auth=s.auth),this.io._autoConnect&&this.open()}subEvents(){if(this.subs)return;const t=this.io;this.subs=[pt(t,"open",this.onopen.bind(this)),pt(t,"packet",this.onpacket.bind(this)),pt(t,"error",this.onerror.bind(this)),pt(t,"close",this.onclose.bind(this))]}get active(){return!!this.subs}connect(){return this.connected||(this.subEvents(),this.io._reconnecting||this.io.open(),"open"===this.io._readyState&&this.onopen()),this}open(){return this.connect()}send(...t){return t.unshift("message"),this.emit.apply(this,t),this}emit(t,...e){if(ut.hasOwnProperty(t))throw new Error('"'+t+'" is a reserved event name');e.unshift(t);const s={type:ot.EVENT,data:e,options:{}};if(s.options.compress=!1!==this.flags.compress,"function"==typeof e[e.length-1]){const t=this.ids++,n=e.pop();this._registerAckCallback(t,n),s.id=t}const n=this.io.engine&&this.io.engine.transport&&this.io.engine.transport.writable;return this.flags.volatile&&(!n||!this.connected)||(this.connected?this.packet(s):this.sendBuffer.push(s)),this.flags={},this}_registerAckCallback(t,e){const s=this.flags.timeout;if(void 0===s)return void(this.acks[t]=e);const n=this.io.setTimeoutFn((()=>{delete this.acks[t];for(let e=0;e<this.sendBuffer.length;e++)this.sendBuffer[e].id===t&&this.sendBuffer.splice(e,1);e.call(this,new Error("operation has timed out"))}),s);this.acks[t]=(...t)=>{this.io.clearTimeoutFn(n),e.apply(this,[null,...t])}}packet(t){t.nsp=this.nsp,this.io._packet(t)}onopen(){"function"==typeof this.auth?this.auth((t=>{this.packet({type:ot.CONNECT,data:t})})):this.packet({type:ot.CONNECT,data:this.auth})}onerror(t){this.connected||this.emitReserved("connect_error",t)}onclose(t){this.connected=!1,this.disconnected=!0,delete this.id,this.emitReserved("disconnect",t)}onpacket(t){if(t.nsp===this.nsp)switch(t.type){case ot.CONNECT:if(t.data&&t.data.sid){const e=t.data.sid;this.onconnect(e)}else this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case ot.EVENT:case ot.BINARY_EVENT:this.onevent(t);break;case ot.ACK:case ot.BINARY_ACK:this.onack(t);break;case ot.DISCONNECT:this.ondisconnect();break;case ot.CONNECT_ERROR:this.destroy();const e=new Error(t.data.message);e.data=t.data.data,this.emitReserved("connect_error",e)}}onevent(t){const e=t.data||[];null!=t.id&&e.push(this.ack(t.id)),this.connected?this.emitEvent(e):this.receiveBuffer.push(Object.freeze(e))}emitEvent(t){if(this._anyListeners&&this._anyListeners.length){const e=this._anyListeners.slice();for(const s of e)s.apply(this,t)}super.emit.apply(this,t)}ack(t){const e=this;let s=!1;return function(...n){s||(s=!0,e.packet({type:ot.ACK,id:t,data:n}))}}onack(t){const e=this.acks[t.id];"function"==typeof e&&(e.apply(this,t.data),delete this.acks[t.id])}onconnect(t){this.id=t,this.connected=!0,this.disconnected=!1,this.emitBuffered(),this.emitReserved("connect")}emitBuffered(){this.receiveBuffer.forEach((t=>this.emitEvent(t))),this.receiveBuffer=[],this.sendBuffer.forEach((t=>this.packet(t))),this.sendBuffer=[]}ondisconnect(){this.destroy(),this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach((t=>t())),this.subs=void 0),this.io._destroy(this)}disconnect(){return this.connected&&this.packet({type:ot.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}close(){return this.disconnect()}compress(t){return this.flags.compress=t,this}get volatile(){return this.flags.volatile=!0,this}timeout(t){return this.flags.timeout=t,this}onAny(t){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(t),this}prependAny(t){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(t),this}offAny(t){if(!this._anyListeners)return this;if(t){const e=this._anyListeners;for(let s=0;s<e.length;s++)if(t===e[s])return e.splice(s,1),this}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}}var dt=ft;function ft(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}ft.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),s=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-s:t+s}return 0|Math.min(t,this.max)},ft.prototype.reset=function(){this.attempts=0},ft.prototype.setMin=function(t){this.ms=t},ft.prototype.setMax=function(t){this.max=t},ft.prototype.setJitter=function(t){this.jitter=t};class yt extends u{constructor(t,e){var s;super(),this.nsps={},this.subs=[],t&&"object"==typeof t&&(e=t,t=void 0),(e=e||{}).path=e.path||"/socket.io",this.opts=e,p(this,e),this.reconnection(!1!==e.reconnection),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(null!==(s=e.randomizationFactor)&&void 0!==s?s:.5),this.backoff=new dt({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this._readyState="closed",this.uri=t;const n=e.parser||ct;this.encoder=new n.Encoder,this.decoder=new n.Decoder,this._autoConnect=!1!==e.autoConnect,this._autoConnect&&this.open()}reconnection(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection}reconnectionAttempts(t){return void 0===t?this._reconnectionAttempts:(this._reconnectionAttempts=t,this)}reconnectionDelay(t){var e;return void 0===t?this._reconnectionDelay:(this._reconnectionDelay=t,null===(e=this.backoff)||void 0===e||e.setMin(t),this)}randomizationFactor(t){var e;return void 0===t?this._randomizationFactor:(this._randomizationFactor=t,null===(e=this.backoff)||void 0===e||e.setJitter(t),this)}reconnectionDelayMax(t){var e;return void 0===t?this._reconnectionDelayMax:(this._reconnectionDelayMax=t,null===(e=this.backoff)||void 0===e||e.setMax(t),this)}timeout(t){return arguments.length?(this._timeout=t,this):this._timeout}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()}open(t){if(~this._readyState.indexOf("open"))return this;this.engine=new $(this.uri,this.opts);const e=this.engine,s=this;this._readyState="opening",this.skipReconnect=!1;const n=pt(e,"open",(function(){s.onopen(),t&&t()})),r=pt(e,"error",(e=>{s.cleanup(),s._readyState="closed",this.emitReserved("error",e),t?t(e):s.maybeReconnectOnOpen()}));if(!1!==this._timeout){const t=this._timeout;0===t&&n();const s=this.setTimeoutFn((()=>{n(),e.close(),e.emit("error",new Error("timeout"))}),t);this.opts.autoUnref&&s.unref(),this.subs.push((function(){clearTimeout(s)}))}return this.subs.push(n),this.subs.push(r),this}connect(t){return this.open(t)}onopen(){this.cleanup(),this._readyState="open",this.emitReserved("open");const t=this.engine;this.subs.push(pt(t,"ping",this.onping.bind(this)),pt(t,"data",this.ondata.bind(this)),pt(t,"error",this.onerror.bind(this)),pt(t,"close",this.onclose.bind(this)),pt(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(t){this.decoder.add(t)}ondecoded(t){this.emitReserved("packet",t)}onerror(t){this.emitReserved("error",t)}socket(t,e){let s=this.nsps[t];return s||(s=new lt(this,t,e),this.nsps[t]=s),s}_destroy(t){const e=Object.keys(this.nsps);for(const t of e){if(this.nsps[t].active)return}this._close()}_packet(t){const e=this.encoder.encode(t);for(let s=0;s<e.length;s++)this.engine.write(e[s],t.options)}cleanup(){this.subs.forEach((t=>t())),this.subs.length=0,this.decoder.destroy()}_close(){this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close"),this.engine&&this.engine.close()}disconnect(){return this._close()}onclose(t){this.cleanup(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const t=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const e=this.backoff.duration();this._reconnecting=!0;const s=this.setTimeoutFn((()=>{t.skipReconnect||(this.emitReserved("reconnect_attempt",t.backoff.attempts),t.skipReconnect||t.open((e=>{e?(t._reconnecting=!1,t.reconnect(),this.emitReserved("reconnect_error",e)):t.onreconnect()})))}),e);this.opts.autoUnref&&s.unref(),this.subs.push((function(){clearTimeout(s)}))}}onreconnect(){const t=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",t)}}const mt={};function gt(t,e){"object"==typeof t&&(e=t,t=void 0);const n=function(t,e="",n){let r=t;n=n||"undefined"!=typeof location&&location,null==t&&(t=n.protocol+"//"+n.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?n.protocol+t:n.host+t),/^(https?|wss?):\/\//.test(t)||(t=void 0!==n?n.protocol+"//"+t:"https://"+t),r=s(t)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";const i=-1!==r.host.indexOf(":")?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+i+":"+r.port+e,r.href=r.protocol+"://"+i+(n&&n.port===r.port?"":":"+r.port),r}(t,(e=e||{}).path||"/socket.io"),r=n.source,i=n.id,o=n.path,a=mt[i]&&o in mt[i].nsps;let h;return e.forceNew||e["force new connection"]||!1===e.multiplex||a?h=new yt(r,e):(mt[i]||(mt[i]=new yt(r,e)),h=mt[i]),n.query&&!e.query&&(e.query=n.queryKey),h.socket(n.path,e)}Object.assign(gt,{Manager:yt,Socket:lt,io:gt,connect:gt});
//# sourceMappingURL=socket.io.esm.min.js.map


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Bar__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__Common_config__);
/* global document */




/*
 * AudioPlayer represents a Audio component that shows either a local or a remote Audio.
 * Ex.: var player = AudioPlayer({id: id, stream: stream, elementID: elementID});
 * A AudioPlayer is also a View component.
 */

const AudioPlayer = (spec) => {
  const that = Object(__WEBPACK_IMPORTED_MODULE_0__View__["a" /* default */])({});
  let onmouseover;
  let onmouseout;

  // Variables

  // AudioPlayer ID
  that.id = spec.id;

  // Stream that the AudioPlayer will play
  that.stream = spec.stream.stream;

  // DOM element in which the AudioPlayer will be appended
  that.elementID = spec.elementID;
  let elementId = spec.stream.getPlayerId(spec.vroom ? spec.vroom : spec.stream.room);


  // Audio tag
  that.audio = document.createElement('audio');
  that.audio.setAttribute('id', `${elementId.stream}`);
  that.audio.setAttribute('class', 'vcx_stream');
  that.audio.setAttribute('style', 'width: 100%; height: 100%; position: absolute');
  that.audio.setAttribute('autoplay', 'autoplay');

  if (spec.stream.local) { that.audio.volume = 0; }

  if (that.elementID !== undefined) {
    // It will stop the AudioPlayer and remove it from the HTML
    that.destroy = () => {
      that.audio.pause();
      that.parentNode.removeChild(that.div);
    };

    // Container
    that.div = document.createElement('div');
    that.div.setAttribute('id', `${elementId.player}`);
    that.div.setAttribute('class', 'vcx_player');
    that.div.setAttribute('style', 'width: 100%; height: 100%; position: relative; ' +
      'overflow: hidden;');

    // Check for a passed DOM node.
    if (typeof that.elementID === 'object' &&
      typeof that.elementID.appendChild === 'function') {
      that.container = that.elementID;
    } else {
      that.container = document.getElementById(that.elementID);
    }
    that.container.appendChild(that.div);

    that.parentNode = that.div.parentNode;
    that.div.appendChild(that.audio);

    // Bottom Bar
    if (spec.options.bar !== false) {
      that.bar = Object(__WEBPACK_IMPORTED_MODULE_1__Bar__["a" /* default */])({
        elementID: `${elementId.player}`,
        id: that.id,
        stream: spec.stream,
        media: that.audio,
        options: spec.options,
      });

      that.div.onmouseover = onmouseover;
      that.div.onmouseout = onmouseout;
    } else {
      // Expose a consistent object to manipulate the media.
      that.media = that.audio;
    }
  } else {
    // It will stop the AudioPlayer and remove it from the HTML
    that.destroy = () => {
      that.audio.pause();
      that.parentNode.removeChild(that.audio);
    };

    document.body.appendChild(that.audio);
    that.parentNode = document.body;
  }
  let statsContainer = undefined;
  let playerButton = undefined;
  let statsOverlay = undefined;
  let statsOverlayInner = undefined;
  let leftPartition = undefined;
  let rightPartition = undefined;
  // player stats button
  if(!__WEBPACK_IMPORTED_MODULE_2__Common_config___default.a.csp_enabled) {
    statsContainer = document.createElement('div');
    statsContainer.setAttribute('id', `stats-container-${that.id}`);
    statsContainer.setAttribute('class', 'stats-container');
    statsContainer.setAttribute('style', 'display:none;');


    playerButton = document.createElement('div');
    playerButton.setAttribute('id', `stats-button-${that.id}`);
    playerButton.setAttribute('class', 'stats-button');
    playerButton.setAttribute('title', 'Click to see stats');
    playerButton.innerHTML = window.statsIcon;

    statsContainer.appendChild(playerButton);

    statsOverlay = document.createElement('div');
    statsOverlay.setAttribute('class', 'stats-overlay');
    statsOverlay.setAttribute('id', `stats-overlay-${that.id}`);
    statsOverlay.setAttribute('style', 'display:none;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');

    statsOverlayInner = document.createElement('div');
    statsOverlayInner.setAttribute('class', 'stats-overlay-inner');
    statsOverlayInner.setAttribute('id', `stats-overlay-inner-${that.id}`);
    // statsOverlayInner.setAttribute('style', `display:flex;flex-direction:row;`);


    leftPartition = document.createElement('div'),
    rightPartition = document.createElement('div');
    leftPartition.setAttribute('class', 'stats-left-partition');
    leftPartition.setAttribute('id', `stats-left-part-${that.id}`);

    rightPartition.setAttribute('class', 'stats-right-partition');
    rightPartition.setAttribute('id', `stats-right-part-${that.id}`);

    playerButton.addEventListener('click', () => {
      if (statsOverlay.style.display === 'none') { statsOverlay.style.display = 'block'; } else { statsOverlay.style.display = 'none'; }
    });

    that.div.parentNode.style.position = 'relative';
    // Appending Stats container to main player container
    that.div.parentNode.appendChild(statsContainer);
    // appending overlay to container
    that.div.parentNode.appendChild(statsOverlay);
    statsOverlay.appendChild(statsOverlayInner);


    // partitions of overlay
    statsOverlayInner.appendChild(leftPartition);
    statsOverlayInner.appendChild(rightPartition);
  }
  that.audio.srcObject = that.stream;
  that.ShowSessionStats = (statsEnabled) => {
    if (statsEnabled) {
      // show stats UI
      statsContainer.setAttribute('style', 'display:block;');
      statsOverlay.setAttribute('style', 'display:block;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
    } else {
      // hide stats UI
      statsContainer.setAttribute('style', 'display:none;');
      statsOverlay.setAttribute('style', 'display:none;position: absolute;z-index:3;padding: 5px;top:0;right:0;background: rgba(20, 198, 239, 0.75);');
    }
  };
  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (AudioPlayer);


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ViewProperties__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__component_Speaker__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__component_Zoomer__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__component_Branding__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__component_Recorder__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__component_Share__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__component_Play__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__component_microphone__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__assets_css_defaultCss__ = __webpack_require__(10);
/*
This file is for handle Bar.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 29/11/2017 07:14 PM
*/

/* global document, clearTimeout, setTimeout */












/*
 * Bar represents the bottom menu bar of every mediaPlayer.
 * It contains a Speaker and an icon.
 * Every Bar is a View.
 * Ex.: var bar = Bar({elementID: element, id: id});
 */
const Bar = (spec) => {
    const that = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    // Variables
    let waiting;
    let toolbar;
    toolbar = Object(__WEBPACK_IMPORTED_MODULE_0__ViewProperties__["a" /* default */])().toolbar.default;
    let isDefault = false;
    //options attribute checking
    if (spec.options !== undefined && spec.options.player !== undefined) {
        that.playerProperties = spec.options.player;
    }
    if (spec.options.toolbar) {
        const barUser = spec.options.toolbar;
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.position)) { toolbar.position = barUser.position; }
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.class)) { toolbar.class = barUser.class; }
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.skin)) {
            toolbar.skin = barUser.skin;
            isDefault = toolbar.skin === 'default';
        }
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.displayMode)) { toolbar.displayMode = barUser.displayMode; } else { toolbar.displayMode = barUser.displayMode; }
        if (__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].checkParam(barUser.autoDisplayTimeout)) { toolbar.autoDisplayTimeout = barUser.autoDisplayTimeout; }
        if (barUser.buttons) {
            toolbar.buttons = barUser.buttons;
        }
    }


    // DOM element in which the Bar will be appended
    that.elementID = spec.elementID;

    // Bar ID
    that.id = spec.id;

    // Container
    if (isDefault) {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({
            name: 'div', id: `bar_${that.id}`, class: 'vcx_bar', style: __WEBPACK_IMPORTED_MODULE_10__assets_css_defaultCss__["a" /* default */].vcx_bar,
        });
    } else {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({ name: 'div', id: `bar_${that.id}`, class: `vcx_bar ${toolbar.skin}_vcx_bar` });
    }

    __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getById(that.elementID).appendChild(that.div);

    //bar
    if (isDefault) {
        that.bar = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({
            name: 'div',
            id: `subbar_${that.id}`,
            class: `vcx_subbar ${toolbar.class}`,
            style: __WEBPACK_IMPORTED_MODULE_10__assets_css_defaultCss__["a" /* default */][`vcx_subbar_${toolbar.position}`],
        });
    } else {
        that.bar = Object(__WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */])({
            name: 'div',
            id: `subbar_${that.id}`,
            class: `vcx_subbar ${toolbar.skin}_vcx_subbar_${toolbar.position} ${toolbar.class}`,
        });
    }
    that.div.appendChild(that.bar);
    dragElement(that.bar);

    function dragElement(elmnt) {
        let pos1 = 0,
            pos2 = 0,
            pos3 = 0,
            pos4 = 0;
        if (document.getElementById(elmnt.id)) {
            /* if present, the header is where you move the DIV from:*/
            document.getElementById(elmnt.id).onmousedown = dragMouseDown;
        } else {
            /* otherwise, move the DIV from anywhere inside the DIV:*/
            elmnt.onmousedown = dragMouseDown;
        }

        function dragMouseDown(e) {
            e = e || window.event;
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // set the element's new position:
            elmnt.style.top = `${elmnt.offsetTop - pos2}px`;
            elmnt.style.left = `${elmnt.offsetLeft - pos1}px`;
        }

        function closeDragElement() {
            /* stop moving when mouse button is released:*/
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }

    //Play icon
    if (toolbar.buttons.play) {
        that.playIcon = Object(__WEBPACK_IMPORTED_MODULE_8__component_Play__["a" /* default */])({ stream: spec.stream, skin: toolbar.skin });
        that.bar.appendChild(that.playIcon);
    }

    // Zoom icon
    if (toolbar.buttons.zoom) {
        that.zoomIcon = Object(__WEBPACK_IMPORTED_MODULE_4__component_Zoomer__["a" /* default */])({ skin: toolbar.skin, player: that.playerProperties });
        that.bar.appendChild(that.zoomIcon);
    }

    // Record icon
    if (toolbar.buttons.record) {
        that.recIcon = Object(__WEBPACK_IMPORTED_MODULE_6__component_Recorder__["a" /* default */])({ skin: toolbar.skin, stream: spec.stream });
        that.bar.appendChild(that.recIcon);
    }

    // Share icon
    if (toolbar.buttons.share) {
        that.shareIcon = Object(__WEBPACK_IMPORTED_MODULE_7__component_Share__["a" /* default */])({ skin: toolbar.skin, stream: spec.stream });
        that.bar.appendChild(that.shareIcon);
    }

    // Mic icon
    if (toolbar.buttons.mic) {
        that.micIcon = Object(__WEBPACK_IMPORTED_MODULE_9__component_microphone__["a" /* default */])({ skin: toolbar.skin, stream: spec.stream });
        that.bar.appendChild(that.micIcon);
    }

    // Brand icon
    let brandTemp = {};
    if (spec.options && spec.options.toolbar && spec.options.toolbar.branding) {
        brandTemp = spec.options.toolbar.branding;
    }
    brandTemp.skin = toolbar.skin;
    that.brand = Object(__WEBPACK_IMPORTED_MODULE_5__component_Branding__["a" /* default */])(brandTemp);
    that.bar.appendChild(that.brand);

    // Speaker component
    if (toolbar.buttons.volume && !spec.stream.screen && (spec.options === undefined ||
        spec.options.speaker === undefined ||
        spec.options.speaker === true)) {
        that.speaker = Object(__WEBPACK_IMPORTED_MODULE_3__component_Speaker__["a" /* default */])({
            elementID: `subbar_${that.id}`,
            id: that.id,
            stream: spec.stream,
            media: spec.media,
            position: toolbar.position,
            skin: toolbar.skin,
        });
    }

    // Toolbar display mode set
    if (toolbar.displayMode) {
        if (toolbar.displayMode == 'auto') {
            that.div.onmouseover = function (event) {
                const elem = event.currentTarget;
                setTimeout(
                    () => {
                        __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', elem).style.display = 'block';
                    },
                    (parseInt(toolbar.autoDisplayTimeout) * 1000),
                );
            };
            that.div.onmouseout = function (event) {
                const elem = event.currentTarget;
                setTimeout(
                    () => {
                        __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', elem).style.display = 'none';
                    },
                    (parseInt(toolbar.autoDisplayTimeout) * 1000),
                );
            };
            __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', that.div).style.display = 'none';
        } else { __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', that.div).style.display = 'block'; }
    } else {
        __WEBPACK_IMPORTED_MODULE_2__Element__["a" /* default */].getByClass('vcx_subbar', that.div).style.display = 'none';
    }
    return that;
};


/* harmony default export */ __webpack_exports__["a"] = (Bar);


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__ = __webpack_require__(10);
/*
This file is for handle Speaker.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */




/*
 * Speaker represents the volume icon that will be shown in the mediaPlayer, for example.
 * It manages the volume level of the media tag given in the constructor.
 * Every Speaker is a View.
 * Ex.: var speaker = Speaker({elementID: element, media: mediaTag, id: id});
 */
const Speaker = (spec) => {
    const that = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    let lastVolume = 50;
    const isDefaultSkin = spec.skin === 'default';
    const mute = () => {
        that.media.muted = true;
        that.div.classList.remove('fa-volume-up');
        that.div.classList.add('fa-volume-off');
        if (that.stream.local) {
            that.stream.stream.getAudioTracks()[0].enabled = false;
        } else {
            lastVolume = that.picker.value;
            that.picker.value = 0;
            that.media.volume = 0;
        }
    };
    const unmute = () => {
        that.media.muted = false;
        that.div.classList.remove('fa-volume-off');
        that.div.classList.add('fa-volume-up');
        //that.div.setAttribute('src', `${that.url}/assets/sound48.png`);
        if (that.stream.local) {
            that.stream.stream.getAudioTracks()[0].enabled = true;
        } else {
            that.picker.value = lastVolume;
            that.media.volume = that.picker.value / 100;
        }
    };

    // Variables
    // DOM element in which the Speaker will be appended
    that.elementID = spec.elementID;

    // media tag
    that.media = spec.media;

    // Speaker id
    that.id = spec.id;

    // MediaStream
    that.stream = spec.stream;

    const spkr_pos = spec.position;
    // Container
    if (isDefaultSkin) {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            class: 'fa fa-volume-up fa-fw fa-lg',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon_volume),
            id: `volume_${that.id}`,
        });
    } else {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            class: `fa fa-volume-up fa-fw fa-lg ${spec.skin}_icon ${spec.skin}_icon_volume`,
            id: `volume_${that.id}`,
        });
    }
    __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].setStyle(that.div, spec.position, '0');


    that.div.onclick = () => {
        if (that.media.muted) {
            unmute();
        } else {
            mute();
        }
    };

    if (!that.stream.local) {
        // Volume bar
        that.picker = document.createElement('input');
        that.picker.setAttribute('id', `picker_${that.id}`);
        that.picker.setAttribute('style', 'position: absolute;max-width: 50px;margin: 1.1%;top:0;');
        that.picker.type = 'range';
        that.picker.min = 0;
        that.picker.max = 1;
        that.picker.step = 0.1;
        that.picker.value = lastVolume;
        //  FireFox supports range sliders as of version 23
        that.picker.setAttribute('orient', 'vertical');
        that.div.appendChild(that.picker);
        that.media.volume = that.picker.value;
        that.media.muted = false;

        that.picker.onclick = () => {
            if (that.picker.value > 0) {
                that.media.muted = false;
                that.div.classList.remove('fa-volume-off');
                that.div.classList.add('fa-volume-up');
            } else {
                that.media.muted = true;
                that.div.classList.remove('fa-volume-up');
                that.div.classList.add('fa-volume-off');
            }
            that.media.volume = that.picker.value;
        };


        // Private functions
        const show = (displaying) => {
            that.picker.setAttribute('style', `position: absolute;max-width: 50px;margin: 1.1%;margin-left:32px;top:0;display: ${displaying}`);
        };

        //	Element.setStyle(that.picker,spec.position,`${that.div.offsetHeight}px`);
        // Public functions
        that.div.onmouseover = () => {
            show('block');
        };


        that.picker.onmouseout = () => {
            show('none');
        };
        show('none');
    }

    document.getElementById(that.elementID).appendChild(that.div);
    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (Speaker);


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__ = __webpack_require__(10);
/*
This file is for handle Zoom / fullscreen button.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */





let isDefaultSkin = false;
const Zoomer = (spec) => {
    const that = {};
    isDefaultSkin = spec.skin === 'default';
    if (isDefaultSkin) {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'zoom',
            class: 'fa fa-expand  fa-lg icon_zoom ',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon_zoom),
        });
    } else {
        that.div = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'zoom',
            class: `fa fa-expand icon_zoom ${spec.skin}_icon fa-lg ${spec.skin}_icon_zoom`,
        });
    }

    that.div.onclick = function (e) {
        e.stopPropagation();
        Zoomer.click(e, spec);
    };
    return that.div;
};

Zoomer.click = function (e, spec) {
    const skin = spec.skin;
    const player = {
        height: spec.player.height,
        width: spec.player.width,
        position: 'relative',
    };
    const className = e.currentTarget.classList;
    if (className.contains('fa-expand')) {
        e.currentTarget.classList.remove('fa-expand');
        e.currentTarget.classList.add('fa-arrows-alt');
        if (isDefaultSkin) { e.currentTarget.parentNode.parentNode.parentNode.parentNode.setAttribute('style', __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getStyle(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].full_view)); } else { e.currentTarget.parentNode.parentNode.parentNode.classList.add(`${skin}_theater_view`); }
    } else if (className.contains('fa-arrows-alt')) {
        e.currentTarget.classList.remove('fa-arrows-alt');
        e.currentTarget.classList.add('fa-compress');
        if (isDefaultSkin) {
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.removeAttribute('style');
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.setAttribute('style', __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getStyle(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].full_view));
        } else {
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.classList.remove(`${skin}_theater_view`);
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.classList.add(`${skin}_full_view`);
        }
    } else if (className.contains('fa-compress')) {
        e.currentTarget.classList.remove('fa-compress');
        e.currentTarget.classList.add('fa-expand');
        if (isDefaultSkin) {
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.removeAttribute('style');
            e.currentTarget.parentNode.parentNode.parentNode.parentNode.setAttribute('style', __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getStyle(player));
        } else { e.currentTarget.parentNode.parentNode.parentNode.classList.remove(`${skin}_full_view`); }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Zoomer);


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ViewProperties__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__ = __webpack_require__(10);
/*
This file is for handle Brand Logo and Icon.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */






const Branding = (spec) => {
    const view = Object(__WEBPACK_IMPORTED_MODULE_2__View__["a" /* default */])({});
    const that = {};
    let isDefaultSkin = false;
    const brand = Object(__WEBPACK_IMPORTED_MODULE_0__ViewProperties__["a" /* default */])().brand.default;
    if (spec) {
        if (__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(spec.clickthru)) { brand.url = spec.clickthru; }
        if (spec.target && spec.target == 'current') { brand.target = '_self'; }
        if (__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(spec.logo)) { brand.logo = spec.logo; }
        if (__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(spec.title)) { brand.title = spec.title; }
        if (spec.display !== undefined) { brand.display = spec.display; }
        isDefaultSkin = spec.skin === 'default';
    }
    that.link = Object(__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */])({
        name: 'a', title: brand.title, href: brand.url, target: brand.target,
    });
    if (isDefaultSkin) { that.brandIcon = Object(__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */])({ name: 'img', src: brand.logo, style: __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__["a" /* default */].brand_logo }); } else { that.brandIcon = Object(__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */])({ name: 'img', class: `${spec.skin}_brand_logo`, src: brand.logo }); }
    that.link.appendChild(that.brandIcon);
    if (!__WEBPACK_IMPORTED_MODULE_1__Element__["a" /* default */].checkParam(brand.display)) {
        that.link.style.display = 'none';
    }
    return that.link;
};

/* harmony default export */ __webpack_exports__["a"] = (Branding);


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/*
This file is for handle Recorder.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */





const Recorder = (spec) => {
    const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    const that = {};
    that.recorder = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({ name: 'i', title: 'record', class: `fa fa-circle fa-fw fa-lg icon_record ${spec.skin}_icon ${spec.skin}_icon_record` });

    that.recorder.onclick = function (e) {
        Recorder.click(e, spec.stream);
    };
    return that.recorder;
};
Recorder.click = function (e, stream) {
    const className = e.currentTarget.classList;
    if (className.contains('fa-circle')) {
        e.currentTarget.classList.remove('fa-circle');
        e.currentTarget.classList.add('fa-stop-circle');
        if (!stream.local) {
            stream.room.startRecording(stream, (id) => {
            });
        } else {
        }
    } else if (className.contains('fa-stop-circle')) {
        e.currentTarget.classList.remove('fa-stop-circle');
        e.currentTarget.classList.add('fa-circle');
        if (stream.recordingId) {
            stream.room.stopRecording(stream.recordingId, (bool) => {
                if (bool) { stream.recordingId = undefined; }
            });
        }
    }
};
/* harmony default export */ __webpack_exports__["a"] = (Recorder);


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/*
This file is for handle Recorder.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */





const Share = (spec) => {
  const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
  const that = {};
  that.stream = spec.stream;
  that.share = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({ name: 'i', title: 'share screen', class: `fa fa-share-alt fa-fw fa-lg icon_share ${spec.skin}_icon ${spec.skin}_icon_share` });
  that.share.onclick = function (e) { Share.click(e, that.stream); };
  return that.share;
};
Share.click = function (e, stream) {
  const streamShare = VcxRtc.Stream({ screen: true, data: true, attributes: { name: 'shareStream' } });
  streamShare.init();
  streamShare.addEventListener('media-access-allowed', () => {
    stream.room.publish(streamShare, { maxVideoBW: 300 }, (id, error) => {
    });
  });
  streamShare.addEventListener('media-access-denied', (error) => {
  });
};
/* harmony default export */ __webpack_exports__["a"] = (Share);


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Room__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__ = __webpack_require__(10);
/*
This file is for handle Recorder.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */






const Play = (spec) => {
    const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    const that = {};
    that.stream = spec.stream;
    if (spec.skin === 'default') {
        that.play = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'pause',
            class: 'fa fa-pause fa-lg icon_play',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_3__assets_css_defaultCss__["a" /* default */].icon_play),
        });
    } else {
        that.play = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'pause',
            class: `fa fa-pause fa-lg ${spec.skin}_icon icon_play ${spec.skin}_icon_play`,
        });
    }
    that.play.onclick = function (e) {
        Play.click(e);
    };
    const css = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getCss;
    return that.play;
};

Play.toggleVideo = (video) => {
    video.srcObject.getTracks().forEach(t => t.enabled = !t.enabled);
};
Play.click = function (e) {
    const className = e.currentTarget.classList;
    if (className.contains('fa-pause')) {
        e.currentTarget.classList.remove('fa-pause');
        e.currentTarget.classList.add('fa-play');
        var playerDiv = e.currentTarget.parentNode.parentNode.parentNode;
        var videoTag = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById(`stream${playerDiv.id.split('_')[1]}`);
        var screenSaver = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById(`screen_saver_${playerDiv.id.split('_')[1]}`);
        Play.toggleVideo(videoTag);
        if (screenSaver.src !== '') { screenSaver.style.display = 'block'; } else { videoTag.pause(); }
    } else if (className.contains('fa-play')) {
        e.currentTarget.classList.remove('fa-play');
        e.currentTarget.classList.add('fa-pause');
        var playerDiv = e.currentTarget.parentNode.parentNode.parentNode;
        var videoTag = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById(`stream${playerDiv.id.split('_')[1]}`);
        var screenSaver = __WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */].getById(`screen_saver_${playerDiv.id.split('_')[1]}`);
        Play.toggleVideo(videoTag);
        if (screenSaver.src !== '') { screenSaver.style.display = 'none'; } else { videoTag.play(); }
    }
};

/* harmony default export */ __webpack_exports__["a"] = (Play);


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Element__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__View__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__ = __webpack_require__(10);
/*
This file is for handle Microphone.
Author  : Dipjay Datta<dipjay.d@vcloudx.com>
Company : Vcloudx Infotech
Date	: 07/12/2017 12:05 PM
*/
/* global document */






const Mic = (spec) => {
    const view = Object(__WEBPACK_IMPORTED_MODULE_1__View__["a" /* default */])({});
    const that = {};
    const isDefaultSkin = spec.skin === 'default';
    that.stream = spec.stream;
    if (isDefaultSkin) {
        that.mic = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'microphone',
            class: 'fa fa-microphone fa-fw fa-lg icon_mic',
            style: Object.assign(__WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon, __WEBPACK_IMPORTED_MODULE_2__assets_css_defaultCss__["a" /* default */].icon_mic),
        });
    } else {
        that.mic = Object(__WEBPACK_IMPORTED_MODULE_0__Element__["a" /* default */])({
            name: 'i',
            title: 'microphone',
            class: `fa fa-microphone fa-fw fa-lg icon_mic ${spec.skin}_icon ${spec.skin}_icon_mic`,
        });
    }
    that.mic.onclick = function (e) {
        Mic.click(e, that.stream);
    };
    return that.mic;
};

Mic.click = function (e, stream) {
    const className = e.currentTarget.classList;
    if (className.contains('fa-microphone')) {
        stream.muteAudio();
        e.currentTarget.classList.remove('fa-microphone');
        e.currentTarget.classList.add('fa-microphone-slash');
    } else if (className.contains('fa-microphone-slash')) {
        stream.unmuteAudio();
        e.currentTarget.classList.remove('fa-microphone-slash');
        e.currentTarget.classList.add('fa-microphone');
    }
};
/* harmony default export */ __webpack_exports__["a"] = (Mic);


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Common_config_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Common_config_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Common_config_js__);
const { default: Logger } = __webpack_require__(0);


let that;

class NoiseEffects {
  constructor() {
    this.audioContext = undefined;
    this.originalMediaTrack = undefined
    this.sourceStream = undefined;
    this.scriptProcessor = undefined;
    this.modifiedStream = undefined;
    this.audioDestination = undefined;
    this.bufferResidue = new Float32Array([]);
    this.audioWorklet = undefined;
    this.bAnalysisStarted = false;
    that = this;
  }

  async initAudioWorklet() {
    return new Promise(async (resolve, reject) => {
      try {
        await this.audioContext.resume();
        const workletUrl = __WEBPACK_IMPORTED_MODULE_0__Common_config_js___default.a.noise_suppression_sdk_url;
        // Handling of blank worklet URL
        if (workletUrl && workletUrl.trim().length > 0) {
          await that.audioContext.audioWorklet.addModule(workletUrl);
          // After the resolution of module loading, an AudioWorkletNode can be constructed.
          resolve(new AudioWorkletNode(that.audioContext, 'NoiseSuppressorWorklet'));
        } else {
          Logger.debug('Error in initializing audio context (worklet URL configuration missing)');
          reject();
        }
      } catch (e) {
        Logger.debug('Error while adding audio worklet module: ', e);
        reject();
      }
    });
  }

  async checkFileExists() {
    return new Promise(async (resolve, reject) => {
      try {
        const workletUrl = __WEBPACK_IMPORTED_MODULE_0__Common_config_js___default.a.noise_suppression_sdk_url;
        const response = await fetch(workletUrl, { method: 'HEAD' });
        resolve(response.ok);
      } catch (error) {
        reject(false);
      }
    });
  }

  async startNoiseProcessing(original_stream) {
    Logger.info("Starting noise suppression...");
    return new Promise((resolve, reject) => {
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.audioContext = new AudioContext();

        this.initAudioWorklet()
          .then(newAudioWorklet => {
            if (newAudioWorklet) {
              this.audioWorklet = newAudioWorklet;
              // Create a MediaStreamAudioSourceNode for the user audio stream
              this.originalMediaTrack = original_stream.getAudioTracks()[0];
              this.sourceStream = this.audioContext.createMediaStreamSource(original_stream);
              // Create a MediaStreamAudioDestinationNode for the modified audio stream
              this.modifiedStream = new MediaStream();
              this.audioDestination = this.audioContext.createMediaStreamDestination();
              this.outputMediaTrack = this.audioDestination.stream.getAudioTracks()[0];

              this.sourceStream.connect(this.audioWorklet);
              this.audioWorklet.connect(this.audioDestination);
              this.modifiedStream.addTrack(this.audioDestination.stream.getAudioTracks()[0]);

              this.outputMediaTrack.enabled = this.originalMediaTrack.enabled;
              this.outputMediaTrack.enabled = true;
              this.bAnalysisStarted = true;
              resolve(this.modifiedStream);
            } else {
              this.bAnalysisStarted = false;
              Logger.debug('Error while starting noise processing (audio worklet is undefined)');
              reject();
            }
          })
          .catch(error => {
            this.bAnalysisStarted = false;
            Logger.debug('Error while starting noise processing: ', error);
            reject();
          });
      } catch (excp) {
        this.bAnalysisStarted = false;
        Logger.debug('Error while starting noise processing: ', excp);
        reject();
      }
    });
  }

  async stopNoiseProcessing() {
    Logger.info("Stopping noise suppression...");
    return new Promise((resolve, reject) => {
      try {
        this.originalMediaTrack.enabled = this.outputMediaTrack.enabled;
        this.audioDestination.disconnect();
        this.audioWorklet.disconnect();
        this.sourceStream.disconnect();
        this.audioContext.suspend();
        this.bAnalysisStarted = false;
        resolve();
      } catch (excp) {
        this.bAnalysisStarted = false;
        Logger.debug('Error while stopping noise processing: ', excp);
        reject();
      }
    });
  }

  isAlreadyStarted() {
    return this.bAnalysisStarted;
  }
}
/* harmony default export */ __webpack_exports__["a"] = (NoiseEffects);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Pair__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Room__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Base64__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Stream__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__Common_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__customErrors__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__ = __webpack_require__(5);











/*
* Breakout room class, takes care of joining breakout room and managing it.
*/
const BreakOutRoom = (parentRoom, specInput) => {
    const spec = specInput;
    const that = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["c" /* EventDispatcher */])(specInput);
    that.rooms = new Map();
    that.currentBreakOutRoom = null;


    that.joinRoom = (token, streamInfo, callback, reconnectInfo = { allow_reconnect: true, number_of_attempts: 3, timeout_interval: 45000 }) => {
        let room;
        let localStream;
        let error = null;
        let success = null;
        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('SDK version is: ', __WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.product.version);

        if (token != null) {
            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('=========== port of hope');
            const tok = JSON.parse(window.atob(token));
            tok.version = __WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.product.version;
            room = Object(__WEBPACK_IMPORTED_MODULE_2__Room__["a" /* default */])(undefined, undefined, { token: __WEBPACK_IMPORTED_MODULE_3__utils_Base64__["a" /* default */].encodeBase64(JSON.stringify(tok)), reconnectInfo });
            const onAccessSuccess = () => {
                if (__WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].browserEngineCheck() === 'IE') {
                    //streamInfo.video = false;
                    const plugin = document.getElementById('WebrtcEverywherePluginId');
                    plugin.addEventListener('room-connected', (streamEvent) => {
                        that.rooms.set(room.roomID, room); //Room-Connected breakout Room
                        success = {
                            streams: streamEvent.data.streams, room, roomData: streamEvent.data.room, localStream,
                        };
                        room.publish(localStream, {}, (response) => {
                            if (response.result === 0) {
                                success.publishId = response.id;
                                callback(success, null);
                            } else {
                                callback(null, response);
                            }
                        });
                    });
                    plugin.addEventListener('room-error', (err) => {
                        callback(success, err.data);
                    });
                    plugin.addEventListener('stream-added', (streamEvent) => {
                        room.subscribe(streamEvent.data.stream);
                    });
                } else {
                    room.addEventListener('room-connected', (streamEvent) => {
                        //Video not supported as of now.
                        //streamInfo.video = false;
                        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('-----------BreakoutRoom-Connected--------');
                        success = {
                            streams: streamEvent.streams,
                            room,
                            roomData: streamEvent.room,
                            localStream,
                        };
                        callback(success, null);
                        room.publish(localStream, (response) => {
                            if (response.result === 0) {
                                success.publishId = response.id;
                            } else {
                                room.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({ type: 'room-error', message: response }));
                            }
                        });
                        for (let i = 0; i < success.streams.length; i++) {
                            const optionsInput = {};
                            room.subscribe(success.streams[i], optionsInput, (res) => {
                                // check if all the streams subscribed properly and flag that subscribed streams are fine
                                if (res === true) {
                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('breakout room-subscribe callback success');
                                } else {
                                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('breakout room-subscribe callback failed, could not subscribe streams', res);
                                    room.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({ type: 'room-error', message: res }));
                                    //EL.error('api-event', customEvents.event_reconnect_subscribe_failed,
                                }
                            });
                        }
                        //add the room to breakout room Map.
                        that.rooms.set(room.roomID, room);
                        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({ type: 'breakout-room-connected', success });
                        that.dispatchEvent(connectEvt);
                    });
                    room.addEventListener('room-error', (err) => {
                        callback(null, err);
                    });
                    room.addEventListener('stream-added', (streamEvent) => {
                        room.subscribe(streamEvent.stream);
                    });
                    room.addEventListener('room-disconnected', that.onBreakOutRoomDisconnect.bind(room));
                }
                if (room.reconnectionState === false && room.reconnectAttempt == 0) {
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('-----------BreakoutRoom-Connecting--------');
                    room.connect(reconnectInfo);
                } else {
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug(' Reconnection case in join room public api');
                }
            };
            //Success Cases
            const onAccessError = (err) => {
                error = err;
                callback(success, error);
            };
            //Error cases
            if (streamInfo.audio || streamInfo.video) {
                //streamInfo.video = false //By default breakout will have video disabled.
                localStream = room.initPublishStream(streamInfo.div, streamInfo, onAccessSuccess, onAccessError);
            } else {
                __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info(' No publish stream. audio and video are disabled..');
                onAccessSuccess();
            }
        }
        return localStream;
    };

    that.endBreakOutRoom = (room_id) => {
        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('Breakout Room ended, Disconnecting the room');
        const room = that.rooms.get(room_id);
        room.disconnect();
    };

    that.onBreakOutRoomDisconnect = (room) => {
        const breakout_room_disconnected = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({ type: 'breakout-room-disconnect', message: { room_id: room.id } });
        that.rooms.delete(room.roomID);
        that.dispatchEvent(breakout_room_disconnected);
    };

    that.onUserLeft = (room, arg) => {
        const userName = arg.name;
        const userRole = arg.role;
        const userPermissions = arg.permissions;
        const clientId = arg.clientId;
        const evt = UserEvent({
            type: 'user-disconnected',
            room_id: room.roomID,
            name: userName,
            clientId,
            role: userRole,
            permission: userPermissions,
        });
        that.dispatchEvent(evt);
    };

    that.onUserJoined = (room, arg) => {
        const userName = arg.name;
        const userRole = arg.role;
        const userPermissions = arg.permissions;
        const user = {
            name: arg.name,
            permissions: arg.permissions,
            role: arg.role,
            user_ref: arg.user_ref,
            videoMuted: arg.videoMuted,
            audioMuted: arg.audioMuted,
        };
        that.userList.set(arg.clientId, user);
        const evt = UserEvent({
            type: 'user-connected', name: userName, clientId: arg.clientId, role: userRole, permission: userPermissions, user,
        });
        that.dispatchEvent(evt);
    };

    that.disconnectAll = () => {
        that.rooms.forEach((room, room_id) => {
            if (room) room.disconnect();
        });
    };
    return that;
};

/* harmony default export */ __webpack_exports__["a"] = (BreakOutRoom);


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* global unescape */

const VcxRtcMap = () => {
  const that = {};
  const values = {};

  that.add = (id, value) => {
    values[id] = value;
  };

  that.get = id => values[id];

  that.getAll = () => values;
  that.clear = () => { that.forEach((value,id) => {that.remove(id)}) };

  that.has = id => values[id] !== undefined;

  that.forEach = (func) => {
    const keys = Object.keys(values);
    for (let index = 0; index < keys.length; index += 1) {
      const key = keys[index];
      const value = values[key];
      func(value, key);
    }
  };

  that.keys = () => Object.keys(values);

  that.remove = (id) => {
    delete values[id];
  };
  // find the size of object
  that.size = () => {
    const obj = values;
    let size = 0;
    let key;
    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        size++;
      }
    }
    return size;
  };

  return that;
};

/* harmony default export */ __webpack_exports__["a"] = (VcxRtcMap);


/***/ }),
/* 54 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 55 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_nanobus__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ownedFile__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__keychain__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__api__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_Logger__ = __webpack_require__(0);








class FileSender extends __WEBPACK_IMPORTED_MODULE_0_nanobus___default.a {
  constructor() {
    super('FileSender');
    this.keychain = new __WEBPACK_IMPORTED_MODULE_2__keychain__["a" /* default */]();
    this.reset();
  }

  get progressRatio() {
    return this.progress[0] / this.progress[1];
  }

  get progressIndefinite() {
    return (
      ['fileSizeProgress', 'notifyUploadEncryptDone'].indexOf(this.msg) === -1
    );
  }

  get sizes() {
    return {
      partialSize: Object(__WEBPACK_IMPORTED_MODULE_3__utils__["bytes"])(this.progress[0]),
      totalSize: Object(__WEBPACK_IMPORTED_MODULE_3__utils__["bytes"])(this.progress[1]),
    };
  }

  reset() {
    this.uploadRequest = null;
    this.msg = 'importingFile';
    this.progress = [0, 1];
    this.cancelled = false;
  }

  cancel() {
    this.cancelled = true;
    if (this.uploadRequest) {
      this.uploadRequest.cancel();
    }
  }

  async upload(archive, bearerToken) {
    if (this.cancelled) {
      //  Logger.info('upload cancelled', archive);
      throw new Error(0);
    }
    this.msg = 'encryptingFile';
    this.emit('encrypting');
    const totalSize = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["encryptedSize"])(archive.size);
    const encStream = await this.keychain.encryptStream(archive.stream);
    const metadata = await this.keychain.encryptMetadata(archive);
    const authKeyB64 = await this.keychain.authKeyB64();
    const file_info = {
      name: archive.name,
      plainSize: archive.size,
      type: archive.type,
      totalSize,
    };

    this.uploadRequest = Object(__WEBPACK_IMPORTED_MODULE_4__api__["i" /* uploadWs */])(
      encStream,
      metadata,
      authKeyB64,
      archive.timeLimit,
      archive.dlimit,
      bearerToken,
      file_info,
      (p) => {
        this.progress = [p, totalSize];
        this.emit('progress');
      },
    );

    if (this.cancelled) {
      throw new Error(0);
    }

    this.msg = 'fileSizeProgress';
    this.emit('progress'); // HACK to kick MS Edge
    try {
      const result = await this.uploadRequest.result;
      this.msg = 'notifyUploadEncryptDone';
      this.uploadRequest = null;
      this.progress = [1, 1];
      const secretKey = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["arrayToB64"])(this.keychain.rawSecret);
      const ownedFile = new __WEBPACK_IMPORTED_MODULE_1__ownedFile__["a" /* default */]({
        id: result.id,
        url: `${result.url}#${secretKey}`,
        name: archive.name,
        size: archive.size,
        manifest: archive.manifest,
        time: result.duration,
        speed: archive.size / (result.duration / 1000),
        createdAt: Date.now(),
        expiresAt: Date.now() + archive.timeLimit * 1000,
        secretKey,
        nonce: this.keychain.nonce,
        ownerToken: result.ownerToken,
        dlimit: archive.dlimit,
        timeLimit: archive.timeLimit,
        mnounce: result.mnounce,
      });

      return ownedFile;
    } catch (e) {
      __WEBPACK_IMPORTED_MODULE_5__utils_Logger__["default"].info('upload request failed', e);
      this.msg = 'errorPageHeader';
      this.uploadRequest = null;
      throw e;
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FileSender;



/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Remove a range of items from an array
 *
 * @function removeItems
 * @param {Array<*>} arr The target array
 * @param {number} startIdx The index to begin removing from (inclusive)
 * @param {number} removeCount How many items to remove
 */
module.exports = function removeItems (arr, startIdx, removeCount) {
  var i, length = arr.length

  if (startIdx >= length || removeCount === 0) {
    return
  }

  removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount)

  var len = length - removeCount

  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount]
  }

  arr.length = len
}


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var scheduler = __webpack_require__(59)()
var assert = __webpack_require__(21)

var perf
nanotiming.disabled = true
try {
  perf = window.performance
  nanotiming.disabled = window.localStorage.DISABLE_NANOTIMING === 'true' || !perf.mark
} catch (e) { }

module.exports = nanotiming

function nanotiming (name) {
  assert.equal(typeof name, 'string', 'nanotiming: name should be type string')

  if (nanotiming.disabled) return noop

  var uuid = (perf.now() * 10000).toFixed() % Number.MAX_SAFE_INTEGER
  var startName = 'start-' + uuid + '-' + name
  perf.mark(startName)

  function end (cb) {
    var endName = 'end-' + uuid + '-' + name
    perf.mark(endName)

    scheduler.push(function () {
      var err = null
      try {
        var measureName = name + ' [' + uuid + ']'
        perf.measure(measureName, startName, endName)
        perf.clearMarks(startName)
        perf.clearMarks(endName)
      } catch (e) { err = e }
      if (cb) cb(err, name)
    })
  }

  end.uuid = uuid
  return end
}

function noop (cb) {
  if (cb) {
    scheduler.push(function () {
      cb(new Error('nanotiming: performance API unavailable'))
    })
  }
}


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var assert = __webpack_require__(21)

var hasWindow = typeof window !== 'undefined'

function createScheduler () {
  var scheduler
  if (hasWindow) {
    if (!window._nanoScheduler) window._nanoScheduler = new NanoScheduler(true)
    scheduler = window._nanoScheduler
  } else {
    scheduler = new NanoScheduler()
  }
  return scheduler
}

function NanoScheduler (hasWindow) {
  this.hasWindow = hasWindow
  this.hasIdle = this.hasWindow && window.requestIdleCallback
  this.method = this.hasIdle ? window.requestIdleCallback.bind(window) : this.setTimeout
  this.scheduled = false
  this.queue = []
}

NanoScheduler.prototype.push = function (cb) {
  assert.equal(typeof cb, 'function', 'nanoscheduler.push: cb should be type function')

  this.queue.push(cb)
  this.schedule()
}

NanoScheduler.prototype.schedule = function () {
  if (this.scheduled) return

  this.scheduled = true
  var self = this
  this.method(function (idleDeadline) {
    var cb
    while (self.queue.length && idleDeadline.timeRemaining() > 0) {
      cb = self.queue.shift()
      cb(idleDeadline)
    }
    self.scheduled = false
    if (self.queue.length) self.schedule()
  })
}

NanoScheduler.prototype.setTimeout = function (cb) {
  setTimeout(cb, 0, {
    timeRemaining: function () {
      return 1
    }
  })
}

module.exports = createScheduler


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__keychain__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__api__ = __webpack_require__(16);




class OwnedFile {
  constructor(obj) {
    if (!obj.manifest) {
      throw new Error('invalid file object');
    }
    this.id = obj.id;
    this.url = obj.url;
    this.name = obj.name;
    this.size = obj.size;
    this.manifest = obj.manifest;
    this.time = obj.time;
    this.speed = obj.speed;
    this.createdAt = obj.createdAt;
    this.expiresAt = obj.expiresAt;
    this.ownerToken = obj.ownerToken;
    this.dlimit = obj.dlimit || 1;
    this.dtotal = obj.dtotal || 0;
    this.keychain = new __WEBPACK_IMPORTED_MODULE_0__keychain__["a" /* default */](obj.secretKey, obj.nonce);
    this._hasPassword = !!obj.hasPassword;
    this.timeLimit = obj.timeLimit;
    this.mnounce = obj.mnounce;
  }

  get hasPassword() {
    return !!this._hasPassword;
  }

  get expired() {
    return this.dlimit === this.dtotal || Date.now() > this.expiresAt;
  }

  async setPassword(password) {
    try {
      this.password = password;
      this._hasPassword = true;
      this.keychain.setPassword(password, this.url);
      const result = await Object(__WEBPACK_IMPORTED_MODULE_2__api__["h" /* setPassword */])(this.id, this.ownerToken, this.keychain);
      return result;
    } catch (e) {
      this.password = null;
      this._hasPassword = false;
      throw e;
    }
  }

  del() {
    return Object(__WEBPACK_IMPORTED_MODULE_2__api__["a" /* del */])(this.id, this.ownerToken);
  }

  changeLimit(dlimit, user = {}) {
    if (this.dlimit !== dlimit) {
      this.dlimit = dlimit;
      return Object(__WEBPACK_IMPORTED_MODULE_2__api__["g" /* setParams */])(this.id, this.ownerToken, user.bearerToken, { dlimit });
    }
    return Promise.resolve(true);
  }

  async updateDownloadCount() {
    const oldTotal = this.dtotal;
    const oldLimit = this.dlimit;
    try {
      const result = await Object(__WEBPACK_IMPORTED_MODULE_2__api__["c" /* fileInfo */])(this.id, this.ownerToken);
      this.dtotal = result.dtotal;
      this.dlimit = result.dlimit;
    } catch (e) {
      if (e.message === '404') {
        this.dtotal = this.dlimit;
      }
      // ignore other errors
    }
    return oldTotal !== this.dtotal || oldLimit !== this.dlimit;
  }

  toJSON() {
    return {
      id: this.id,
      url: this.url,
      name: this.name,
      size: this.size,
      manifest: this.manifest,
      time: this.time,
      speed: this.speed,
      createdAt: this.createdAt,
      expiresAt: this.expiresAt,
      secretKey: Object(__WEBPACK_IMPORTED_MODULE_1__utils__["arrayToB64"])(this.keychain.rawSecret),
      ownerToken: this.ownerToken,
      dlimit: this.dlimit,
      dtotal: this.dtotal,
      hasPassword: this.hasPassword,
      timeLimit: this.timeLimit,
      mnounce: this.mnounce,
    };
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = OwnedFile;



/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__streams__ = __webpack_require__(20);


function isDupe(newFile, array) {
  for (const file of array) {
    if (
      newFile.name === file.name &&
      newFile.size === file.size &&
      newFile.lastModified === file.lastModified
    ) {
      return true;
    }
  }
  return false;
}

class Archive {
  constructor(files = [], defaultTimeLimit = 86400, roomMeta = {}) {
    this.files = Array.from(files);
    this.defaultTimeLimit = defaultTimeLimit;
    this.timeLimit = defaultTimeLimit;
    this.dlimit = 10;
    this.password = null;
    this.roomMeta = roomMeta;
  }

  get name() {
    return this.files.length > 1 ? 'Send-Archive.zip' : this.files[0].name;
  }

  get type() {
    return this.files.length > 1 ? 'send-archive' : this.files[0].type;
  }

  get size() {
    return this.files.reduce((total, file) => total + file.size, 0);
  }

  get numFiles() {
    return this.files.length;
  }

  get manifest() {
    return {
      files: this.files.map(file => ({
        name: file.name,
        size: file.size,
        type: file.type,
      })),
    };
  }

  get stream() {
    return Object(__WEBPACK_IMPORTED_MODULE_0__streams__["b" /* concatStream */])(this.files.map(file => Object(__WEBPACK_IMPORTED_MODULE_0__streams__["a" /* blobStream */])(file)));
  }

  addFiles(files, maxSize, maxFiles) {
    if (this.files.length + files.length > maxFiles) {
      throw new Error('tooManyFiles');
    }
    const newFiles = files.filter(file => file.size > 0 && !isDupe(file, this.files));
    const newSize = newFiles.reduce((total, file) => total + file.size, 0);
    if (this.size + newSize > maxSize) {
      throw new Error('fileTooBig');
    }
    this.files = this.files.concat(newFiles);
    return true;
  }

  remove(file) {
    const index = this.files.indexOf(file);
    if (index > -1) {
      this.files.splice(index, 1);
    }
  }

  clear() {
    this.files = [];
    this.dlimit = 1;
    this.timeLimit = this.defaultTimeLimit;
    this.password = null;
    this.roomMeta = {};
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Archive;



/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_nanobus___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_nanobus__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__keychain__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__utils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__api__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__streams__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__zip__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_Logger__ = __webpack_require__(0);








class FileReceiver extends __WEBPACK_IMPORTED_MODULE_0_nanobus___default.a {
  constructor(fileInfo) {
    super('FileReceiver');

    this.keychain = new __WEBPACK_IMPORTED_MODULE_1__keychain__["a" /* default */](fileInfo.secretKey, fileInfo.nonce);
    if (fileInfo.requiresPassword) {
      this.keychain.setPassword(fileInfo.password, fileInfo.url);
    }
    this.fileInfo = fileInfo;
    this.reset();
  }

  get progressRatio() {
    return this.progress[0] / this.progress[1];
  }

  get progressIndefinite() {
    return this.state !== 'downloading';
  }

  get sizes() {
    return {
      partialSize: Object(__WEBPACK_IMPORTED_MODULE_2__utils__["bytes"])(this.progress[0]),
      totalSize: Object(__WEBPACK_IMPORTED_MODULE_2__utils__["bytes"])(this.progress[1]),
    };
  }

  cancel() {
    if (this.downloadRequest) {
      this.downloadRequest.cancel();
    }
  }

  reset() {
    this.msg = 'fileSizeProgress';
    this.state = 'initialized';
    this.progress = [0, 1];
  }

  async getMetadata() {
    const meta = await Object(__WEBPACK_IMPORTED_MODULE_3__api__["e" /* metadata */])(this.fileInfo.id, this.keychain);
    this.fileInfo.name = meta.name;
    this.fileInfo.type = meta.type;
    this.fileInfo.iv = meta.iv;
    this.fileInfo.size = +meta.size;
    this.fileInfo.manifest = meta.manifest;
    this.state = 'ready';
  }

  sendMessageToSw(msg) {
    return new Promise((resolve, reject) => {
      const channel = new MessageChannel();

      channel.port1.onmessage = function (event) {
        if (event.data === undefined) {
          reject('bad response from serviceWorker');
        } else if (event.data.error !== undefined) {
          reject(event.data.error);
        } else {
          resolve(event.data);
        }
      };

      navigator.serviceWorker.controller.postMessage(msg, [channel.port2]);
    });
  }

  async downloadBlob(noSave = false, isMobile = false) {
    this.state = 'downloading';
    this.downloadRequest = await Object(__WEBPACK_IMPORTED_MODULE_3__api__["b" /* downloadFile */])(
      this.fileInfo.id,
      this.keychain,
      (p) => {
        this.progress = [p, this.fileInfo.size];
        this.emit('progress');
      },
    );
    try {
      const ciphertext = await this.downloadRequest.result;
      this.downloadRequest = null;
      this.msg = 'decryptingFile';
      this.state = 'decrypting';
      this.emit('decrypting');
      let size = this.fileInfo.size;
      let plainStream = this.keychain.decryptStream(Object(__WEBPACK_IMPORTED_MODULE_4__streams__["a" /* blobStream */])(ciphertext));
      if (this.fileInfo.type === 'send-archive') {
        const zip = new __WEBPACK_IMPORTED_MODULE_5__zip__["a" /* default */](this.fileInfo.manifest, plainStream);
        plainStream = zip.stream;
        size = zip.size;
      }
      const plaintext = await Object(__WEBPACK_IMPORTED_MODULE_2__utils__["streamToArrayBuffer"])(plainStream, size);
      let resp = {};
      if (!noSave) {
        resp = await saveFile({
          plaintext,
          name: decodeURIComponent(this.fileInfo.name),
          type: this.fileInfo.type,
        }, isMobile);
      }
      this.msg = 'downloadFinish';
      this.emit('complete');
      this.state = 'complete';
      return resp;
    } catch (e) {
      this.downloadRequest = null;
      throw e;
    }
  }

  async downloadStream(noSave = false) {
    const start = Date.now();
    const onprogress = (p) => {
      this.progress = [p, this.fileInfo.size];
      this.emit('progress');
    };

    this.downloadRequest = {
      cancel: () => {
        this.sendMessageToSw({ request: 'cancel', id: this.fileInfo.id });
      },
    };

    try {
      this.state = 'downloading';

      const info = {
        request: 'init',
        id: this.fileInfo.id,
        filename: this.fileInfo.name,
        type: this.fileInfo.type,
        manifest: this.fileInfo.manifest,
        key: this.fileInfo.secretKey,
        requiresPassword: this.fileInfo.requiresPassword,
        password: this.fileInfo.password,
        url: this.fileInfo.url,
        size: this.fileInfo.size,
        nonce: this.keychain.nonce,
        noSave,
      };
      await this.sendMessageToSw(info);

      onprogress(0);

      if (noSave) {
        const res = await fetch(Object(__WEBPACK_IMPORTED_MODULE_3__api__["d" /* getApiUrl */])(`/api/download/${this.fileInfo.id}`));
        if (res.status !== 200) {
          throw new Error(res.status);
        }
      } else {
        const downloadPath = `/api/download/${this.fileInfo.id}`;
        let downloadUrl = Object(__WEBPACK_IMPORTED_MODULE_3__api__["d" /* getApiUrl */])(downloadPath);
        if (downloadUrl === downloadPath) {
          downloadUrl = `${location.protocol}//${location.host}${downloadPath}`;
        }
        const a = document.createElement('a');
        a.href = downloadUrl;
        document.body.appendChild(a);
        a.click();
      }

      let prog = 0;
      let hangs = 0;
      while (prog < this.fileInfo.size) {
        const msg = await this.sendMessageToSw({
          request: 'progress',
          id: this.fileInfo.id,
        });
        if (msg.progress === prog) {
          hangs++;
        } else {
          hangs = 0;
        }
        if (hangs > 30) {
          // TODO: On Chrome we don't get a cancel
          // signal so one is indistinguishable from
          // a hang. We may be able to detect
          // which end is hung in the service worker
          // to improve on this.
          const e = new Error('hung download');
          e.duration = Date.now() - start;
          e.size = this.fileInfo.size;
          e.progress = prog;
          throw e;
        }
        prog = msg.progress;
        onprogress(prog);
        await Object(__WEBPACK_IMPORTED_MODULE_2__utils__["delay"])(1000);
      }

      this.downloadRequest = null;
      this.msg = 'downloadFinish';
      this.emit('complete');
      this.state = 'complete';
    } catch (e) {
      this.downloadRequest = null;
      if (e === 'cancelled' || e.message === '400') {
        throw new Error(0);
      }
      throw e;
    }
  }

  download(options) {
    if (options.stream) {
      return this.downloadStream(options.noSave);
    }
    return this.downloadBlob(options.noSave, options.isMobile);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FileReceiver;


async function saveFile(file, isMobile = false) {
  return new Promise(((resolve, reject) => {
    let fdownloadResult = {};
    const dataView = new DataView(file.plaintext);
    const blob = new Blob([dataView], { type: file.type });
    if (isMobile === true) {
      __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].info(' download file mobile device', isMobile);
      fdownloadResult = {
        messageType: 'download-success',
        result: 0,
        description: 'download-success',
        response: {
          downloadStatus: 'success',
          name: file.name,
          type: file.type,
          size: file.size,
          blob,
        },
      };
      return resolve(fdownloadResult);
    }
    if (navigator.msSaveBlob) {
      console.log('nagivator service worker is present');
      navigator.msSaveBlob(blob, file.name);
      return resolve();
    } else if (/iPhone|fxios/i.test(navigator.userAgent)) {
      //  console.log('checking about iphone');
      // This method is much slower but createObjectURL
      // is buggy on iOS
      const reader = new FileReader();
      reader.addEventListener('loadend', () => {
        if (reader.error) {
          return reject(reader.error);
        }
        if (reader.result) {
          const a = document.createElement('a');
          a.href = reader.result;
          a.download = file.name;
          document.body.appendChild(a);
          a.click();
        }
        resolve();
      });
      reader.readAsDataURL(blob);
    } else {
      const downloadUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = file.name;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(downloadUrl);
      fdownloadResult = {
        messageType: 'download-success',
        result: 0,
        description: 'download-success',
        response: {
          downloadStatus: 'success',
          name: file.name,
          type: file.type,
          size: file.size,
          //  blob:blob
        },
      };

      setTimeout(resolve(fdownloadResult), 100);
    }
  }));
}


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crc_crc32__ = __webpack_require__(64);


const encoder = new TextEncoder();

function dosDateTime(dateTime = new Date()) {
  const year = (dateTime.getFullYear() - 1980) << 9;
  const month = (dateTime.getMonth() + 1) << 5;
  const day = dateTime.getDate();
  const date = year | month | day;
  const hour = dateTime.getHours() << 11;
  const minute = dateTime.getMinutes() << 5;
  const second = Math.floor(dateTime.getSeconds() / 2);
  const time = hour | minute | second;

  return { date, time };
}

class File {
  constructor(info) {
    this.name = encoder.encode(info.name);
    this.size = info.size;
    this.bytesRead = 0;
    this.crc = null;
    this.dateTime = dosDateTime();
  }

  get header() {
    const h = new ArrayBuffer(30 + this.name.byteLength);
    const v = new DataView(h);
    v.setUint32(0, 0x04034b50, true); // sig
    v.setUint16(4, 20, true); // version
    v.setUint16(6, 8, true); // bit flags (8 = use data descriptor)
    v.setUint16(8, 0, true); // compression
    v.setUint16(10, this.dateTime.time, true); // modified time
    v.setUint16(12, this.dateTime.date, true); // modified date
    v.setUint32(14, 0, true); // crc32 (in descriptor)
    v.setUint32(18, 0, true); // compressed size (in descriptor)
    v.setUint32(22, 0, true); // uncompressed size (in descriptor)
    v.setUint16(26, this.name.byteLength, true); // name length
    v.setUint16(28, 0, true); // extra field length
    for (let i = 0; i < this.name.byteLength; i++) {
      v.setUint8(30 + i, this.name[i]);
    }
    return new Uint8Array(h);
  }

  get dataDescriptor() {
    const dd = new ArrayBuffer(16);
    const v = new DataView(dd);
    v.setUint32(0, 0x08074b50, true); // sig
    v.setUint32(4, this.crc, true); // crc32
    v.setUint32(8, this.size, true); // compressed size
    v.setUint32(12, this.size, true); // uncompressed size
    return new Uint8Array(dd);
  }

  directoryRecord(offset) {
    const dr = new ArrayBuffer(46 + this.name.byteLength);
    const v = new DataView(dr);
    v.setUint32(0, 0x02014b50, true); // sig
    v.setUint16(4, 20, true); // version made
    v.setUint16(6, 20, true); // version required
    v.setUint16(8, 8, true); // bit flags (8 = use data descriptor)
    v.setUint16(10, 0, true); // compression
    v.setUint16(12, this.dateTime.time, true); // modified time
    v.setUint16(14, this.dateTime.date, true); // modified date
    v.setUint32(16, this.crc, true); // crc
    v.setUint32(20, this.size, true); // compressed size
    v.setUint32(24, this.size, true); // uncompressed size
    v.setUint16(28, this.name.byteLength, true); // name length
    v.setUint16(30, 0, true); // extra length
    v.setUint16(32, 0, true); // comment length
    v.setUint16(34, 0, true); // disk number
    v.setUint16(36, 0, true); // internal file attrs
    v.setUint32(38, 0, true); // external file attrs
    v.setUint32(42, offset, true); // file offset
    for (let i = 0; i < this.name.byteLength; i++) {
      v.setUint8(46 + i, this.name[i]);
    }
    return new Uint8Array(dr);
  }

  get byteLength() {
    return this.size + this.name.byteLength + 30 + 16;
  }

  append(data, controller) {
    this.bytesRead += data.byteLength;
    const endIndex = data.byteLength - Math.max(this.bytesRead - this.size, 0);
    const buf = data.slice(0, endIndex);
    this.crc = Object(__WEBPACK_IMPORTED_MODULE_0_crc_crc32__["a" /* default */])(buf, this.crc);
    controller.enqueue(buf);
    if (endIndex < data.byteLength) {
      return data.slice(endIndex, data.byteLength);
    }
  }
}

function centralDirectory(files, controller) {
  let directoryOffset = 0;
  let directorySize = 0;
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const record = file.directoryRecord(directoryOffset);
    directoryOffset += file.byteLength;
    controller.enqueue(record);
    directorySize += record.byteLength;
  }
  controller.enqueue(eod(files.length, directorySize, directoryOffset));
}

function eod(fileCount, directorySize, directoryOffset) {
  const e = new ArrayBuffer(22);
  const v = new DataView(e);
  v.setUint32(0, 0x06054b50, true); // sig
  v.setUint16(4, 0, true); // disk number
  v.setUint16(6, 0, true); // directory disk
  v.setUint16(8, fileCount, true); // number of records
  v.setUint16(10, fileCount, true); // total records
  v.setUint32(12, directorySize, true); // size of directory
  v.setUint32(16, directoryOffset, true); // offset of directory
  v.setUint16(20, 0, true); // comment length
  return new Uint8Array(e);
}

class ZipStreamController {
  constructor(files, source) {
    this.files = files;
    this.fileIndex = 0;
    this.file = null;
    this.reader = source.getReader();
    this.nextFile();
    this.extra = null;
  }

  nextFile() {
    this.file = this.files[this.fileIndex++];
  }

  async pull(controller) {
    if (!this.file) {
      // end of archive
      centralDirectory(this.files, controller);
      return controller.close();
    }
    if (this.file.bytesRead === 0) {
      // beginning of file
      controller.enqueue(this.file.header);
      if (this.extra) {
        this.extra = this.file.append(this.extra, controller);
      }
    }
    if (this.file.bytesRead >= this.file.size) {
      // end of file
      controller.enqueue(this.file.dataDescriptor);
      this.nextFile();
      return this.pull(controller);
    }
    const data = await this.reader.read();
    if (data.done) {
      this.nextFile();
      return this.pull(controller);
    }
    this.extra = this.file.append(data.value, controller);
  }
}

class Zip {
  constructor(manifest, source) {
    this.files = manifest.files.map(info => new File(info));
    this.source = source;
  }

  get stream() {
    return new ReadableStream(new ZipStreamController(this.files, this.source));
  }

  get size() {
    const entries = this.files.reduce(
      (total, file) => total + file.byteLength * 2 - file.size,
      0,
    );
    const eod = 22;
    return entries + eod;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Zip;



/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__create_buffer__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__define_crc__ = __webpack_require__(66);




// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`
// prettier-ignore
let TABLE = [
  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
  0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
  0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
  0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
  0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
  0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
  0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
  0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
  0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
  0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
  0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
  0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
  0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
  0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
  0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
  0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
  0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
  0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
  0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
  0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
  0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
  0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
  0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
  0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
  0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
  0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
  0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
  0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
  0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
  0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
  0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
  0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
  0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
  0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
  0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
  0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
  0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
  0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
  0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
  0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
  0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
  0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
  0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

const crc32 = Object(__WEBPACK_IMPORTED_MODULE_2__define_crc__["a" /* default */])('crc-32', function(buf, previous) {
  if (!__WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].isBuffer(buf)) buf = Object(__WEBPACK_IMPORTED_MODULE_1__create_buffer__["a" /* default */])(buf);

  let crc = previous === 0 ? 0 : ~~previous ^ -1;

  for (let index = 0; index < buf.length; index++) {
    const byte = buf[index];
    crc = TABLE[(crc ^ byte) & 0xff] ^ (crc >>> 8);
  }

  return crc ^ -1;
});

/* harmony default export */ __webpack_exports__["a"] = (crc32);


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_buffer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_buffer__);


const createBuffer =
  __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].from && __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].alloc && __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].allocUnsafe && __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].allocUnsafeSlow
    ? __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"].from
    : // support for Node < 5.10
      val => new __WEBPACK_IMPORTED_MODULE_0_buffer__["Buffer"](val);

/* harmony default export */ __webpack_exports__["a"] = (createBuffer);


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function(model, calc) {
  const fn = (buf, previous) => calc(buf, previous) >>> 0;
  fn.signed = calc;
  fn.unsigned = fn;
  fn.model = model;

  return fn;
});


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

const Annotate = {
  isAnnotationStarted: false,
  canvasOptions: { width: 0, height: 0 },
  frameStyle: 'display:block; user-select: none;z-index:0; position:absolute;top:0%',
  annotateStyle: 'display:block; user-select: none;z-index:2; position:absolute;top:0%',
  annotationConfig: {
    toolType: 'draw',
    isErase: false,
    drawMethod: 'pencil',
    strokeColor: '#ff0000',
    lineWidth: 3,
    hasInput: false,
    lastMouseX: 0,
    lastMouseY: 0,
    canvasX: 0,
    canvasY: 0,
    mouseX: 0,
    mouseY: 0,
    mouseDown: false,
    drawElement: null,
    drawCtx: null,
    canvasDomID: null,
    canvasVideoPlayerID: null,
    customCanvasID: 'draw_veneer2',
    customframeID: 'draw_frame',
    pausePlayTime: 0,
    videoPlaying: false,
    streamid: 0,
    setTimeLoop: 0.3

  },

  setupAnnotationToolbar() {
    const toolbarCont = document.createElement('div');
    toolbarCont.setAttribute('id', 'annotationToolbarContainer');
    toolbarCont.style = 'position: absolute;bottom: 0; z-index: 98;';
    const toolbar = document.createElement('div');
    toolbar.setAttribute('id', 'toolbar');
    toolbar.innerHTML = `<div class="atn-btns">
      <button id="annotate-draw">Draw</button>
      <select id="selDrawMethod">
        <option value="pencil" selected="selected">Pencil</option>
        <option value="text">Text</option>
      </select>
      <input
      type="color"
      id="favcolor"
      name="favcolor"
      value="#ff0000"

    />
    <select id="selWidth" >
      <option value="1">1</option>
      <option value="3" selected="selected">3</option>
      <option value="5">5</option>
      <option value="7">7</option>
      <option value="9">9</option>
      <option value="11">11</option>
    </select>
    <input type="button" id="eraseBtn" value="Erase" />
    <input type="button" id="clearBtn" value="Clear" />
    <input type="button" id="play" value="Play-Pause" />

      </div>`;
    toolbarCont.append(toolbar);
    // this.bindEventListernersForTools()
    return { toolbarCont, toolbar };
  },

  _QS(domSelector, all = false) {
    if (all) {
      return document.querySelectorAll(`${domSelector}`) ? document.querySelectorAll(`${domSelector}`) : false;
    }
    return document.querySelector(`${domSelector}`) ? document.querySelector(`${domSelector}`) : false;


  },
  bindEventListernersForTools() {
    let _this = this;
    if (_this._QS('#annotate-draw')) {
      _this._QS('#annotate-draw').addEventListener("click", (e) => {
        _this.annotateToolAction('tool', 'draw')
      })
    }
    if (_this._QS('#selDrawMethod')) {
      _this._QS('#selDrawMethod').addEventListener("change", (e) => {
        _this.annotateToolAction('drawMethod', e.target.value)
      })
    }
    if (_this._QS('#selWidth')) {
      _this._QS('#selWidth').addEventListener("change", (e) => {
        _this.annotateToolAction('lineWidth', e.target.value)
      })
    }
    if (_this._QS('#favcolor')) {
      _this._QS('#favcolor').addEventListener("change", (e) => {
        _this.annotateToolAction('strokeColor', e.target.value)
      })
    }
    if (_this._QS('#eraseBtn')) {
      _this._QS('#eraseBtn').addEventListener("click", (e) => {
        _this.annotateToolAction('erase')
      })
    }
    if (_this._QS('#clearBtn')) {
      _this._QS('#clearBtn').addEventListener("click", (e) => {
        _this.annotateToolAction('clear')
      })
    }
    if (_this._QS('#play')) {
      _this._QS('#play').addEventListener("click", (e) => {
        _this.pause_play()
      })
    }

  },

  annotateAddInput(x, y) {
    let _this = this;
    const input = document.createElement('input');
    input.className = 'annotate-text';
    input.type = 'text';
    input.style.position = 'fixed';
    input.style.zIndex = 50;
    input.style.left = `${x - 4}px`;
    input.style.top = `${y - 4}px`;
    input.onkeydown = function (e) {
      const keyCode = e.keyCode;
      if (keyCode === 13) {
        _this.annotateDrawText(e.target.value);
        document.body.removeChild(e.target);
        _this.annotationConfig.hasInput = false;
      } else if (keyCode === 27) {
        document.body.removeChild(e.target);
        _this.annotationConfig.hasInput = false;
      }
    };
    document.body.appendChild(input);
    input.focus();
    this.annotationConfig.hasInput = true;
  },
  pause_play() {
    let _this = this;
    if (_this.annotationConfig.videoPlaying) {
      clearInterval(_this.annotationConfig.pausePlayTime);
      _this.annotationConfig.videoPlaying = false;
    }
    else {
      let videoele = document.getElementById(`stream${_this.annotationConfig.streamid}`);
      if (!videoele) {
        return;
      }
      let videoCanvas = document.getElementById(_this.annotationConfig.customframeID);
      if (!videoCanvas) {
        return;
      }
      let videoCanvasContext = videoCanvas.getContext('2d');
      _this.annotationConfig.pausePlayTime = setInterval(() => {
        if(_this.canvasOptions.width > 0 && _this.canvasOptions.height > 0){
          videoCanvasContext.drawImage(videoele, 0, 0, _this.canvasOptions.width, _this.canvasOptions.height);
        }
      }, _this.annotationConfig.setTimeLoop);
      _this.annotationConfig.videoPlaying = true;

    }
  },

  handleEnter(e) {
    let _this = this;
    const keyCode = e.keyCode;
    if (keyCode === 13) {
      _this.annotateDrawText(e.target.value);
      document.body.removeChild(e.target);
      _this.annotationConfig.hasInput = false;
    } else if (keyCode === 27) {
      document.body.removeChild(e.target);
      _this.annotationConfig.hasInput = false;
    }
  },

  annotateDrawText(txt) {
    let _this = this;
    _this.annotationConfig.drawCtx.textBaseline = 'top';
    _this.annotationConfig.drawCtx.textAlign = 'left';
    _this.annotationConfig.drawCtx.fillStyle = _this.annotationConfig.strokeColor;
    _this.annotationConfig.drawCtx.font = '14px sans-serif';
    _this.annotationConfig.drawCtx.fillText(
      txt,
      _this.annotationConfig.lastMouseX - 4,
      _this.annotationConfig.lastMouseY - 4,
    );
  },

  reOffset(selector) {
    let _this = this;
    const canvasData = selector.getBoundingClientRect();
    _this.annotationConfig.canvasX = canvasData.left;
    _this.annotationConfig.canvasY = canvasData.top;
  },
  startFrame() {
    this.annotationConfig.videoPlaying = false;
  },
  getCanvasId() {
    return this.annotationConfig.customCanvasID;
  },
  getVideoFrameId() {
    return this.annotationConfig.customframeID;
  },
  getCanvasWidth() {
    return this.canvasOptions.width;
  },
  getCanvasHeight() {
    return this.canvasOptions.height;
  },
  toolBarAction(action, value) {
    let _this = this;
    if (action === 'tool') {
      _this.annotationConfig.toolType = value;
      _this.annotationConfig.isErase = false;
    } else if (action === 'erase') {
      _this.annotationConfig.toolType = action;
      _this.annotationConfig.isErase = true;
    } else if (action === 'strokeColor') {
      _this.annotationConfig.strokeColor = value;
    } else if (action === 'lineWidth') {
      _this.annotationConfig.lineWidth = value;
    } else if (action === 'drawMethod') {
      _this.annotationConfig.drawMethod = value;
    } else if (action === 'clear') {
      const elements = document.getElementsByClassName('annotate-text');
      while (elements.length > 0) {
        elements[0].remove();
      }
      _this.annotationConfig.drawCtx.clearRect(
        0,
        0,
        _this.canvasOptions.width,
        _this.canvasOptions.height,
      );
    }
  },

  appendCustomCanvas(wrapper, className, width, height) {
    let _this = this;
    _this.canvasOptions.width = width;
    _this.canvasOptions.height = height;
    const drawcanvas = document.createElement('canvas');
    drawcanvas.id = _this.annotationConfig.customCanvasID;
    drawcanvas.width = width;
    drawcanvas.height = height;
    drawcanvas.className = className;
    drawcanvas.setAttribute('style', _this.annotateStyle);
    if (!wrapper) {
      return;
    }
    wrapper.append(drawcanvas);
    const { toolbarCont, toolbar } = _this.setupAnnotationToolbar();
    wrapper.append(toolbarCont);

  },
  appendCanvasFrame(wrapper, className, width, height, stream) {
    let _this = this;
    _this.canvasOptions.width = width;
    _this.canvasOptions.height = height;
    const drawcanvas2 = document.createElement('canvas');
    const ctx = drawcanvas2.getContext('2d');
    drawcanvas2.id = _this.annotationConfig.customframeID;
    drawcanvas2.width = width;
    drawcanvas2.height = height;
    if (!stream) {
      return;
    }
    const stream_iD = stream.getID();
    _this.annotationConfig.streamid = stream_iD;
    const canvas_video_player2 = document.getElementById(`stream${stream_iD}`);
    if (!canvas_video_player2) {
      return;
    }
    drawcanvas2.className = className;
    drawcanvas2.setAttribute('style', _this.frameStyle);
    if (!wrapper) {
      return;
    }
    wrapper.append(drawcanvas2);
  },




  onDown(e, touch) {
    let _this = this;

    e.preventDefault();
    var clientX, clientY;
    if (e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel') {
      var evt = (typeof e.originalEvent === 'undefined') ? e : e.originalEvent;
      var touch = evt.touches[0] || evt.changedTouches[0];
      clientX = touch.pageX;
      clientY = touch.pageY;
    } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover' || e.type == 'mouseout' || e.type == 'mouseenter' || e.type == 'mouseleave') {
      clientX = e.clientX;
      clientY = e.clientY;
    }

    _this.reOffset(_this.annotationConfig.drawElement);
    _this.annotationConfig.lastMouseX = _this.annotationConfig.mouseX = parseInt(clientX - _this.annotationConfig.canvasX);
    _this.annotationConfig.lastMouseY = _this.annotationConfig.mouseY = parseInt(clientY - _this.annotationConfig.canvasY);
    _this.annotationConfig.mouseDown = true;
    if (
      _this.annotationConfig.drawMethod === 'text' &&
      _this.annotationConfig.toolType === 'draw'
    ) {
      _this.annotateAddInput(clientX, clientY);
    }
  },

  onMove(e, inputContext, touch) {
    let _this = this;
    e.preventDefault();
    var clientX, clientY;
    if (e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel') {
      var evt = (typeof e.originalEvent === 'undefined') ? e : e.originalEvent;
      var touch = evt.touches[0] || evt.changedTouches[0];
      clientX = touch.pageX;
      clientY = touch.pageY;
    } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover' || e.type == 'mouseout' || e.type == 'mouseenter' || e.type == 'mouseleave') {
      clientX = e.clientX;
      clientY = e.clientY;
    }


    _this.annotationConfig.mouseX = parseInt(clientX - _this.annotationConfig.canvasX);
    _this.annotationConfig.mouseY = parseInt(clientY - _this.annotationConfig.canvasY);

    if (_this.annotationConfig.mouseDown && _this.annotationConfig.drawMethod === 'pencil') {

      _this.annotationConfig.drawCtx.beginPath();
      if (_this.annotationConfig.toolType === 'draw') {
        _this.annotationConfig.drawCtx.globalCompositeOperation = 'source-over';
        _this.annotationConfig.drawCtx.strokeStyle = _this.annotationConfig.strokeColor;
        _this.annotationConfig.drawCtx.lineWidth = _this.annotationConfig.lineWidth;
      } else {
        _this.annotationConfig.drawCtx.globalCompositeOperation = 'destination-out';
        _this.annotationConfig.drawCtx.lineWidth = 10;
      }

      _this.annotationConfig.drawCtx.moveTo(
        _this.annotationConfig.lastMouseX,
        _this.annotationConfig.lastMouseY,
      );
      _this.annotationConfig.drawCtx.lineTo(
        _this.annotationConfig.mouseX,
        _this.annotationConfig.mouseY,
      );
      _this.annotationConfig.drawCtx.lineJoin = inputContext.lineCap = 'round';
      _this.annotationConfig.drawCtx.stroke();
    }
    _this.annotationConfig.lastMouseX = _this.annotationConfig.mouseX;
    _this.annotationConfig.lastMouseY = _this.annotationConfig.mouseY;
  },

  onUp(e) {
    e.preventDefault();
    this.annotationConfig.mouseDown = false;
  },

  annotateToolAction(action, value) {
    this.toolBarAction(action, value);
  },

  /*Draw on mouse move*/
  mouseAnnotate(canvasDomID, inputContext, canvasVideoPlayerID, stream = null) {
    let _this = this;
    if (stream) {
      _this.stream = stream;
    }
    _this.isAnnotationStarted = true;
    _this.annotationConfig.drawElement = document.getElementById(_this.annotationConfig.customCanvasID);
    _this.annotationConfig.drawCtx = _this.annotationConfig.drawElement.getContext('2d');
    _this.annotationConfig.canvasDomID = canvasDomID;
    _this.annotationConfig.canvasVideoPlayerID = canvasVideoPlayerID;

    //on onmousedown
    _this.annotationConfig.drawElement.addEventListener('mousedown', (e) => {
      _this.onDown(e, false);

    });
    _this.annotationConfig.drawElement.addEventListener('touchstart', (e) => {
      _this.onDown(e, true);
    });

    //on onmousemove
    _this.annotationConfig.drawElement.addEventListener('mousemove', (e) => {
      _this.onMove(e, inputContext, false);
    });
    _this.annotationConfig.drawElement.addEventListener('touchmove', (e) => {
      _this.onMove(e, inputContext, true);
    });

    //on mouseup
    _this.annotationConfig.drawElement.addEventListener('mouseup', (e) => {
      _this.onUp(e);
    });
    _this.annotationConfig.drawElement.addEventListener('touchcancel', (e) => {
      _this.onUp(e);
    });
    return _this.annotationConfig.drawElement;
  },

  stopAnnotation() {
    let _this = this;
    _this.isAnnotationStarted = false;
    const canvasWrapper = document.getElementById('canvas-wrapper');
    if (canvasWrapper) canvasWrapper.remove();
    const elements = document.getElementsByClassName('annotate-text');
    while (elements.length > 0) {
      elements[0].remove();
    }
    const annotateDiv = document.querySelector('.annotate-div');
    const annotateDivParent = annotateDiv.parentElement;
    annotateDivParent.prepend(annotateDiv.firstElementChild);
    annotateDivParent.firstChild.style.height = `100%`;
    annotateDivParent.firstChild.style.width = `100%`
    annotateDiv.remove();
    _this.annotationConfig.toolType = 'draw';
    _this.annotationConfig.isErase = false;
    _this.annotationConfig.drawMethod = 'pencil';
    _this.annotationConfig.strokeColor = '#ff0000';
    _this.annotationConfig.lineWidth = 3;
  },

  // resize() function set canvas height and width according to stream size
  // and height , width of canvas is decreased and increased in correct aspect ratio.

  resize() {
    let _this = this;
    if (_this.isAnnotationStarted) {
      setTimeout(() => {
        const stream = _this.stream;
        if (stream) {
          var streamId = stream.getID();
          var streamVeneerCanvas = document.getElementById(`stream${streamId}_veneer`);
          var drawVeneerCanvas = document.getElementById(`draw_veneer2`);
          var frameVeneerCanvas = document.getElementById(`draw_frame`);
          var wrapperDiv = document.getElementById(`canvas-wrapper`);
          if (drawVeneerCanvas && frameVeneerCanvas && wrapperDiv) {
            var canvas = drawVeneerCanvas.getContext("2d");
              var imageData = canvas.getImageData(0, 0, drawVeneerCanvas.width, drawVeneerCanvas.height);
            var track = stream.stream.getVideoTracks()[0];
            var { height, width } = track.getSettings() ? track.getSettings() : track.getConstraints();
            var annotateScreen = document.querySelector(`.annotate-div`);
            var playerDiv = document.querySelector(`#player_${streamId}`);
            var annotateHeight = annotateScreen.clientHeight;
            var annotateWidth = annotateScreen.clientWidth;
            if (annotateHeight < annotateWidth) {
              var ratio = annotateHeight / height;
              var increasedHeight = height * ratio;
              var increasedWidth = width * ratio
              if (increasedWidth > annotateWidth) {
                ratio = annotateWidth / width;
                height = height * ratio;
                width = width * ratio;
              } else {
                height = increasedHeight;
                width = increasedWidth;
              }
            } else {
              var ratio = annotateWidth / width;
              var increasedHeight = height * ratio;
              var increasedWidth = width * ratio;
              if (increasedHeight > annotateHeight) {
                ratio = annotateHeight / height;
                height = height * ratio;
                width = width * ratio;
              } else {
                height = increasedHeight;
                width = increasedWidth;
              }
            }

            playerDiv.style.height = `${height}px`;
            playerDiv.style.width = `${width}px`;
            streamVeneerCanvas.width = width;
            streamVeneerCanvas.height = height;
            drawVeneerCanvas.width = width;
            drawVeneerCanvas.height = height;
            frameVeneerCanvas.width = width;
            frameVeneerCanvas.height = height;
            wrapperDiv.style.width = `${width}px`;
            wrapperDiv.style.height = `${height}px`;
            createImageBitmap(imageData).then(function (imgBitmap) {
              canvas.drawImage(imgBitmap, 0, 0, width, height);
            })
            _this.canvasOptions.width = width;
            _this.canvasOptions.height = height;
            _this.reOffset(_this.annotationConfig.drawElement);
          }
        }
      }, 100);
    }
  }
}

// window.addeventlistener is commented because it is handled from UI side with advanced resize

// window.addEventListener('resize', function () {
//   Annotate.resize();
// });

/* harmony default export */ __webpack_exports__["a"] = (Annotate);


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Pair__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Room__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_Base64__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Stream__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__Common_config__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__customErrors__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__EventLogger__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__customEvents__ = __webpack_require__(8);













const constants = __WEBPACK_IMPORTED_MODULE_8__vcxEventProperties__["a" /* default */].constant;

/*
 *   Author: Avnish
 *   Description: Merge all method in a singel class
 */
var myRoom = undefined;
const VcxQuickApi = {};
VcxQuickApi.default = {
  minVideoBW: 80,
  maxVideoBW: 1500,
  scheme: 'notify-break-recover',
};

//////////disconnect Room///////////////
VcxQuickApi.disconnectRoom = (room) => {
  myRoom = undefined;
  if (room) {
    room.disconnect();
  }
};

/////////Get Device List//////////////
VcxQuickApi.getDevice = (param1, param2) => {
  let callback, options;
  if (param1 != undefined && param1 != null){
    if(typeof param1 === 'function'){
      callback = param1;
      options = {mic:true, cam:true, speaker:false}; //default
    }else if (typeof param1 === 'object'){
      if (!((param1.mic != undefined && typeof param1.mic !== 'boolean') ||
            (param1.cam != undefined && typeof param1.cam !== 'boolean') ||
            (param1.speaker != undefined && typeof param1.speaker !== 'boolean'))){
        options = param1;
      }
    }
  }else {options = {mic:true, cam:true, speaker:false};}
  if (!callback && param2 != undefined && param2 != null && typeof param2 === 'function') callback = param2;
  if (__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.is_supported() && options && callback){
    __WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].getDeviceList(options, callback);
  }else {
    if (!__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.is_supported()) {
      __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('Failed Webrtc support is missing ');
      if (callback) callback(__WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1000);
    }else {
      __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('Failed invalid param - callback or options');
      if (callback) callback(__WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1155);
    }
  }
};

VcxQuickApi.notifyDeviceUpdate = (options, callback) => {
  if (!__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.is_supported()) {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('Failed Webrtc support is missing ');
    return;
  }
  if ((!options || (typeof options === 'object' && (options.mic || options.cam))) &&
      callback && typeof callback === 'function') {
    __WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].mediaDeviceUpdate(false, options, 'vcxVcxQuickApi_notifyDeviceUpdate',(devices) => {
      callback(devices);
    });
  }else {
    if (callback && typeof callback === 'function')
      callback(__WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1155);
  }
};

VcxQuickApi.switchMediaDevice = (stream, audioDeviceId, videoDeviceId, callback = () => { }) => {
  if (typeof callback === 'function') {
    if (!__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.is_supported()) {
      __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('Failed Webrtc support is missing ');
      callback(__WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1000);
      return;
    }

    if ((audioDeviceId && typeof audioDeviceId === 'string') && (videoDeviceId && typeof videoDeviceId === 'string')) {
      stream.switchMediaDevices(stream, audioDeviceId, videoDeviceId, callback);
    } else {
      __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('Invalid Device Id');
      callback(false);
    }
  }
  else {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('switchMediaDevice() invalid param - callback');
  }


};

///////////Join Room/////////////
VcxQuickApi.joinRoom = (token, streamInfo, param3, param4) => {
  let callback = () =>{}, specInput = {};
  let reconnectInfo = {allow_reconnect: true,number_of_attempts: 3,timeout_interval: 45000 };
  if (param3 == undefined && param4 == undefined){
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('joinRoom() failed, callback is missing. invalid parameters');
    return;
  }
  if (param3 != undefined  && typeof param3  === 'function') {
    // old version of joinRoom API
    //(token, streamInfo, callback, reconnectInfo = {allow_reconnect: true,number_of_attempts: 3,timeout_interval: 45000 })
    callback = param3;
    if (param4 != undefined) reconnectInfo = param4;
  }else if (param4 != undefined && typeof param4  === 'function'){
    callback = param4;
    if (param3 != undefined) specInput = param3;
    else {
      __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('joinRoom() failed, callback is missing. invalid parameters');
      return;
    }
  }
  if (!__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.is_supported()) {
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('Failed Webrtc support is missing ');
    callback(null, __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1000);
    return;
  }
  if (token == undefined || streamInfo == undefined){
    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('joinRoom() failed, token/streamInfo is missing. invalid parameters');
    callback(null, __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1155);
    return;
  }

  let room;
  let localStream;
  let error = null;
  let success = null;
  __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info(`SDK version: ${__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.product.version} browser name: ${__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.browser_type} browser version: ${__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.browser_info.version} device type: ${__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.browser_info.device_type}`);

  if (token != null) {
    const tok = JSON.parse(__WEBPACK_IMPORTED_MODULE_3__utils_Base64__["a" /* default */].decodeBase64(token));
    //var tok = JSON.parse(window.atob(token));
    __WEBPACK_IMPORTED_MODULE_9__EventLogger__["a" /* default */].init(tok);
    tok.version = __WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.product.version;
    specInput.reconnectInfo = reconnectInfo;
    specInput.token = __WEBPACK_IMPORTED_MODULE_3__utils_Base64__["a" /* default */].encodeBase64(JSON.stringify(tok));
    //room = Room(undefined, undefined, { token: window.btoa(JSON.stringify(tok)),reconnectInfo });
    room = Object(__WEBPACK_IMPORTED_MODULE_2__Room__["a" /* default */])(undefined, undefined, specInput);
    const onAccessSuccess = () => {
      if (__WEBPACK_IMPORTED_MODULE_1__Pair__["a" /* default */].browserEngineCheck() !== 'IE') {
        room.addEventListener('room-connected', (streamEvent) => {
          success = {
            streams: streamEvent.streams,
            room,
            roomData: streamEvent.room,
            localStream,
          };
          myRoom = room;
          let pubOps;
          if (streamEvent.me !== undefined && streamEvent.me !== null && (room.mode !== 'lecture' ||
            streamEvent.me.role !== 'participant' || room.floorGranted) &&
            (streamInfo.audio || streamInfo.video)) {
            pubOps = {scheme: streamInfo.scheme ? streamInfo.scheme : VcxQuickApi.default.scheme,
                      maxVideoLayers: room.maxVideoLayers, forceTurn: streamInfo.forceTurn
                     };
            if (streamInfo.maxVideoBW) pubOps.maxVideoBW = streamInfo.maxVideoBW;
            if (streamInfo.minVideoBW) pubOps.minVideoBW = streamInfo.minVideoBW;
            if (streamInfo.maxVideoFps) pubOps.maxVideoFps = streamInfo.maxVideoFps;
            if (streamInfo.maxVideoFps) pubOps.maxVideoFps = streamInfo.maxVideoFps;
            if (streamInfo.audioMuted) pubOps.audioMuted = streamInfo.audioMuted;
            if (streamInfo.videoMuted) pubOps.videoMuted = streamInfo.videoMuted;
          }

          if (room.me.role === "audience" && (room.subscription && !room.subscription.hls)) {
            __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('Licence error :  HLS not supported !!');
            return;
          }

          if (room.reconnectionState === false) {
            if (streamInfo.video && room.subscription && !room.subscription.audio_video) {
              __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('Licence error : video not supported, ignoring video option');
              streamInfo.video = false;
            }
            if (streamInfo.audio && room.subscription && !room.subscription.audio_only && !room.subscription.audio_video) {
              __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].error('Licence error : audio not supported, ignoring audio option');
              streamInfo.audio = false;
            }

            const publishStream = (ops, callback) => {
              let resp;
              room.publish(localStream, ops, (response) => {
                if (response.result === 0) {
                  success.publishId = response.id;
                  if (room.mediaConfiguration !== constants.H264_CODEC && __WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.browser_info.name === 'safari' &&
                      __WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.browser_info.version <= constants.SAFARI_VERSION_NOT_SUPPORTING_VP8) {
                    callback(success, __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1152);
                  } else {
                    callback(success, null);
                  }
                  if (streamEvent.mediaRecord) room.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({ type: 'room-record-on', message: {} }));
                  if (room.muteInfo.room.audio) room.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({ type: 'room-muted', message: {} }));
                } else if (response.result === __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_1130.result) callback(success, response);
                else callback(null, response);
              });
            };
            if (pubOps != undefined && room.waitRoom === false && (room.me.role != 'viewer' && room.me.role != 'audience')) {
              publishStream(pubOps, callback);
            } else if ( (room.me.role != 'viewer' && room.me.role != 'audience') && room.waitRoom) {
              /*room.dispatchEvent(RoomEvent({ type: 'room-awaited', message}));*/
              callback(success, null);
              room.addEventListener('wait-room-disabled', (arg) => {
                room.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({ type: 'room-allowed', message: arg.message }));
                if (room.mode !== 'lecture')
                  publishStream(pubOps, callback);
              });
            } else {
              __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info( true ? 'no audio&video' : 'lecture mode publisher');
              if (localStream){
                if (streamInfo.audioMuted){
                  localStream.muteAudio((resp) => {
                    if (resp.result == __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_000.result) {
                      room.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_6__Events__["g" /* UserEvent */])({ type: 'user-audio-muted', clientId: room.clientId}));
                    }
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('audioSelfMuteCallback: '+ JSON.stringify(resp));
                  },
                  false, 0, true);
                }
                if (streamInfo.videoMuted){
                  localStream.muteVideo((resp) => {
                    if (resp.result !== __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_000.result) {
                      room.dispatchEvent(Object(__WEBPACK_IMPORTED_MODULE_6__Events__["g" /* UserEvent */])({ type: 'user-video-muted', clientId: room.clientId}));
                    }
                    __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info('videoSelfMuteCallback: ' + JSON.stringify( resp));
                  },
                  false, 0, true);
                }
              }
              callback(success, null);
            }
          }
        });

        room.addEventListener('room-error', (err) => {
          if (success == null)
          callback(success, err);
        });

        room.addEventListener('stream-added', (streamEvent) => {
          room.subscribe(streamEvent.stream);
        });

        room.addEventListener('active-talkers-updated', (event) => {
          const activeList = event.message.activeList;
          const activeListLength = activeList.length;
          if (activeListLength > 0) {
            for (let index = 0; index < activeListLength; index++) {
              if (activeList[index].mediatype === 'audio' && activeList[index].muteDueToBw === true) {
                room.remoteStreams.getAll()[activeList[index].streamId].audioOnly = true;
                const userMutedEvt = Object(__WEBPACK_IMPORTED_MODULE_6__Events__["e" /* RoomEvent */])({
                  type: 'user-muted-due-to-bw-crunch',
                  message: {
                    streamId: activeList[index].streamId,
                    clientId: activeList[index].clientId,
                    name: activeList[index].name,
                  },
                });
                room.dispatchEvent(userMutedEvt);
              }
            }
          }
        });
      }

      if (room.reconnectionState === false && room.reconnectAttempt == 0) {
        room.connect(reconnectInfo, (resp)=>{
          __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug ("room.connect callback resp: " + JSON.stringify(resp));
          if (resp.result != __WEBPACK_IMPORTED_MODULE_7__customErrors__["a" /* default */].error_000.result) callback(null,resp);
        });
      } else {
        __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].debug(' Reconnection case in join room public api');
      }
    };

    const onAccessError = (err) => {
      error = err;
      callback(success, error);
    };

    if (streamInfo.stream != undefined || (streamInfo.audio || streamInfo.video)) {
      localStream = room.initPublishStream(streamInfo.div, streamInfo, onAccessSuccess, onAccessError);
    } else {
      __WEBPACK_IMPORTED_MODULE_0__utils_Logger__["default"].info(' No publish stream. audio and video are disabled..');
      onAccessSuccess();
    }
  }
  return localStream;
};

////////////////List Participants/////////////////
VcxQuickApi.listParticipants = (room) => {
  if (!__WEBPACK_IMPORTED_MODULE_5__Common_config___default.a.is_supported()) {
    console.log('Failed Webrtc support is missing ');
    return;
  }
  let users = [];
  if (room) {
    users = room.userList;
  }
  return users;
};

const socketEventToArgs = (func, event) => {
  if (event.args) {
    func(...event.args);
  } else {
    func();
  }
};

////////////////ReceiveMessage/////////////////
VcxQuickApi.ReceiveMessage = (stream, div) => {
  if (stream) {
    stream.addEventListener('stream-data', (evt) => {
    });
  }
};

////////////////Send Message/////////////////
VcxQuickApi.sendMessage = (stream, data) => {
  if (stream) {
    stream.sendData(data);
  }
};

VcxQuickApi.getRoom = () => {
    return myRoom;
};

/* harmony default export */ __webpack_exports__["a"] = (VcxQuickApi);


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__testWebRtc_mictest__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__testWebRtc_camresolutionstest__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__testWebRtc_nettest__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__testWebRtc_conntest__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__testWebRtc_bandwidth_test__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__testSignallingServer_signalling__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_Logger__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Events__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Common_config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Common_config___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8__Common_config__);
/* eslint-disable no-console */
/* eslint-disable func-names */
/*
*Author: Shri Kant
 */








 // This package is needed for managing events


const util = __webpack_require__(13);

const PREFIX_INFO = '[ INFO ]';
const PREFIX_OK = '[ OK ]';
const PREFIX_FAILED = '[ FAILED ]';
const PREFIX_WARNING = '[ WARN ]';
const PREFIX_POOR = '[ POOR ]';
const PREFIX_ACCEPTABLE = '[ MODERATE ]';
const PREFIX_GOOD = '[ GOOD ]';

const MICROPHONE = 'microphone';
const CAMERA = 'camera';
const NETWORK = 'network';
const CONNECTIVITY = 'connectivity';
const THROUGHPUT = 'throughput';
const BANDWIDTH = 'bandwidth';
const SIGNALLING = 'signalling';
const AVAILABLE_REGION = ['IN','US', 'SG', 'DE'];

const MAX_BANDWIDTH_TEST_DURATION = 60;
const BITRATE_VIDEO_TEST_DURATION = 40;
const BITRATE_AUDIO_TEST_DURATION = 20;

const clientHealth = {};
let index = 0;
let testCases = [];
let responseMicrophone = {};
let responseCamera = {};
let responseNetwork = {};
let responseConnectivity = {};
let responseThroughPut = {};
let responseBandwidth = {};
let responseSignalling = {};
let audioDeviceId = '';
let videoDeviceId = '';
let regionId = [];
let running = false;
let bitrateOnly = false;
let eventDispatcher = null;
let testServerApiHost = '';
let testServerApiPort = '';
let forMobile = false;
let testDurationDataThroughput = 0;
let testDurationVideoBandwidth = 0;
let testDurationAudioBandwidth = 0;
let forIosVersion13 = false;
/* This API reset all the global variables */
function reset() {
  index = 0;
  testCases.splice(0, testCases.length);
  responseMicrophone = {};
  responseCamera = {};
  responseNetwork = {};
  responseConnectivity = {};
  responseThroughPut = {};
  responseBandwidth = {};
  responseSignalling = {};
  videoDeviceId = '';
  audioDeviceId = '';
  regionId = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.default_region;
  testServerApiHost = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.proxy_api_url;
  testServerApiPort = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.proxy_api_port;
  forMobile = false;
  bitrateOnly = false;
  testDurationDataThroughput = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.data_throughput_duration;
  testDurationVideoBandwidth = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.video_bandwidth_duration;
  testDurationAudioBandwidth = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.audio_bandwidth_duration;
}

/*
 * Class: TestRTC
 * Description: This class create a test case. It collects all the results e.g error, success,
 * warning etc while test case is in execution.
 * This class also collect the data and prepares the JSON object for the output.
 * When test case completed it calls the completion callback.
 */
class TestRTC {
  constructor(name, group, cb) {
    this.test_title = name;
    this.test_group = group;
    this.started = false;
    this.error_count = 0;
    this.warning_count = 0;
    this.success_count = 0;
    this.finished_cb = cb;
    this.region = 'IN';
    this.server = 'TURN';
    this.uri = '';
    this.progress_value = 0;
    this.state = 'not_tested';
    this.start_time = 0;
    this.bitrate_only = false;
    this.json_response = {
      result: this.state,
      execution_time: 'not_set',
      success: [],
      error: [],
      warning: [],
      info: [],
    };

    /* This API marks that  test case is executed */
    this.done = function () {
      const success = (this.error_count + this.warning_count === 0 && this.success_count > 0);
        if (success) {
          this.state = 'success';
        } else if (this.warning_count > 0 && this.error_count === 0) {
          this.state = 'warning';
        } else if (this.isDisabled) {
          this.state = 'disabled';
        } else {
          this.state = 'failure';
        }

        this.json_response.result = this.state;
        let now = new Date();
        this.json_response.execution_time = `${(now - this.start_time)} ms`;
        let current_response = { };
        switch (this.test_group) {
          case MICROPHONE:
            responseMicrophone[this.test_title] = this.json_response;
            current_response[this.test_title] = responseMicrophone[this.test_title];
            break;
          case CAMERA:
            responseCamera[this.test_title] = this.json_response;
            current_response[this.test_title] = responseCamera[this.test_title];
            break;
          case NETWORK:
            this.setServer();
            current_response = this.fillResponse(responseNetwork);
            break;
          case CONNECTIVITY:
            this.setServer();
            current_response = this.fillResponse(responseConnectivity);
            break;
          case THROUGHPUT:
            this.setServer();
            current_response = this.fillResponse(responseThroughPut);
            break;
          case BANDWIDTH:
            this.setServer();
            current_response = this.fillResponse(responseBandwidth);
            break;
          case SIGNALLING:
              this.setServer();
            current_response = this.fillResponse(responseSignalling);
              break;
            default:
              break;
        }
        const msg = {
          test_group: this.test_group,
          test_case: this.test_title,
          status: 'finished',
          output: current_response
        };
        if(this.test_group === NETWORK || this.test_group === CONNECTIVITY || this.test_group === THROUGHPUT
          || this.test_group === BANDWIDTH || this.test_group === SIGNALLING) {
            msg['test_region'] = this.region;
            msg['test_server'] = this.server;
          }
        const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["a" /* ClientHealthEvent */])({ type: 'client-diagnosis-status', message: msg });
        if(forIosVersion13 === true) {
          window.webkit.messageHandlers.callbackHandler.postMessage(connectEvt);
        } else {
          eventDispatcher.dispatchEvent(connectEvt);
        }
        this.finished_cb();
    };

    /* Internal API */
    this.fillResponse = function (testResponse) {
      let response = { };
      if (!testResponse.hasOwnProperty(this.test_title)) {
        testResponse[this.test_title] = {};
      }
      if (!(testResponse[this.test_title].hasOwnProperty(this.region))) {
        testResponse[this.test_title][this.region] = {};
      }
      if (!(testResponse[this.test_title][this.region].hasOwnProperty(this.server))) {
        testResponse[this.test_title][this.region][this.server] = {};
      }
      testResponse[this.test_title][this.region][this.server] = this.json_response;
      response[this.test_title] = this.json_response;
      //response[this.test_title][this.region] = {};
      //response[this.test_title][this.region][this.server] = this.json_response;
      return response;
    };

    /* This API reports the fatal events */
    this.reportFatal = function (str) {
      this.reportError(str);
      this.done();
    };

    /* This API reports the success events */
    this.reportSuccess = function (str) {
      this.success_count += 1;
      __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].info(PREFIX_OK + str);
      this.json_response.success.push({ message: str });
    };

    /* This API adds the server info in json */
    this.setServer = function () {
      this.json_response.server = {};
      this.json_response.server.region = this.region;
      if (this.server === 'TURN') {
        this.json_response.server.url = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.ice_servers[this.region].turnURI;
      } else {
        this.json_response.server.url = __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.ice_servers[this.region].stunURI;
      }
    };

    /* This API reports the error events */
    this.reportError = function (str) {
      this.error_count += 1;
      __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].error(PREFIX_FAILED + str);
      this.json_response.error.push({ message: str });
    };

    /* This API reports the warning events */
    this.reportWarning = function (str) {
      this.warning_count += 1;
      __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].warning(PREFIX_WARNING + str);
      this.json_response.warning.push({ message: str });
    };

    /* This API reports the info events */
    this.reportInfo = function (str) {
      __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].info(PREFIX_INFO + str);
      this.json_response.info.push({message: str});
    };

    this.fillBandwidth = function (str) {
      this.json_response['bandwidth_bps'] = str;
    };
    this.fillPacketsLost = function (str) {
      this.json_response['packets_lost_percentage'] = str;
    };

    /* This API update the status of test case in execution */
    this.setProgress = function (value) {
      this.progress_value = value;
    };

    this.fillData = function (X, Y) {
      //console.log('time' + X + ',value = '+ Y);
    };

    /* This API reports the events based upon their state */
    this.reportByState = function (str, state) {
      switch (state) {
        case 'poor':
          this.error_count += 1;
          __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].error(PREFIX_POOR + str);
          this.json_response.error.push({ message: `${str} [BAD]`});
          break;
        case 'moderate':
          this.warning_count += 1;
          __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].warning(PREFIX_ACCEPTABLE + str);
          this.json_response.warning.push({ message: `${str} [ACCEPTABLE]`});
          break;
        case 'good':
          this.success_count += 1;
          __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].info(PREFIX_GOOD + str);
          this.json_response.success.push({ message: `${str} [GOOD]`});
          break;
        default:
          break;
      }
    };
  }
}

/* This API executes the selected test case */
function runTestCase(test) {
  util.setActiveTest(test);
  const msg = {
    test_group: test.test_group,
    test_case: test.test_title,
    status: 'started'
  };
  if(test.test_group === NETWORK || test.test_group === CONNECTIVITY || test.test_group === THROUGHPUT
    || test.test_group === BANDWIDTH || test.test_group === SIGNALLING) {
      msg['test_region'] = test.region;
      msg['test_server'] = test.server;
    }
  test.start_time = new Date();
  const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["a" /* ClientHealthEvent */])({ type: 'client-diagnosis-status', message: msg });
  if(forIosVersion13 === true) {
    window.webkit.messageHandlers.callbackHandler.postMessage(connectEvt);
  } else {
    eventDispatcher.dispatchEvent(connectEvt);
  }

  switch (test.test_title) {
    case 'audio_capture': {
      Object(__WEBPACK_IMPORTED_MODULE_0__testWebRtc_mictest__["a" /* testMicrophone */])(test, audioDeviceId);
      break;
    }
    case 'check_resolution_240':
    case 'check_resolution_480':
    case 'check_resolution_720':
    case 'check_supported_resolutions': {
      Object(__WEBPACK_IMPORTED_MODULE_1__testWebRtc_camresolutionstest__["a" /* testCamera */])(test, videoDeviceId);
      break;
    }
    case 'udp_enabled':
    case 'tcp_enabled':
    case 'ipv6_enabled': {
      Object(__WEBPACK_IMPORTED_MODULE_2__testWebRtc_nettest__["a" /* testNetwork */])(test);
      break;
    }
    case 'relay_connectivity':
    case 'reflexive_connectivity':
    case 'host_connectivity': {
      Object(__WEBPACK_IMPORTED_MODULE_3__testWebRtc_conntest__["a" /* testConnectivity */])(test);
      break;
    }
    case 'data_throughput':{
      Object(__WEBPACK_IMPORTED_MODULE_4__testWebRtc_bandwidth_test__["a" /* testThroughPut */])(test, null, testDurationDataThroughput);
      break;
    }
    case 'audio_bandwidth':{
      Object(__WEBPACK_IMPORTED_MODULE_4__testWebRtc_bandwidth_test__["a" /* testThroughPut */])(test, audioDeviceId, testDurationAudioBandwidth);
      break;
    }
    case 'video_bandwidth': {
      Object(__WEBPACK_IMPORTED_MODULE_4__testWebRtc_bandwidth_test__["a" /* testThroughPut */])(test, videoDeviceId, testDurationVideoBandwidth);
      break;
    }
    case 'signalling_connectivity': {
      Object(__WEBPACK_IMPORTED_MODULE_5__testSignallingServer_signalling__["a" /* testSignalling */])(test, testServerApiHost, testServerApiPort);
      break;
    }
    default:
      break;
  }

}

/* This API executes the selected test case */
function runNextTestCase() {
  if(running === false) {
    clientDiagnosticsStopped();
    return;
  }
  if (index < testCases.length) {
    const test = testCases[index];
    runTestCase(test);
    index += 1;
  } else {
    const jsonResponse = { };
    if (Object.keys(responseMicrophone).length) {
      jsonResponse[MICROPHONE] = responseMicrophone;
    }
    if (Object.keys(responseCamera).length) {
      jsonResponse[CAMERA] = responseCamera;
    }
    if (Object.keys(responseNetwork).length) {
      jsonResponse[NETWORK] = responseNetwork;
    }
    if (Object.keys(responseConnectivity).length) {
      jsonResponse[CONNECTIVITY] = responseConnectivity;
    }
    if (Object.keys(responseThroughPut).length) {
      jsonResponse[THROUGHPUT] = responseThroughPut;
    }
    if (Object.keys(responseBandwidth).length) {
      jsonResponse[BANDWIDTH] = responseBandwidth;
    }
    if (Object.keys(responseSignalling).length) {
      jsonResponse[SIGNALLING] = responseSignalling;
    }

    running = false;
    __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].info('All test case executed');


    const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["a" /* ClientHealthEvent */])({ type: 'client-diagnosis-finished', message: jsonResponse });
    if(forIosVersion13 === true) {
      window.webkit.messageHandlers.callbackHandler.postMessage(connectEvt);
    } else {
      eventDispatcher.dispatchEvent(connectEvt);
    }
    reset();
  }
}

/* This API add the test case in list */
function addTestCase(testName, testGroup, region = null, server = null, bitrate = false) {
  const test = new TestRTC(testName, testGroup, runNextTestCase);
  test.region = region;
  test.server = server;
  test.bitrate_only = bitrate;
  testCases.push(test);
}

/* This API creates the microphone related test cases */
function clientHealthMicrophone() {
  addTestCase('audio_capture', MICROPHONE);
}

/* This API creates the camera related test cases */
function clientHealthCamera() {
  if(forMobile === true) {
    addTestCase('check_supported_resolutions', CAMERA);
  } else {
    addTestCase('check_resolution_240', CAMERA);
    addTestCase('check_resolution_480', CAMERA);
    addTestCase('check_resolution_720', CAMERA);
    addTestCase('check_supported_resolutions', CAMERA);
  }
}

/* This API creates the network related test cases */
function clientHealthNetwork() {
  for (const index in regionId) {
    if(AVAILABLE_REGION.includes(regionId[index])) {
      addTestCase('udp_enabled', NETWORK, regionId[index], 'TURN');
      //addTestCase('udp_enabled', NETWORK, regionId[index], 'STUN');
      addTestCase('tcp_enabled', NETWORK, regionId[index], 'TURN');
      //addTestCase('tcp_enabled', NETWORK, regionId[index], 'STUN');
      addTestCase('ipv6_enabled', NETWORK, regionId[index], 'TURN');
      //addTestCase('ipv6_enabled', NETWORK, regionId[index], 'STUN');
    }
  }
}

/* This API creates the connectivity related test cases */
function clientHealthConnectivity() {
  for (const index in regionId) {
    if(AVAILABLE_REGION.includes(regionId[index])) {
      addTestCase('relay_connectivity', CONNECTIVITY, regionId[index], 'TURN');
      addTestCase('reflexive_connectivity', CONNECTIVITY, regionId[index], 'TURN');
      //addTestCase('reflexive_connectivity', CONNECTIVITY, regionId[index], 'STUN');
      addTestCase('host_connectivity', CONNECTIVITY, regionId[index], 'TURN');
      //addTestCase('host_connectivity', CONNECTIVITY, regionId[index], 'STUN');
    }
  }
}

/* This API creates the throughput related test cases */
function clientHealthThroughput() {
  for (const index in regionId) {
    if(AVAILABLE_REGION.includes(regionId[index])) {
      addTestCase('data_throughput', THROUGHPUT, regionId[index], 'TURN');
    }
  }
}

/* This API creates the bandwidth related test cases */
function clientHealthBandwidth() {
  for (const index in regionId) {
    if(AVAILABLE_REGION.includes(regionId[index])) {
      addTestCase('video_bandwidth', BANDWIDTH, regionId[index], 'TURN', bitrateOnly);
      addTestCase('audio_bandwidth', BANDWIDTH, regionId[index], 'TURN', bitrateOnly);
    }
  }
}

/* This API creates the signalling related test cases */
function clientHealthSignalling() {
  for (const index in regionId) {
    if(AVAILABLE_REGION.includes(regionId[index])) {
      addTestCase('signalling_connectivity', SIGNALLING, regionId[index], 'TURN');
    }
  }
}

/* This API creates begin the execution of test cases*/
function executeTestCases() {
  setTimeout(runNextTestCase, 1);
}

/*

var Options = {
     testNames: ['microphone', 'camera'],
     audioDeviceId: 'XXX',
     videoDeviceId: 'XXX',
     regionId: ['IN','US'],
     testServerApiHost: 'api-devvm47.vcloudx.com',
     testServerApiPort: '8626',
     stop: 'false'
 }

client = EnxRtc.clientDiagnostics(Options);
client.addEventListener("client-diagnosis-finished", function(response) {
     // handle json from response.message
});

client.addEventListener("client-diagnosis-failed", function(response) {
     // handle error message from response.message
});

client.addEventListener("client-diagnosis-status", function(response) {
     // handle info message from response.message
});

client.addEventListener('client-diagnosis-stopped', function(response) {
   // handle info message from response.message
});

 */
clientHealth.clientDiagnostics = (clientInfo) => {
  forIosVersion13 = false;
  if (clientInfo.hasOwnProperty('forIosVersion13') && clientInfo.forIosVersion13 === true) {
    forIosVersion13 = true;
  }
  if (clientInfo.hasOwnProperty('stop') && clientInfo.stop === true && eventDispatcher !== null) {
    clientDiagnosticsStop();
    return eventDispatcher;
  }
  if (running || testCases.length) {
    __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].error('Diagnosis is already in progress. Few resources are in use and may not be accessible.');
    return eventDispatcher;
  }
  eventDispatcher = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["c" /* EventDispatcher */])();

  if (!clientInfo.hasOwnProperty('testNames')) {
    setTimeout(diagnosisFailed, 1);
    return eventDispatcher;
  }
  if(!Array.isArray(clientInfo.testNames))
  {
    setTimeout(diagnosisFailed, 1);
    return eventDispatcher;
  }
  running = true;



  reset();

  if (clientInfo.hasOwnProperty('audioDeviceId')) {
    audioDeviceId = clientInfo.audioDeviceId;
  }
  if (clientInfo.hasOwnProperty('videoDeviceId')) {
    videoDeviceId = clientInfo.videoDeviceId;
  }
  if (clientInfo.hasOwnProperty('testServerApiHost')) {
    testServerApiHost = clientInfo.testServerApiHost;
  }
  if (clientInfo.hasOwnProperty('testServerApiPort')) {
    testServerApiPort = clientInfo.testServerApiPort;
  }
  if (clientInfo.hasOwnProperty('regionId')) {
    if(Array.isArray(clientInfo.regionId)) {
      regionId = clientInfo.regionId || __WEBPACK_IMPORTED_MODULE_8__Common_config___default.a.default_region;
    } else {
      running = false;
      setTimeout(diagnosisFailed, 1);
      return eventDispatcher;
    }
  }
  if (clientInfo.hasOwnProperty('forMobile') && clientInfo.forMobile === true) {
    forMobile = true;
  }
  if (clientInfo.hasOwnProperty('bitrateOnly') && clientInfo.bitrateOnly === true) {
    bitrateOnly = true;
  }
  if (clientInfo.hasOwnProperty('testDurationDataThroughput') && clientInfo.testDurationDataThroughput > 0) {
    testDurationDataThroughput = clientInfo.testDurationDataThroughput;
  }
  if(testDurationDataThroughput > MAX_BANDWIDTH_TEST_DURATION) {
    testDurationDataThroughput = MAX_BANDWIDTH_TEST_DURATION;
  }
  if (clientInfo.hasOwnProperty('testDurationVideoBandwidth') && clientInfo.testDurationVideoBandwidth > 0) {
    testDurationVideoBandwidth = clientInfo.testDurationVideoBandwidth;
  }
  if(testDurationVideoBandwidth > MAX_BANDWIDTH_TEST_DURATION) {
    testDurationVideoBandwidth = MAX_BANDWIDTH_TEST_DURATION;
  }
  if (clientInfo.hasOwnProperty('testDurationAudioBandwidth') && clientInfo.testDurationAudioBandwidth > 0) {
    testDurationAudioBandwidth = clientInfo.testDurationAudioBandwidth;
  }
  if(testDurationAudioBandwidth > MAX_BANDWIDTH_TEST_DURATION) {
    testDurationAudioBandwidth = MAX_BANDWIDTH_TEST_DURATION;
  }

  const testNames = clientInfo.testNames.map(function(item){ item = item.toString(); return item.toLowerCase(); })
  const testGroupSet = new Set();
  if(testNames.includes('all')) {
      testGroupSet.add(MICROPHONE);
      testGroupSet.add(CAMERA);
      testGroupSet.add(NETWORK);
      testGroupSet.add(CONNECTIVITY);
      testGroupSet.add(THROUGHPUT);
      testGroupSet.add(BANDWIDTH);
      testGroupSet.add(SIGNALLING);
  } else {
    for (const item in clientInfo.testNames) {
      testGroupSet.add(testNames[item]);
    }
  }
  for (const testName of testGroupSet) {
    switch (testName) {
      case MICROPHONE: {
        clientHealthMicrophone();
        break;
      }
      case CAMERA: {
        clientHealthCamera();
        break;
      }
      case NETWORK: {
        clientHealthNetwork();
        break;
      }
      case CONNECTIVITY: {
        clientHealthConnectivity();
        break;
      }
      case THROUGHPUT: {
        clientHealthThroughput();
        break;
      }
      case BANDWIDTH: {
        clientHealthBandwidth();
        break;
      }
      case SIGNALLING: {
        clientHealthSignalling();
        break;
      }
      default: {
        // do nothing
      }
    }
  }

  if(testCases.length > 0) {
    executeTestCases();
  } else {
    running = false;
    setTimeout(diagnosisFailed, 1);
    return eventDispatcher;
  }
  return eventDispatcher;
};

/* This API stops the execution of test cases */
function clientDiagnosticsStop() {
  if (running === false && testCases.length === 0) {
    clientDiagnosticsStopped();
  }
  running = false;
  return eventDisp;
};

function diagnosisFailed() {
  const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["a" /* ClientHealthEvent */])({ type: 'client-diagnosis-failed', message: {msg: 'Invalid arguments' }});
  if(forIosVersion13 === true) {
    window.webkit.messageHandlers.callbackHandler.postMessage(connectEvt);
  } else {
    eventDispatcher.dispatchEvent(connectEvt);
  }
  reset();
  __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].error('Invalid argument');
}

function clientDiagnosticsStopped() {
  const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["a" /* ClientHealthEvent */])({ type: 'client-diagnosis-stopped', message: {msg: 'Diagnosis stopped.' }});
  if(forIosVersion13 === true) {
    window.webkit.messageHandlers.callbackHandler.postMessage(connectEvt);
  } else {
    eventDispatcher.dispatchEvent(connectEvt);
  }
  reset();
  __WEBPACK_IMPORTED_MODULE_6__utils_Logger__["default"].error('diagnosis stopped');
};

clientHealth.clientBitrate = (regionInfo) => {
  let eventDispatcher_bitrate = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["c" /* EventDispatcher */])();
  let default_region = 'DE';
  if (regionInfo !== undefined && regionInfo.hasOwnProperty('region')) {
    let region = regionInfo.region;
    if(AVAILABLE_REGION.includes(region)) {
      default_region = region;
    }
  }
  let client = EnxRtc.clientDiagnostics({
    testNames: ['bandwidth'],
    regionId: [default_region],
    testDurationVideoBandwidth: BITRATE_VIDEO_TEST_DURATION,
    testDurationAudioBandwidth: BITRATE_AUDIO_TEST_DURATION,
    bitrateOnly: true,
    stop: false,
  });
  let bitrate_result_json = {
    video: {
      bitrate_bps: 'NA',
      connection: 'NA',
    },
    audio:
    {
      bitrate_bps: 'NA',
      connection: 'NA',
    }
  };
  client.addEventListener("client-diagnosis-status", function(event) {
    const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["a" /* ClientHealthEvent */])({ type: 'client-bitrate-status', message: event.message });
    if(event.message.hasOwnProperty('output')) {
      if(event.message.output.hasOwnProperty('video_bandwidth')) {
        if(event.message.output.video_bandwidth.hasOwnProperty('bandwidth_bps')) {
          bitrate_result_json.video.bitrate_bps = event.message.output.video_bandwidth.bandwidth_bps;
        }
        if(event.message.output.video_bandwidth.hasOwnProperty('packets_lost_percentage')) {
          bitrate_result_json.video.connection = (event.message.output.video_bandwidth.packets_lost_percentage) > 5 ? 'unstable': 'stable';
        }
      }
      if(event.message.output.hasOwnProperty('audio_bandwidth')) {
        if(event.message.output.audio_bandwidth.hasOwnProperty('bandwidth_bps')) {
          bitrate_result_json.audio.bitrate_bps = event.message.output.audio_bandwidth.bandwidth_bps;
        }
        if(event.message.output.audio_bandwidth.hasOwnProperty('packets_lost_percentage')) {
          bitrate_result_json.audio.connection = (event.message.output.audio_bandwidth.packets_lost_percentage) > 5 ? 'unstable': 'stable';
        }
      }
    }
    if(forIosVersion13 === true) {
      window.webkit.messageHandlers.callbackHandler.postMessage(connectEvt);
    } else {
      eventDispatcher_bitrate.dispatchEvent(connectEvt);
    }
  });
   client.addEventListener("client-diagnosis-finished", function(event) {
    const connectEvt = Object(__WEBPACK_IMPORTED_MODULE_7__Events__["a" /* ClientHealthEvent */])({ type: 'client-bitrate-finished', message: bitrate_result_json });
    if(forIosVersion13 === true) {
      window.webkit.messageHandlers.callbackHandler.postMessage(connectEvt);
    } else {
      eventDispatcher_bitrate.dispatchEvent(connectEvt);
    }
   });
  return eventDispatcher_bitrate;
};

/* harmony default export */ __webpack_exports__["a"] = (clientHealth);


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = testMicrophone;
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */


const util = __webpack_require__(13);

function testMicrophone(test, deviceId) {
  const mictest = new MicTest(test, deviceId);
  mictest.run();
}

// mictest.js
function MicTest(test, deviceId) {
    this.test = test;
    this.inputChannelCount = 6;
    this.outputChannelCount = 2;
    // Buffer size set to 0 to let Chrome choose based on the platform.
    this.bufferSize = 0;
    this.deviceId = deviceId;
    // Turning off echoCancellation constraint enables stereo input.
    this.constraints = {
      audio: {
        optional: [
          { echoCancellation: false },
        ],
      },
    };

    this.collectSeconds = 2.0;
    // At least one LSB 16-bit data (compare is on absolute value).
    this.silentThreshold = 1.0 / 32767;
    this.lowVolumeThreshold = -60;
    // Data must be identical within one LSB 16-bit to be identified as mono.
    this.monoDetectThreshold = 1.0 / 65536;
    // Number of consequtive clipThreshold level samples that indicate clipping.
    this.clipCountThreshold = 6;
    this.clipThreshold = 1.0;

    // Populated with audio as a 3-dimensional array:
    //   collectedAudio[channels][buffers][samples]
    this.collectedAudio = [];
    this.collectedSampleCount = 0;
    for (let i = 0; i < this.inputChannelCount; ++i) {
      this.collectedAudio[i] = [];
    }
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    this.audioContext = new AudioContext();
  }

  MicTest.prototype = {
    run() {
      // Resuming as per new spec after user interaction.
      this.audioContext.resume().then(() => {
        util.appendSourceId(this.deviceId, 'audio', this.constraints);
        util.doGetUserMedia(this.constraints, this.gotStream.bind(this), this.onFail.bind(this));
      })
      .catch((error) => {
        this.test.reportError(`WebAudio run failure: ${error}`);
        this.test.done();
      });
    },
    onFail(error) {
      this.test.reportError(`getUserMedia failed with error: ${error}`);
      this.test.done();
    },
    gotStream(stream) {
      if (!this.checkAudioTracks(stream)) {
        this.test.done();
        return;
      }
      this.createAudioBuffer(stream);
    },

    checkAudioTracks(stream) {
      this.stream = stream;
      const audioTracks = stream.getAudioTracks();
      if (audioTracks.length < 1) {
        this.test.reportError('No audio track in returned stream.');
        return false;
      }
      this.test.reportSuccess(`Audio track created using device=${
          audioTracks[0].label}`);
      return true;
    },

    createAudioBuffer() {
      this.audioSource = this.audioContext.createMediaStreamSource(this.stream);
      this.scriptNode = this.audioContext.createScriptProcessor(
        this.bufferSize,
        this.inputChannelCount, this.outputChannelCount,
      );
      this.audioSource.connect(this.scriptNode);
      this.scriptNode.connect(this.audioContext.destination);
      this.scriptNode.onaudioprocess = this.collectAudio.bind(this);
      this.stopCollectingAudio = util.setTimeoutWithProgressBar(this.onStopCollectingAudio.bind(this), 5000);
    },

    collectAudio(event) {
      // Simple silence detection: check first and last sample of each channel in
      // the buffer. If both are below a threshold, the buffer is considered
      // silent.
      const sampleCount = event.inputBuffer.length;
      let allSilent = true;
      for (let c = 0; c < event.inputBuffer.numberOfChannels; c++) {
        const data = event.inputBuffer.getChannelData(c);
        const first = Math.abs(data[0]);
        const last = Math.abs(data[sampleCount - 1]);
        var newBuffer;
        if (first > this.silentThreshold || last > this.silentThreshold) {
          // Non-silent buffers are copied for analysis. Note that the silent
          // detection will likely cause the stored stream to contain discontinu-
          // ities, but that is ok for our needs here (just looking at levels).
          newBuffer = new Float32Array(sampleCount);
          newBuffer.set(data);
          allSilent = false;
        } else {
          // Silent buffers are not copied, but we store empty buffers so that the
          // analysis doesn't have to care.
          newBuffer = new Float32Array();
        }
        this.collectedAudio[c].push(newBuffer);
      }
      if (!allSilent) {
        this.collectedSampleCount += sampleCount;
        if ((this.collectedSampleCount / event.inputBuffer.sampleRate) >=
            this.collectSeconds) {
          this.stopCollectingAudio();
        }
      }
    },

    onStopCollectingAudio() {
      this.stream.getAudioTracks()[0].stop();
      this.audioSource.disconnect(this.scriptNode);
      this.scriptNode.disconnect(this.audioContext.destination);
      this.analyzeAudio(this.collectedAudio);
      this.test.done();
    },

    analyzeAudio(channels) {
      const activeChannels = [];
      for (let c = 0; c < channels.length; c++) {
        if (this.channelStats(c, channels[c])) {
          activeChannels.push(c);
        }
      }
      if (activeChannels.length === 0) {
        this.test.reportError('No active input channels detected. Microphone ' +
            'is most likely muted or broken, please check if muted in the ' +
            'sound settings or physically on the device. Then rerun the test.');
      } else {
        this.test.reportSuccess(`Active audio input channels: ${
        activeChannels.length}`);
      }
      if (activeChannels.length === 2) {
        this.detectMono(channels[activeChannels[0]], channels[activeChannels[1]]);
      }
    },

    channelStats(channelNumber, buffers) {
      let maxPeak = 0.0;
      let maxRms = 0.0;
      let clipCount = 0;
      let maxClipCount = 0;
      for (let j = 0; j < buffers.length; j++) {
        const samples = buffers[j];
        if (samples.length > 0) {
          let s = 0;
          let rms = 0.0;
          for (let i = 0; i < samples.length; i++) {
            s = Math.abs(samples[i]);
            maxPeak = Math.max(maxPeak, s);
            rms += s * s;
            if (maxPeak >= this.clipThreshold) {
              clipCount += 1;
              maxClipCount = Math.max(maxClipCount, clipCount);
            } else {
              clipCount = 0;
            }
          }
          // RMS is calculated over each buffer, meaning the integration time will
          // be different depending on sample rate and buffer size. In practise
          // this should be a small problem.
          rms = Math.sqrt(rms / samples.length);
          maxRms = Math.max(maxRms, rms);
        }
      }

      if (maxPeak > this.silentThreshold) {
        const dBPeak = this.dBFS(maxPeak);
        const dBRms = this.dBFS(maxRms);
        this.test.reportInfo(`Channel ${channelNumber} levels: ${
            dBPeak.toFixed(1)} dB (peak), ${dBRms.toFixed(1)} dB (RMS)`);
        if (dBRms < this.lowVolumeThreshold) {
          this.test.reportError('Microphone input level is low, increase input ' +
              'volume or move closer to the microphone.');
        }
        if (maxClipCount > this.clipCountThreshold) {
          this.test.reportWarning('Clipping detected! Microphone input level ' +
              'is high. Decrease input volume or move away from the microphone.');
        }
        return true;
      }
      return false;
    },

    detectMono(buffersL, buffersR) {
      let diffSamples = 0;
      for (let j = 0; j < buffersL.length; j++) {
        const l = buffersL[j];
        const r = buffersR[j];
        if (l.length === r.length) {
          let d = 0.0;
          for (let i = 0; i < l.length; i++) {
            d = Math.abs(l[i] - r[i]);
            if (d > this.monoDetectThreshold) {
              diffSamples += 1;
            }
          }
        } else {
          diffSamples += 1;
        }
      }
      if (diffSamples > 0) {
        this.test.reportInfo('Stereo microphone detected.');
      } else {
        this.test.reportInfo('Mono microphone detected.');
      }
    },

    dBFS(gain) {
      //this.test.reportInfo( "dBFS" );
      const dB = 20 * (Math.log(gain) / Math.log(10));
      // Use Math.round to display up to one decimal place.
      return Math.round(dB * 10) / 10;
    },
  };


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = testCamera;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__videoframechecker__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__videoframechecker___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__videoframechecker__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__call__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__call___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__call__);
/* eslint-disable import/prefer-default-export */
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
//'use strict';



const util = __webpack_require__(13);


function CamResolutionsTest(test, resolutions, deviceId) {
  this.test = test;
  this.resolutions = resolutions;
  this.currentResolution = 0;
  this.isMuted = false;
  this.isShuttingDown = false;
  this.deviceId = deviceId;
}

CamResolutionsTest.prototype = {
  run() {
    this.startGetUserMedia(this.resolutions[this.currentResolution], this.deviceId);
    this.currentResolution += 1;
  },

  startGetUserMedia(resolution, devId) {
    const constraints = {
      audio: false,
      video: {
        width: { exact: resolution[0] },
        height: { exact: resolution[1] },
        deviceId: devId,
      },
    };
    //util.appendSourceId(devId, 'video', constraints);
    navigator.mediaDevices.getUserMedia(constraints)
        .then((stream) => {
          // Do not check actual video frames when more than one resolution is
          // provided.
          if (this.resolutions.length > 1) {
            this.test.reportSuccess(`Supported resolution: ${resolution[0]}x${
            resolution[1]}`);
            stream.getTracks().forEach((track) => {
              track.stop();
            });
            this.maybeContinueGetUserMedia();
          } else {
            this.collectAndAnalyzeStats(stream, resolution);
          }
        })
        .catch((error) => {
          // if (error.name === "OverconstrainedError")
          // this.test.reportInfo('Resolution selected is not supported by your webcam');
          // else
          if (this.resolutions.length > 1) {
            this.test.reportInfo(`${resolution[0]}x${resolution[1]
            } not supported`);
          } else {
            this.test.reportError(`getUserMedia failed with error: ${
                error.name}`);
          }
          this.maybeContinueGetUserMedia();
        });
  },

  maybeContinueGetUserMedia() {
    if (this.currentResolution === this.resolutions.length) {
      this.test.done();
      return;
    }
    this.startGetUserMedia(this.resolutions[this.currentResolution]);
    this.currentResolution += 1;
  },

  collectAndAnalyzeStats(stream, resolution) {
    const tracks = stream.getVideoTracks();
    if (tracks.length < 1) {
      this.test.reportError('No video track in returned stream.');
      this.maybeContinueGetUserMedia();
      return;
    }

    // Firefox does not support event handlers on mediaStreamTrack yet.
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack
    // TODO: remove if (...) when event handlers are supported by Firefox.
    const videoTrack = tracks[0];
    if (typeof videoTrack.addEventListener === 'function') {
      // Register events.
      videoTrack.addEventListener('ended', () => {
        // Ignore events when shutting down the test.
        if (this.isShuttingDown) {
          return;
        }
        this.test.reportError('Video track ended, camera stopped working');
      });
      videoTrack.addEventListener('mute', () => {
        // Ignore events when shutting down the test.
        if (this.isShuttingDown) {
          return;
        }
        this.test.reportWarning('Your camera reported itself as muted.');
        // MediaStreamTrack.muted property is not wired up in Chrome yet,
        // checking isMuted local state.
        this.isMuted = true;
      });
      videoTrack.addEventListener('unmute', () => {
        // Ignore events when shutting down the test.
        if (this.isShuttingDown) {
          return;
        }
        this.test.reportInfo('Your camera reported itself as unmuted.');
        this.isMuted = false;
      });
    }

    const video = document.createElement('video');
    video.setAttribute('autoplay', '');
    video.setAttribute('muted', '');
    video.width = resolution[0];
    video.height = resolution[1];
    video.srcObject = stream;
    const frameChecker = new __WEBPACK_IMPORTED_MODULE_0__videoframechecker___default.a(video);
    const call = new __WEBPACK_IMPORTED_MODULE_1__call___default.a(null, this.test);
    call.pc1.addStream(stream);
    call.establishConnection();
    call.gatherStats(
      call.pc1, null, stream,
      this.onCallEnded.bind(
        this, resolution, video,
        stream, frameChecker,
      ),
      100,
    );

    util.setTimeoutWithProgressBar(this.endCall.bind(this, call, stream), 8000);
  },

  onCallEnded(
    resolution, videoElement, stream, frameChecker,
    stats, statsTime,
  ) {
    this.analyzeStats(
      resolution, videoElement, stream, frameChecker,
      stats, statsTime,
    );

    frameChecker.stop();
    this.test.done();
  },

  analyzeStats(
    resolution, videoElement, stream,
    frameChecker, stats, statsTime,
  ) {
    const googAvgEncodeTime = [];
    const googAvgFrameRateInput = [];
    const googAvgFrameRateSent = [];
    const statsReport = {};
    const frameStats = frameChecker.frameStats;

    for (const index in stats) {
      if (stats[index].type === 'ssrc') {
        // Make sure to only capture stats after the encoder is setup.
        if (parseInt(stats[index].googFrameRateInput) > 0) {
          googAvgEncodeTime.push(parseInt(stats[index].googAvgEncodeMs));
          googAvgFrameRateInput.push(parseInt(stats[index].googFrameRateInput));
          googAvgFrameRateSent.push(parseInt(stats[index].googFrameRateSent));
        }
      }
    }

    statsReport.cameraName = stream.getVideoTracks()[0].label || NaN;
    statsReport.actualVideoWidth = videoElement.videoWidth;
    statsReport.actualVideoHeight = videoElement.videoHeight;
    statsReport.mandatoryWidth = resolution[0];
    statsReport.mandatoryHeight = resolution[1];
    statsReport.encodeSetupTimeMs = this.extractEncoderSetupTime(stats, statsTime);
    statsReport.avgEncodeTimeMs = util.arrayAverage(googAvgEncodeTime);
    statsReport.minEncodeTimeMs = util.arrayMin(googAvgEncodeTime);
    statsReport.maxEncodeTimeMs = util.arrayMax(googAvgEncodeTime);
    statsReport.avgInputFps = util.arrayAverage(googAvgFrameRateInput);
    statsReport.minInputFps = util.arrayMin(googAvgFrameRateInput);
    statsReport.maxInputFps = util.arrayMax(googAvgFrameRateInput);
    statsReport.avgSentFps = util.arrayAverage(googAvgFrameRateSent);
    statsReport.minSentFps = util.arrayMin(googAvgFrameRateSent);
    statsReport.maxSentFps = util.arrayMax(googAvgFrameRateSent);
    statsReport.isMuted = this.isMuted;
    statsReport.testedFrames = frameStats.numFrames;
    statsReport.blackFrames = frameStats.numBlackFrames;
    statsReport.frozenFrames = frameStats.numFrozenFrames;

    // TODO: Add a reportInfo() function with a table format to display
    // values clearer.
    //report.traceEventInstant('video-stats', statsReport);

    this.testExpectations(statsReport);
  },

  endCall(callObject, stream) {
    this.isShuttingDown = true;
    stream.getTracks().forEach((track) => {
      track.stop();
    });
    callObject.close();
  },

  extractEncoderSetupTime(stats, statsTime) {
    for (let index = 0; index !== stats.length; index++) {
      if (stats[index].type === 'ssrc') {
        if (parseInt(stats[index].googFrameRateInput) > 0) {
          return JSON.stringify(statsTime[index] - statsTime[0]);
        }
      }
    }
    return NaN;
  },

  resolutionMatchesIndependentOfRotationOrCrop(
aWidth, aHeight,
    bWidth, bHeight,
) {
    const minRes = Math.min(bWidth, bHeight);
    return (aWidth === bWidth && aHeight === bHeight) ||
            (aWidth === bHeight && aHeight === bWidth) ||
            (aWidth === minRes && bHeight === minRes);
  },

  testExpectations(info) {
    const notAvailableStats = [];
    for (const key in info) {
      if (info.hasOwnProperty(key)) {
        if (typeof info[key] === 'number' && isNaN(info[key])) {
          notAvailableStats.push(key);
        } else {
          this.test.reportInfo(`${key}: ${info[key]}`);
        }
      }
    }
    if (notAvailableStats.length !== 0) {
      this.test.reportInfo(`Not available: ${notAvailableStats.join(', ')}`);
    }

    if (isNaN(info.avgSentFps)) {
      this.test.reportInfo('Cannot verify sent FPS.');
    } else if (info.avgSentFps < 5) {
      this.test.reportError(`Low average sent FPS: ${info.avgSentFps}`);
    } else {
      this.test.reportSuccess('Average FPS above threshold');
    }
    if (!this.resolutionMatchesIndependentOfRotationOrCrop(
        info.actualVideoWidth, info.actualVideoHeight, info.mandatoryWidth,
        info.mandatoryHeight,
  )) {
          this.test.reportError('Incorrect captured resolution.');
    } else {
      this.test.reportSuccess('Captured video using expected resolution.');
    }
    if (info.testedFrames === 0) {
      this.test.reportError('Could not analyze any video frame.');
    } else {
      if (info.blackFrames > info.testedFrames / 3) {
        this.test.reportError('Camera delivering lots of black frames.');
      }
      if (info.frozenFrames > info.testedFrames / 3) {
        this.test.reportError('Camera delivering lots of frozen frames.');
      }
    }
  },
};

function testCamera(test, deviceId) {
  switch (test.test_title) {
    case 'check_resolution_240': {
      const camera = new CamResolutionsTest(test, [[320, 240]], deviceId);
      camera.run();

      break;
    }
    case 'check_resolution_480': {
      const camera = new CamResolutionsTest(test, [[640, 480]], deviceId);
      camera.run();
      break;
    }
    case 'check_resolution_720': {
      const camera = new CamResolutionsTest(test, [[1280, 720]], deviceId);
      camera.run();
      break;
    }
    case 'check_supported_resolutions': {
      const resolutionArray = [
        [160, 120], [320, 180], [320, 240], [640, 360], [640, 480], [768, 576],
        [1024, 576], [1280, 720], [1280, 768], [1280, 800], [1920, 1080],
        [1920, 1200], [3840, 2160], [4096, 2160],
      ];
      const camResolutionsTest = new CamResolutionsTest(test, resolutionArray, deviceId);
      camResolutionsTest.run();
     break;
    }
    default:
      break;
  }
}


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */


function VideoFrameChecker(videoElement) {
  this.frameStats = {
    numFrozenFrames: 0,
    numBlackFrames: 0,
    numFrames: 0,
  };

  this.running_ = true;

  this.nonBlackPixelLumaThreshold = 20;
  this.previousFrame_ = [];
  this.identicalFrameSsimThreshold = 0.985;
  this.frameComparator = new Ssim();
  this.canvas_ = document.createElement('canvas');
  this.videoElement_ = videoElement;
  this.listener_ = this.checkVideoFrame_.bind(this);
  this.videoElement_.addEventListener('play', this.listener_, false);
}

VideoFrameChecker.prototype = {
  stop() {
    this.videoElement_.removeEventListener('play', this.listener_);
    this.running_ = false;
  },

  getCurrentImageData_() {
    this.canvas_.width = this.videoElement_.width;
    this.canvas_.height = this.videoElement_.height;

    const context = this.canvas_.getContext('2d');
    context.drawImage(
this.videoElement_, 0, 0, this.canvas_.width,
        this.canvas_.height,
);
    return context.getImageData(0, 0, this.canvas_.width, this.canvas_.height);
  },

  checkVideoFrame_() {
    if (!this.running_) {
      return;
    }
    if (this.videoElement_.ended) {
      return;
    }

    const imageData = this.getCurrentImageData_();

    if (this.isBlackFrame_(imageData.data, imageData.data.length)) {
      this.frameStats.numBlackFrames += 1;
    }

    if (this.frameComparator.calculate(this.previousFrame_, imageData.data) >
        this.identicalFrameSsimThreshold) {
      this.frameStats.numFrozenFrames += 1;
    }
    this.previousFrame_ = imageData.data;

    this.frameStats.numFrames += 1;
    setTimeout(this.checkVideoFrame_.bind(this), 20);
  },

  isBlackFrame_(data, length) {
    // TODO: Use a statistical, histogram-based detection.
    const thresh = this.nonBlackPixelLumaThreshold;
    let accuLuma = 0;
    for (let i = 4; i < length; i += 4) {
      // Use Luma as in Rec. 709: Y709 = 0.21R + 0.72G + 0.07B;
      accuLuma += 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
      // Early termination if the average Luma so far is bright enough.
      if (accuLuma > (thresh * i / 4)) {
        return false;
      }
    }
    return true;
  },
};

function Ssim() {}

Ssim.prototype = {
  // Implementation of Eq.2, a simple average of a vector and Eq.4., except the
  // square root. The latter is actually an unbiased estimate of the variance,
  // not the exact variance.
  statistics(a) {
    let accu = 0;
    let i;
    for (i = 0; i < a.length; ++i) {
      accu += a[i];
    }
    const meanA = accu / (a.length - 1);
    let diff = 0;
    for (i = 1; i < a.length; ++i) {
      diff = a[i - 1] - meanA;
      accu += a[i] + (diff * diff);
    }
    return { mean: meanA, variance: accu / a.length };
  },

  // Implementation of Eq.11., cov(Y, Z) = E((Y - uY), (Z - uZ)).
  covariance(a, b, meanA, meanB) {
    let accu = 0;
    for (let i = 0; i < a.length; i += 1) {
      accu += (a[i] - meanA) * (b[i] - meanB);
    }
    return accu / a.length;
  },

  calculate(x, y) {
    if (x.length !== y.length) {
      return 0;
    }

    // Values of the constants come from the Matlab code referred before.
    const K1 = 0.01;
    const K2 = 0.03;
    const L = 255;
    const C1 = (K1 * L) * (K1 * L);
    const C2 = (K2 * L) * (K2 * L);
    const C3 = C2 / 2;

    const statsX = this.statistics(x);
    const muX = statsX.mean;
    const sigmaX2 = statsX.variance;
    const sigmaX = Math.sqrt(sigmaX2);
    const statsY = this.statistics(y);
    const muY = statsY.mean;
    const sigmaY2 = statsY.variance;
    const sigmaY = Math.sqrt(sigmaY2);
    const sigmaXy = this.covariance(x, y, muX, muY);

    // Implementation of Eq.6.
    const luminance = (2 * muX * muY + C1) /
        ((muX * muX) + (muY * muY) + C1);
    // Implementation of Eq.10.
    const structure = (sigmaXy + C3) / (sigmaX * sigmaY + C3);
    // Implementation of Eq.9.
    const contrast = (2 * sigmaX * sigmaY + C2) / (sigmaX2 + sigmaY2 + C2);

    // Implementation of Eq.12.
    return luminance * contrast * structure;
  },
};

if (true) {
  module.exports = VideoFrameChecker;
}


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = testNetwork;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__call__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__call___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__call__);
/* eslint-disable default-case */
/* eslint-disable import/prefer-default-export */
/*
 *  Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */




function NetworkTest(test, protocol, params, iceCandidateFilter) {
  this.test = test;
  this.protocol = protocol;
  this.params = params;
  this.iceCandidateFilter = iceCandidateFilter;
}

NetworkTest.prototype = {
  run() {
    // Do not create turn config for IPV6 test.
    if (this.iceCandidateFilter.toString() === __WEBPACK_IMPORTED_MODULE_0__call___default.a.isIpv6.toString()) {
      this.gatherCandidates(null, this.params, this.iceCandidateFilter);
    } else if (this.test.server === 'TURN') {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateTurnConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    } else {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateStunConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    }
  },

  start(config) {
    this.filterConfig(config, this.protocol);
    this.gatherCandidates(config, this.params, this.iceCandidateFilter);
  },

  // Filter the RTCConfiguration |config| to only contain URLs with the
  // specified transport protocol |protocol|. If no turn transport is
  // specified it is added with the requested protocol.
  filterConfig(config, protocol) {
    const newIceServers = [];
    const iceServer = config.iceServers[0];
    const new_urls = [];
    const transport = `transport=${protocol}`;
    const uri = (iceServer.urls.startsWith('turns')) ? `${iceServer.urls}?${transport}` : iceServer.urls;
    new_urls.push(uri);
    iceServer.urls = new_urls;
    newIceServers.push(iceServer);
    config.iceServers = newIceServers;
  },

  // Create a PeerConnection, and gather candidates using RTCConfig |config|
  // and ctor params |params|. Succeed if any candidates pass the |isGood|
  // check, fail if we complete gathering without any passing.
  gatherCandidates(config, params, isGood) {
    let pc;
    try {
      pc = new RTCPeerConnection(config, params);
    } catch (error) {
      if (params !== null && params.optional[0].googIPv6) {
        this.test.reportError('Failed to create peer connection, IPv6 ' +
            'might not be setup/supported on the network.');
      } else {
        this.test.reportError(`Failed to create peer connection: ${error}`);
      }
      this.test.done();
      return;
    }

    // In our candidate callback, stop if we get a candidate that passes
    // |isGood|.
    pc.addEventListener('icecandidate', (e) => {
      // Once we've decided, ignore future callbacks.
      if (e.currentTarget.signalingState === 'closed') {
        return;
      }

      if (e.candidate) {
        const parsed = __WEBPACK_IMPORTED_MODULE_0__call___default.a.parseCandidate(e.candidate.candidate);
        if (isGood(parsed)) {
          this.test.reportSuccess(`Gathered candidate of Type: ${parsed.type
              } Protocol: ${parsed.protocol} Address: ${parsed.address}`);
          pc.close();
          pc = null;
          this.test.done();
        }
      } else {
        pc.close();
        pc = null;
        if (params !== null && params.optional[0].googIPv6) {
          this.test.reportError('Failed to gather IPv6 candidates, it ' +
              'might not be setup/supported on the network.');
        } else {
          this.test.reportError('Failed to gather specified candidates');
        }
        this.test.done();
      }
    });

    this.createAudioOnlyReceiveOffer(pc);
  },

  // Create an audio-only, recvonly offer, and setLD with it.
  // This will trigger candidate gathering.
  createAudioOnlyReceiveOffer(pc) {
    const createOfferParams = { offerToReceiveAudio: 1 };
    pc.createOffer(createOfferParams).then(
        (offer) => {
          pc.setLocalDescription(offer).then(
              noop,
              noop,
          );
        },
        noop,
    );

    // Empty function for callbacks requiring a function.
    function noop() {}
  },
};

function testNetwork(test) {
  //this.region = 'IN';
  //this.server = 'TURN';
  switch (test.test_title) {
    case 'udp_enabled':
    {
      // Test whether it can connect via UDP to a TURN server
      // Get a TURN config, and try to get a relay candidate using UDP.
      const networkTest = new NetworkTest(test, 'udp', null, __WEBPACK_IMPORTED_MODULE_0__call___default.a.isRelay);
      networkTest.run();
      break;
    }
    case 'tcp_enabled':
    {
      // Test whether it can connect via TCP to a TURN server
      // Get a TURN config, and try to get a relay candidate using TCP.
      const networkTest = new NetworkTest(test, 'tcp', null, __WEBPACK_IMPORTED_MODULE_0__call___default.a.isRelay);
      networkTest.run();
      break;
    }
    case 'ipv6_enabled':
    {
      // Test whether it is IPv6 enabled (TODO: test IPv6 to a destination).
      // Turn on IPv6, and try to get an IPv6 host candidate.
      const params = { optional: [{ googIPv6: true }] };
      const networkTest = new NetworkTest(test, null, params, __WEBPACK_IMPORTED_MODULE_0__call___default.a.isIpv6);
      networkTest.run();
      break;
    }
  }
}



/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = testConnectivity;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__call__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__call___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__call__);
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */




function testConnectivity(test) {
  switch (test.test_title) {
    case 'relay_connectivity':
    {
      // Set up a datachannel between two peers through a relay
      // and verify data can be transmitted and received
      // (packets travel through the public internet)
      const runConnectivityTest = new RunConnectivityTest(test, __WEBPACK_IMPORTED_MODULE_0__call___default.a.isRelay);
      runConnectivityTest.run();
      break;
    }
    case 'reflexive_connectivity':
        {
      // Set up a datachannel between two peers through a public IP address
      // and verify data can be transmitted and received
      // (packets should stay on the link if behind a router doing NAT)
      const runConnectivityTest = new RunConnectivityTest(test, __WEBPACK_IMPORTED_MODULE_0__call___default.a.isReflexive);
      runConnectivityTest.run();
      break;
    }
    case 'host_connectivity':
    {
      // Set up a datachannel between two peers through a local IP address
      // and verify data can be transmitted and received
      // (packets should not leave the machine running the test)
      const runConnectivityTest = new RunConnectivityTest(test, __WEBPACK_IMPORTED_MODULE_0__call___default.a.isHost);
      runConnectivityTest.start();
      break;
    }
  }
}
function RunConnectivityTest(test, iceCandidateFilter) {
  this.test = test;
  this.iceCandidateFilter = iceCandidateFilter;
  this.timeout = null;
  this.parsedCandidates = [];
  this.call = null;
}

RunConnectivityTest.prototype = {
  run() {
    if (this.test.server === 'TURN') {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateTurnConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    } else {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateStunConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    }
  },

  start(config) {
    //this.filterConfig(config);
    this.call = new __WEBPACK_IMPORTED_MODULE_0__call___default.a(config, this.test);
    this.call.setIceCandidateFilter(this.iceCandidateFilter);

    // Collect all candidates for validation.
    this.call.pc1.addEventListener('icecandidate', (event) => {
      if (event.candidate) {
        const parsedCandidate = __WEBPACK_IMPORTED_MODULE_0__call___default.a.parseCandidate(event.candidate.candidate);
        this.parsedCandidates.push(parsedCandidate);

        // Report candidate info based on iceCandidateFilter.
        if (this.iceCandidateFilter(parsedCandidate)) {
          this.test.reportInfo(`Gathered candidate of Type: ${parsedCandidate.type
            } Protocol: ${parsedCandidate.protocol
            } Address: ${parsedCandidate.address}`);
        }
      }
    });
    const ch1 = this.call.pc1.createDataChannel(null);
    ch1.addEventListener('open', () => {
      ch1.send('hello');
    });
    ch1.addEventListener('message', (event) => {
      if (event.data !== 'world') {
        this.test.reportError('Invalid data transmitted.');
      } else {
        this.test.reportSuccess('Data successfully transmitted between peers.');
      }
      this.hangup();
    });
    this.call.pc2.addEventListener('datachannel', (event) => {
      const ch2 = event.channel;
      ch2.addEventListener('message', (event) => {
        if (event.data !== 'hello') {
          this.hangup('Invalid data transmitted.');
        } else {
          ch2.send('world');
        }
      });
    });
    this.call.establishConnection();
    this.timeout = setTimeout(this.hangup.bind(this, 'Timed out'), 5000);
  },

  filterConfig(config) {
    const newIceServers = [];
    const iceServer = config.iceServers[0];
    const new_urls = [];
    const transport = 'transport=tcp';
    const uri = (iceServer.urls.startsWith('turns')) ? `${iceServer.urls}?${transport}` : iceServer.urls;
    new_urls.push(uri);
    iceServer.urls = new_urls;
    newIceServers.push(iceServer);
    config.iceServers = newIceServers;
  },

  findParsedCandidateOfSpecifiedType(candidateTypeMethod) {
    for (const candidate in this.parsedCandidates) {
      if (candidateTypeMethod(this.parsedCandidates[candidate])) {
        return candidateTypeMethod(this.parsedCandidates[candidate]);
      }
    }
  },

  hangup(errorMessage) {
    if (errorMessage) {
      // Report warning for server reflexive test if it times out.
      if (errorMessage === 'Timed out' &&
          this.iceCandidateFilter.toString() === __WEBPACK_IMPORTED_MODULE_0__call___default.a.isReflexive.toString() &&
          this.findParsedCandidateOfSpecifiedType(__WEBPACK_IMPORTED_MODULE_0__call___default.a.isReflexive)) {
        this.test.reportWarning('Could not connect using reflexive ' +
            'candidates, likely due to the network environment/configuration.');
      } else {
        this.test.reportError(errorMessage);
      }
    }
    clearTimeout(this.timeout);
    this.call.close();
    this.test.done();
  },
};


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = testThroughPut;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__call__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__call___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__call__);
/* eslint-disable default-case */
/* eslint-disable import/prefer-default-export */
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */




const util = __webpack_require__(13);

const PACKET_LOST_RANGE = [2, 6];
const RTT_RANGE = [200, 500];
const BANDWIDTH_RANGE_VIDEO = [200, 500];
const BANDWIDTH_RANGE_AUDIO = [10, 30];
const INCOMING_VIDEO_COUNT_BANDWIDTH_RANGE= [250, 500, 800];
const JITTER_RANGE = [0, 30];

const GOOD = 'good';
const MODERATE = 'moderate';
const POOR = 'poor';

function DataChannelThroughputTest(test, testDuration) {
  this.test = test;
  this.testDurationSeconds = testDuration * 1.0;
  this.startTime = null;
  this.sentPayloadBytes = 0;
  this.receivedPayloadBytes = 0;
  this.stopSending = false;
  this.samplePacket = '';

  for (let i = 0; i !== 1024; ++i) {
    this.samplePacket += 'h';
  }

  this.maxNumberOfPacketsToSend = 1;
  this.bytesToKeepBuffered = 1024 * this.maxNumberOfPacketsToSend;
  this.lastBitrateMeasureTime = null;
  this.lastReceivedPayloadBytes = 0;

  this.call = null;
  this.senderChannel = null;
  this.receiveChannel = null;
}

DataChannelThroughputTest.prototype = {
  run() {
    if (this.test.server === 'TURN') {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateTurnConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    } else {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateStunConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    }
  },

  start(config) {
    this.call = new __WEBPACK_IMPORTED_MODULE_0__call___default.a(config, this.test);
    this.call.setIceCandidateFilter(__WEBPACK_IMPORTED_MODULE_0__call___default.a.isRelay);
    this.senderChannel = this.call.pc1.createDataChannel(null);
    this.senderChannel.addEventListener('open', this.sendingStep.bind(this));

    this.call.pc2.addEventListener(
      'datachannel',
      this.onReceiverChannel.bind(this),
    );

    this.call.establishConnection();
    this.timeout = setTimeout(this.hangup.bind(this, 'Timed out'), 30000); //patch
  },
   hangup(errorMessage) {
    //patch
    if (errorMessage) {
      if (errorMessage === 'Timed out') {
        this.test.reportError('maximum timeout');
      } else {
        this.test.reportError(errorMessage);
      }
    }
    clearTimeout(this.timeout);
    this.call.close();
    this.test.done();
  },
  onReceiverChannel(event) {
    this.receiveChannel = event.channel;
    this.receiveChannel.addEventListener(
      'message',
      this.onMessageReceived.bind(this),
    );
  },

  sendingStep() {
    clearTimeout(this.timeout); //patch
    const now = new Date();
    if (!this.startTime) {
      this.startTime = now;
      this.lastBitrateMeasureTime = now;
    }

    for (let i = 0; i !== this.maxNumberOfPacketsToSend; ++i) {
      if (this.senderChannel.bufferedAmount >= this.bytesToKeepBuffered) {
        break;
      }
      this.sentPayloadBytes += this.samplePacket.length;
      this.senderChannel.send(this.samplePacket);
    }

    if (now - this.startTime >= 1000 * this.testDurationSeconds) {
      this.test.setProgress(100);
      this.stopSending = true;
    } else {
      this.test.setProgress((now - this.startTime) /
          (10 * this.testDurationSeconds));
      setTimeout(this.sendingStep.bind(this), 1);
    }
  },

  onMessageReceived(event) {
    this.receivedPayloadBytes += event.data.length;
    const now = new Date();
    if (now - this.lastBitrateMeasureTime >= 1000) {
      let bitrate = (this.receivedPayloadBytes -
          this.lastReceivedPayloadBytes) / (now - this.lastBitrateMeasureTime);
      bitrate = Math.round(bitrate * 1000 * 8) / 1000;
      this.test.reportSuccess(`Transmitting at ${bitrate} kbps.`);
      this.lastReceivedPayloadBytes = this.receivedPayloadBytes;
      this.lastBitrateMeasureTime = now;
    }
    if (this.stopSending &&
        this.sentPayloadBytes === this.receivedPayloadBytes) {
      this.call.close();
      this.call = null;

      const elapsedTime = Math.round((now - this.startTime) * 10) / 10000.0;
      const receivedKBits = (this.receivedPayloadBytes * 8) / 1000;
      this.test.reportSuccess(`Total transmitted: ${receivedKBits
          } kilo-bits in ${elapsedTime} seconds.`);
      this.test.done();
    }
  },
};

function VideoBandwidthTest(test, deviceId, testDuration) {
  this.test = test;
  this.maxVideoBitrateKbps = 2000;
  this.durationMs = testDuration  * 1000;
  this.statStepMs = 100;
  this.bweStats = new util.StatisticsAggregate(0.75 * this.maxVideoBitrateKbps *
      1000);
  this.rttStats = new util.StatisticsAggregate();
  this.packetsLost = -1;
  this.nackCount = -1;
  this.pliCount = -1;
  this.qpSum = -1;
  this.packetsSent = 0;
  this.packetsReceived = 0;
  this.framesEncoded = -1;
  this.framesDecoded = -1;
  this.videoBytesSent = -1;
  this.videoBytesRecieved = -1;
  this.framesSent = -1;
  this.bitrateMean = -1;
  this.videoStats = [];
  this.startTime = null;
  this.call = null;
  this.deviceId = deviceId;
  this.bytesSent = 0;
  this.constraints = {
    audio: false,
    video: {
      optional: [
        { minWidth: 320 },
        { minHeight: 240 },
      ],
    },
  };
}

VideoBandwidthTest.prototype = {
  run() {
    if (this.test.server === 'TURN') {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateTurnConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    } else {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateStunConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    }
  },

  start(config) {
    this.call = new __WEBPACK_IMPORTED_MODULE_0__call___default.a(config, this.test);
    this.call.setIceCandidateFilter(__WEBPACK_IMPORTED_MODULE_0__call___default.a.isRelay);
    // FEC makes it hard to study bandwidth estimation since there seems to be
    // a spike when it is enabled and disabled. Disable it for now. FEC issue
    // tracked on: https://code.google.com/p/webrtc/issues/detail?id=3050
    this.call.disableVideoFec();
    this.call.constrainVideoBitrate(this.maxVideoBitrateKbps);
    util.appendSourceId(this.deviceId, 'video', this.constraints);
    util.doGetUserMedia(this.constraints, this.gotStream.bind(this), this.onFail.bind(this));
  },

  onFail(error) {
    this.test.reportError(`getUserMedia failed with error: ${error}`);
    this.test.done();
  },

  gotStream(stream) {
    this.call.pc1.addStream(stream);
    this.call.establishConnection();
    this.startTime = new Date();
    this.localStream = stream.getVideoTracks()[0];
    setTimeout(this.gatherStats.bind(this), this.statStepMs);
  },

  gatherStats() {
    const now = new Date();
    if (now - this.startTime > this.durationMs) {
      this.test.setProgress(100);
      this.hangup();
      return;
    } else if (!this.call.statsGatheringRunning) {
      this.call.gatherStats(
        this.call.pc1, this.call.pc2, this.localStream,
        this.gotStats.bind(this),
      );
    }
    this.test.setProgress((now - this.startTime) * 100 / this.durationMs);
    setTimeout(this.gatherStats.bind(this), this.statStepMs);
  },

  gotStats(response, time, response2, time2) {
    // TODO: Remove browser specific stats gathering hack once adapter.js or
    // browsers converge on a standard.
    if (adapter.browserDetails.browser === 'chrome') {
      for (const i in response) {
        if (typeof response[i].connection !== 'undefined') {
          this.bweStats.add(
            response[i].connection.timestamp,
            parseInt(response[i].connection.availableOutgoingBitrate),
          );
          this.rttStats.add(
            response[i].connection.timestamp,
            parseInt(response[i].connection.currentRoundTripTime * 1000),
          );
          // Grab the last stats.
          this.videoStats[0] = response[i].video.local.frameWidth;
          this.videoStats[1] = response[i].video.local.frameHeight;
          this.nackCount = response[i].video.local.nackCount;
          this.packetsLost = response2[i].video.remote.packetsLost;
          this.qpSum = response2[i].video.remote.qpSum;
          this.pliCount = response[i].video.local.pliCount;
          this.packetsSent = response[i].video.local.packetsSent;
          this.packetsReceived = response2[i].video.remote.packetsReceived;
          this.framesEncoded = response[i].video.local.framesEncoded;
          this.videoBytesSent = response[i].video.local.bytesSent;
          this.videoBytesRecieved = response2[i].video.remote.bytesReceived;
          this.framesDecoded = response2[i].video.remote.framesDecoded;
        }
      }
    } else if (adapter.browserDetails.browser === 'firefox') {
      for (const j in response) {
        let rtt = response[j].video.remote.roundTripTime * 1000;
        if(rtt) {
          this.rttStats.add(
          response[j].video.remote.timestamp,
          parseInt(rtt),
          );
        }
        this.bytesSent += response[j].connection.bytesSent;
        this.packetsSent = response[j].video.local.packetsSent;
        this.packetsLost = response2[j].video.remote.packetsLost;
        this.packetsReceived = response2[j].video.remote.packetsReceived;
        this.qpSum = response2[j].video.remote.qpSum;
        this.bitrateMean = response[j].video.local.bitrateMean;
        this.videoBytesSent = response[j].video.local.bytesSent;
        this.videoBytesRecieved = response2[j].video.remote.bytesReceived;
      }
    } else {
      this.test.reportError('Only Firefox and Chrome getStats implementations' +
        ' are supported.');
    }
    this.completed();
  },

  hangup() {
    this.call.pc1.getLocalStreams()[0].getTracks().forEach((track) => {
      track.stop();
    });
    this.call.close();
    this.call = null;
  },

  completed() {
    // TODO: Remove browser specific stats gathering hack once adapter.js or
    // browsers converge on a standard.
    if (adapter.browserDetails.browser === 'chrome') {
      const now = new Date();
      const durationS = (now - this.startTime) / 1000;
      // Checking if greater than 2 because Chrome sometimes reports 2x2 when
      // a camera starts but fails to deliver frames.
      if (this.videoStats[0] < 2 && this.videoStats[1] < 2) {
        this.test.reportError(`Camera failure: ${this.videoStats[0]}x${
            this.videoStats[1]}. Cannot test bandwidth without a working ` +
            ' camera.');
      } else {
        this.test.reportSuccess(`Video resolution: ${this.videoStats[0]
            }x${this.videoStats[1]}`);
        let sendBWEstimateAvg = Math.round(this.bweStats.getAverage() / 1000);
        let sendBWEstimateAvgState = null;
        if (sendBWEstimateAvg < BANDWIDTH_RANGE_VIDEO[0]) {
          sendBWEstimateAvgState = POOR;
        } else if (sendBWEstimateAvg < BANDWIDTH_RANGE_VIDEO[1]) {
          sendBWEstimateAvgState = MODERATE;
        } else {
          sendBWEstimateAvgState = GOOD;
        }
        let possible_no_incoming_videos = 0;
        if(sendBWEstimateAvg < INCOMING_VIDEO_COUNT_BANDWIDTH_RANGE[0]) {
          possible_no_incoming_videos = 1;
        } else if(sendBWEstimateAvg < INCOMING_VIDEO_COUNT_BANDWIDTH_RANGE[1]) {
          possible_no_incoming_videos = 2;
        } else if(sendBWEstimateAvg < INCOMING_VIDEO_COUNT_BANDWIDTH_RANGE[2]) {
          possible_no_incoming_videos = 4;
        } else {
          possible_no_incoming_videos = 5;
        }
        this.test.reportByState(`Average Video bandwidth (Send): ${sendBWEstimateAvg} kbps`, sendBWEstimateAvgState);
        if(true === this.test.bitrate_only) {
          this.test.fillBandwidth(this.bweStats.getAverage());
        }

        if(false === this.test.bitrate_only) {
          this.test.reportInfo(`Recommended no. of incoming videos :${possible_no_incoming_videos}`);
          this.test.reportInfo(`Send bandwidth estimate max: ${
              this.bweStats.getMax() / 1000} kbps`);
          this.test.reportInfo(`Send bandwidth ramp-up time: ${
              this.bweStats.getRampUpTime()} ms`);
          this.test.reportInfo(`Packets sent: ${this.packetsSent}`);
          this.test.reportInfo(`Packets received: ${this.packetsReceived}`);
          this.test.reportInfo(`NACK count: ${this.nackCount}`);
          this.test.reportInfo(`Picture loss indications: ${this.pliCount}`);
          this.test.reportInfo(`Quality predictor sum: ${this.qpSum}`);
          this.test.reportInfo(`Frames encoded: ${this.framesEncoded}`);
          this.test.reportInfo(`Frames decoded: ${this.framesDecoded}`);
        }
        let pktLoss = null;
        let pktLostPercentage = null;
        if(this.packetsSent > 0) {
          pktLostPercentage = ((this.packetsSent - this.packetsReceived) / this.packetsSent) * 100;

          if (pktLostPercentage < PACKET_LOST_RANGE[0]) {
            pktLoss = GOOD;
          } else if (pktLostPercentage < PACKET_LOST_RANGE[1]) {
            pktLoss = MODERATE;
          } else {
            pktLoss = POOR;
          }

          this.test.reportByState(`Packets lost: ${pktLostPercentage.toFixed(2)}%`, pktLoss);
          if(true === this.test.bitrate_only) {
            this.test.fillPacketsLost(pktLostPercentage.toFixed(2));
          }
        }
        let bandwidthSend = ((this.videoBytesSent * 8) / (durationS * 1000)).toFixed(2);
        let bandwidthReceived = ((this.videoBytesRecieved * 8) / (durationS * 1000)).toFixed(2);

        this.test.reportInfo(`Video Bitrate (Send) :${bandwidthSend} kbps`);
        this.test.reportInfo(`Video Bitrate (Receive) :${bandwidthReceived} kbps`);
      }
    } else if (adapter.browserDetails.browser === 'firefox') {
      this.test.reportInfo(`Bitrate Mean (Send): ${parseInt(this.bitrateMean) / 1000} kbps`);
      const now = new Date();
      const durationS = (now - this.startTime) / 1000;
      let sendBWEstimateAvg = ((this.bytesSent * 8) / (durationS * 1000)).toFixed(2);
      let sendBWEstimateAvgState = null;
      if (sendBWEstimateAvg < BANDWIDTH_RANGE_VIDEO[0]) {
        sendBWEstimateAvgState = POOR;
      } else if (sendBWEstimateAvg < BANDWIDTH_RANGE_VIDEO[1]) {
        sendBWEstimateAvgState = MODERATE;
      } else {
        sendBWEstimateAvgState = GOOD;
      }
      let possible_no_incoming_videos = 0;
      if(sendBWEstimateAvg < INCOMING_VIDEO_COUNT_BANDWIDTH_RANGE[0]) {
        possible_no_incoming_videos = 1;
      } else if(sendBWEstimateAvg < INCOMING_VIDEO_COUNT_BANDWIDTH_RANGE[1]) {
        possible_no_incoming_videos = 2;
      } else if(sendBWEstimateAvg < INCOMING_VIDEO_COUNT_BANDWIDTH_RANGE[2]) {
        possible_no_incoming_videos = 4;
      } else {
        possible_no_incoming_videos = 5;
      }
      this.test.reportByState(`Average Video bandwidth (Send): ${sendBWEstimateAvg} kbps`, sendBWEstimateAvgState);
      if(true === this.test.bitrate_only) {
        this.test.fillBandwidth(sendBWEstimateAvg * 1000);
      }
      if(false === this.test.bitrate_only) {
        this.test.reportInfo(`Packets sent: ${this.packetsSent}`);
        this.test.reportInfo(`Packets received: ${this.packetsReceived}`);
      }
      let pktLoss = null;
      let pktLostPercentage = null;
      if(this.packetsSent > 0) {
        pktLostPercentage = ((this.packetsSent - this.packetsReceived) / this.packetsSent) * 100;

        if (pktLostPercentage < PACKET_LOST_RANGE[0]) {
          pktLoss = GOOD;
        } else if (pktLostPercentage < PACKET_LOST_RANGE[1]) {
          pktLoss = MODERATE;
        } else {
          pktLoss = POOR;
        }

        this.test.reportByState(`Packets lost: ${pktLostPercentage.toFixed(2)}%`, pktLoss);
        if(true === this.test.bitrate_only) {
          this.test.fillPacketsLost(pktLostPercentage.toFixed(2));
        }
      }
      let bandwidthSend = ((this.videoBytesSent * 8) / (durationS * 1000)).toFixed(2);
      let bandwidthReceived = ((this.videoBytesRecieved * 8) / (durationS * 1000)).toFixed(2);

      this.test.reportInfo(`Video Bitrate (Send) :${bandwidthSend} kbps`);
      this.test.reportInfo(`Video Bitrate (Receive) :${bandwidthReceived} kbps`);
    }
    let rttAverage = this.rttStats.getAverage();
    let rttValue = null;

    if (rttAverage < RTT_RANGE[0]) {
      rttValue = GOOD;
    } else if (rttAverage < RTT_RANGE[1]) {
      rttValue = MODERATE;
    } else {
      rttValue = POOR;
    }
    this.test.reportByState(`RTT average: ${rttAverage} ms`, rttValue);
    if(false === this.test.bitrate_only) {
      this.test.reportInfo(`RTT max: ${this.rttStats.getMax()} ms`);
    }
    this.test.done();
  },
};

function WiFiPeriodicScanTest(test, candidateFilter) {
  this.test = test;
  this.candidateFilter = candidateFilter;
  this.testDurationMs = 5 * 60 * 1000;
  this.sendIntervalMs = 100;
  this.delays = [];
  this.recvTimeStamps = [];
  this.running = false;
  this.call = null;
  this.senderChannel = null;
  this.receiveChannel = null;
}

WiFiPeriodicScanTest.prototype = {
  run() {
    if (this.test.server === 'TURN') {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateTurnConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    } else {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateStunConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
    );
    }
  },

  start(config) {
    this.filterConfig(config);
    this.running = true;
    this.call = new __WEBPACK_IMPORTED_MODULE_0__call___default.a(config, this.test);
    //this.chart = this.test.createLineChart();
    this.call.setIceCandidateFilter(this.candidateFilter);

    this.senderChannel = this.call.pc1.createDataChannel({
      ordered: false,
      maxRetransmits: 0,
    });
    this.senderChannel.addEventListener('open', this.send.bind(this));
    this.call.pc2.addEventListener(
      'datachannel',
      this.onReceiverChannel.bind(this),
    );
    this.call.establishConnection();

    util.setTimeoutWithProgressBar(
    this.finishTest.bind(this),
      this.testDurationMs,
    );
  },

  filterConfig(config) {
    const newIceServers = [];
    const iceServer = config.iceServers[0];
    const new_urls = [];
    const transport = 'transport=tcp';
    const uri = (iceServer.urls.startsWith('turns')) ? `${iceServer.urls}?${transport}` : iceServer.urls;
    new_urls.push(uri);
    iceServer.urls = new_urls;
    newIceServers.push(iceServer);
    config.iceServers = newIceServers;
  },
  onReceiverChannel(event) {
    this.receiveChannel = event.channel;
    this.receiveChannel.addEventListener('message', this.receive.bind(this));
  },

  send() {
    if (!this.running) {
      return;
    }
    this.senderChannel.send(`${Date.now()}`);
    setTimeout(this.send.bind(this), this.sendIntervalMs);
  },

  receive(event) {
    if (!this.running) {
      return;
    }
    const sendTime = parseInt(event.data);
    const delay = Date.now() - sendTime;
    this.recvTimeStamps.push(sendTime);
    this.delays.push(delay);
    this.test.fillData(sendTime + delay, delay);
    //console.log('timestamp: ' + sendTime + delay + ' value: '+ delay);
    //this.chart.addDatapoint(sendTime + delay, delay);
  },

  finishTest() {
    // report.traceEventInstant('periodic-delay', {
    // delays: this.delays,
    //       recvTimeStamps: this.recvTimeStamps,
    // });
    this.running = false;
    this.call.close();
    this.call = null;
    //this.chart.parentElement.removeChild(this.chart);

    //let avg = util.arrayAverage(this.delays);
    let max = util.arrayMax(this.delays);
    let min = util.arrayMin(this.delays);
    // this.test.reportInfo('Average delay: ' + avg + ' ms.');
    // this.test.reportInfo('Min delay: ' + min + ' ms.');
    // this.test.reportInfo('Max delay: ' + max + ' ms.');

    if (this.delays.length < (0.8 * this.testDurationMs) / this.sendIntervalMs) {
      this.test.reportError('Not enough samples gathered. Keep the page on ' +
          ' the foreground while the test is running.');
    } else {
      this.test.reportSuccess(`Collected ${this.delays.length
          } delay samples.`);
    }

    if (max > (min + 100) * 2) {
      this.test.reportError('There is a big difference between the min and ' +
          'max delay of packets. Your network appears unstable.' + 'min='+min + 'max='+max);
    }
    this.test.done();
  },
};

function AudioBandwidthTest(test, deviceId, testDuration) {
  this.test = test;
  this.maxAudioBitrateKbps = 2000;
  this.durationMs = testDuration * 1000;
  this.statStepMs = 100;
  this.bweStats = new util.StatisticsAggregate(0.75 * this.maxAudioBitrateKbps *
      1000);
  this.rttStats = new util.StatisticsAggregate();
  this.packetsLost = -1;
  this.packetsSent = -1;
  this.packetsReceived = -1;
  this.audioBytesSent = -1;
  this.audioBytesRecieved = -1;
  this.startTime = null;
  this.jitter = 0;
  this.call = null;
  this.bytesSent = 0;
  this.deviceId = deviceId;
  this.constraints = {
    audio: true,
  };
}

AudioBandwidthTest.prototype = {
  run() {
    if (this.test.server === 'TURN') {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateTurnConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    } else {
      __WEBPACK_IMPORTED_MODULE_0__call___default.a.asyncCreateStunConfig(
        this.start.bind(this),
        this.test.reportFatal.bind(this.test), this.test.region,
      );
    }
  },

  start(config) {
    this.call = new __WEBPACK_IMPORTED_MODULE_0__call___default.a(config, this.test);
    this.call.setIceCandidateFilter(__WEBPACK_IMPORTED_MODULE_0__call___default.a.isRelay);
    // FEC makes it hard to study bandwidth estimation since there seems to be
    // a spike when it is enabled and disabled. Disable it for now. FEC issue
    // tracked on: https://code.google.com/p/webrtc/issues/detail?id=3050
    //this.call.disableVideoFec();
    //this.call.constrainVideoBitrate(this.maxVideoBitrateKbps);
    util.appendSourceId(this.deviceId, 'audio', this.constraints);
    util.doGetUserMedia(this.constraints, this.gotStream.bind(this), this.onFail.bind(this));
  },

  onFail(error) {
    this.test.reportError(`getUserMedia failed with error: ${error}`);
    this.test.done();
  },

  gotStream(stream) {
    this.call.pc1.addStream(stream);
    this.call.establishConnection();
    this.startTime = new Date();
    this.localStream = stream.getAudioTracks()[0];
    setTimeout(this.gatherStats.bind(this), this.statStepMs);
  },

  gatherStats() {
    const now = new Date();
    if (now - this.startTime > this.durationMs) {
      this.test.setProgress(100);
      this.hangup();
      return;
    } else if (!this.call.statsGatheringRunning) {
      this.call.gatherStats(
        this.call.pc1, this.call.pc2, this.localStream,
        this.gotStats.bind(this),
      );
    }
    this.test.setProgress((now - this.startTime) * 100 / this.durationMs);
    setTimeout(this.gatherStats.bind(this), this.statStepMs);
  },

  gotStats(response, time, response2, time2) {
    // TODO: Remove browser specific stats gathering hack once adapter.js or
    // browsers converge on a standard.
    if (adapter.browserDetails.browser === 'chrome') {
      for (const i in response) {
        if (typeof response[i].connection !== 'undefined') {
          this.bweStats.add(
            response[i].connection.timestamp,
            parseInt(response[i].connection.availableOutgoingBitrate),
          );
          this.rttStats.add(
            response[i].connection.timestamp,
            parseInt(response[i].connection.currentRoundTripTime * 1000),
          );
          // Grab the last stats.
          this.packetsLost = response2[i].audio.remote.packetsLost;
          this.packetsSent = response[i].audio.local.packetsSent;
          this.packetsReceived = response2[i].audio.remote.packetsReceived;
          this.audioBytesSent = response[i].audio.local.bytesSent;
          this.audioBytesRecieved = response2[i].audio.remote.bytesReceived;
          this.jitter = response2[i].audio.remote.jitter;
        }
      }
    } else if (adapter.browserDetails.browser === 'firefox') {
      for (const j in response) {
        let rtt = response[j].audio.remote.roundTripTime * 1000;
        if(rtt) {
          this.rttStats.add(
          response[j].audio.remote.timestamp,
          parseInt(rtt),
          );
        }
        this.bytesSent += response[j].connection.bytesSent;
        this.packetsSent = response[j].audio.local.packetsSent;
        this.packetsLost = response2[j].audio.remote.packetsLost;
        this.packetsReceived = response2[j].audio.remote.packetsReceived;
        this.jitter = response2[j].audio.remote.jitter;
        this.audioBytesSent = response[j].audio.local.bytesSent;
        this.audioBytesRecieved = response2[j].audio.remote.bytesReceived;
      }
    } else {
      this.test.reportError('Only Firefox and Chrome getStats implementations' +
        ' are supported.');
    }
    this.completed();
  },

  hangup() {
    this.call.pc1.getLocalStreams()[0].getTracks().forEach((track) => {
      track.stop();
    });
    this.call.close();
    this.call = null;
  },

  completed() {
    // TODO: Remove browser specific stats gathering hack once adapter.js or
    // browsers converge on a standard.
    if (adapter.browserDetails.browser === 'chrome') {
      const now = new Date();
      const durationS = (now - this.startTime) / 1000;
      {
        let sendBWEstimateAvg = Math.round(this.bweStats.getAverage() / 1000);
        let sendBWEstimateAvgState = null;
        if (sendBWEstimateAvg < BANDWIDTH_RANGE_AUDIO[0]) {
          sendBWEstimateAvgState = POOR;
        } else if (sendBWEstimateAvg < BANDWIDTH_RANGE_AUDIO[1]) {
          sendBWEstimateAvgState = MODERATE;
        } else {
          sendBWEstimateAvgState = GOOD;
        }
        this.test.reportByState(`Average Audio bandwidth (Send): ${sendBWEstimateAvg} kbps`, sendBWEstimateAvgState);
        if(true === this.test.bitrate_only) {
          this.test.fillBandwidth(this.bweStats.getAverage());
        }
        if(false == this.test.bitrate_only) {
          this.test.reportInfo(`Send bandwidth estimate max: ${
              this.bweStats.getMax() / 1000} kbps`);
          this.test.reportInfo(`Send bandwidth ramp-up time: ${
              this.bweStats.getRampUpTime()} ms`);
          this.test.reportInfo(`Packets sent: ${this.packetsSent}`);
          this.test.reportInfo(`Packets received: ${this.packetsReceived}`);
        }
        let pktLoss = null;
        let pktLostPercentage = null;
        if(this.packetsSent > 0) {
          pktLostPercentage = ((this.packetsSent - this.packetsReceived) / this.packetsSent) * 100;
          if (pktLostPercentage < PACKET_LOST_RANGE[0]) {
            pktLoss = GOOD;
          } else if (pktLostPercentage < PACKET_LOST_RANGE[1]) {
            pktLoss = MODERATE;
          } else {
            pktLoss = POOR;
          }
          this.test.reportByState(`Packets lost: ${pktLostPercentage.toFixed(2)}%`, pktLoss);
          if(true === this.test.bitrate_only) {
            this.test.fillPacketsLost(pktLostPercentage.toFixed(2));
          }
        }
        let bandwidthSend = ((this.audioBytesSent * 8) / (durationS * 1000)).toFixed(2);
        let bandwidthReceived = ((this.audioBytesRecieved * 8) / (durationS * 1000)).toFixed(2);

        this.test.reportInfo(`Audio Bitrate (Send) :${bandwidthSend} kbps`);
        this.test.reportInfo(`Audio Bitrate (Receive) :'${bandwidthReceived} 'kbps`);

        let jit = this.jitter * 1000;
        let jitter = null;
        if(jit > JITTER_RANGE[1] || jit <= JITTER_RANGE[0]) {
          jitter = POOR;
        } else {
          jitter = GOOD;
          this.test.reportByState(`Jitter: ${jit}`, jitter);
        }
      }
    } else if (adapter.browserDetails.browser === 'firefox') {
      const now = new Date();
      const durationS = (now - this.startTime) / 1000;
      // let sendBWEstimateAvg = Math.round(this.bweStats.getAverage() / 1000);
      // let sendBWEstimateAvgState = null;
      // if (sendBWEstimateAvg < BANDWIDTH_RANGE_AUDIO[0]) {
      //   sendBWEstimateAvgState = POOR;
      // } else if (sendBWEstimateAvg < BANDWIDTH_RANGE_AUDIO[1]) {
      //   sendBWEstimateAvgState = MODERATE;
      // } else {
      //   sendBWEstimateAvgState = GOOD;
      // }
      // this.test.reportByState(`Average Audio bandwidth (Send): ${sendBWEstimateAvg} kbps`, sendBWEstimateAvgState);
      // if(true === this.test.bitrate_only) {
      //   this.test.fillBandwidth(sendBWEstimateAvg * 1000);
      // }
      if(false === this.test.bitrate_only) {
        this.test.reportInfo(`Packets sent: ${this.packetsSent}`);
        this.test.reportInfo(`Packets received: ${this.packetsReceived}`);
      }
      let pktLoss = null;
      let pktLostPercentage = null;
      if(this.packetsSent > 0) {
        pktLostPercentage = ((this.packetsSent - this.packetsReceived) / this.packetsSent) * 100;

        if (pktLostPercentage < PACKET_LOST_RANGE[0]) {
          pktLoss = GOOD;
        } else if (pktLostPercentage < PACKET_LOST_RANGE[1]) {
          pktLoss = MODERATE;
        } else {
          pktLoss = POOR;
        }

        this.test.reportByState(`Packets lost: ${pktLostPercentage.toFixed(2)}%`, pktLoss);
        if(true === this.test.bitrate_only) {
          this.test.fillPacketsLost(pktLostPercentage.toFixed(2));
        }
      }
      let jit = this.jitter * 1000;
      let jitter = null;
      if(jit > JITTER_RANGE[1] || jit <= JITTER_RANGE[0]) {
        jitter = POOR;
      } else {
        jitter = GOOD;
        this.test.reportByState(`Jitter: ${jit}`, jitter);
      }
      let bandwidthSend = ((this.audioBytesSent * 8) / (durationS * 1000)).toFixed(2);
      let bandwidthReceived = ((this.audioBytesRecieved * 8) / (durationS * 1000)).toFixed(2);

      this.test.reportInfo(`Audio Bitrate (Send) :${bandwidthSend} kbps`);
      this.test.reportInfo(`Audio Bitrate (Receive) :'${bandwidthReceived} 'kbps`);
    }
    let rttAverage = this.rttStats.getAverage();
    let rttValue = null;
    let pktLoss = null;
    if (rttAverage < RTT_RANGE[0]) {
      rttValue = GOOD;
    } else if (rttAverage < RTT_RANGE[1]) {
      rttValue = MODERATE;
    } else {
      rttValue = POOR;
    }

    this.test.reportByState(`RTT average: ${rttAverage} ms`, rttValue);
    if(false === this.test.bitrate_only) {
      this.test.reportInfo(`RTT max: ${this.rttStats.getMax()} ms`);
    }
    this.test.done();
  },
};

function testThroughPut(test, deviceId, testDuration) {
  switch (test.test_title) {
    case 'data_throughput': {
      // Creates a loopback via relay candidates and tries to send as many packets
      // with 1024 chars as possible while keeping dataChannel bufferedAmmount above
      // zero.
      const dataChannelThroughputTest = new DataChannelThroughputTest(test, testDuration);
      dataChannelThroughputTest.run();
    }
    break;
    case 'video_bandwidth': {
      // Measures video bandwidth estimation performance by doing a loopback call via
      // relay candidates for 40 seconds. Computes rtt and bandwidth estimation
      // average and maximum as well as time to ramp up (defined as reaching 75% of
      // the max bitrate. It reports infinite time to ramp up if never reaches it.
      const videoBandwidthTest = new VideoBandwidthTest(test, deviceId, testDuration);
      videoBandwidthTest.run();
      break;
    }
    case 'audio_bandwidth': {
      // Measures audio bandwidth estimation performance by doing a loopback call via
      // relay candidates for 10 seconds. Computes rtt and bandwidth estimation
      // average and maximum as well as time to ramp up (defined as reaching 75% of
      // the max bitrate. It reports infinite time to ramp up if never reaches it.
      const audioBandwidthTest = new AudioBandwidthTest(test, deviceId, testDuration);
      audioBandwidthTest.run();
      break;
    }
    case 'network_latency': {
      const wiFiPeriodicScanTest = new WiFiPeriodicScanTest(test, __WEBPACK_IMPORTED_MODULE_0__call___default.a.isNotHostCandidate);
      wiFiPeriodicScanTest.run();
      break;
    }
    // case 'network_latency_relay': {
    //   const wiFiPeriodicScanTest = new WiFiPeriodicScanTest(test, Call.isRelay);
    //   wiFiPeriodicScanTest.run();
    //   break;
    // }
  }
}


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = testSignalling;
/*
  This file tests the signalling server.
 */


const fetch = __webpack_require__(77);


function testSignalling(test, host, port) {
  const signalling_connectivity = new SignallingConnectivity(test, host, port);
  signalling_connectivity.run();
}

// signalling.js
function SignallingConnectivity(test, host, port) {
    this.test = test;
    this.host = host;
    this.port = port;
}

SignallingConnectivity.prototype = {
  run() {
    const host = this.host;
    const port = this.port;
    const url = `https://${host}:${port}/proxy-token`;
    fetch(url, {
      method: 'POST',
      headers: {
          'Content-type': 'application/json; charset=UTF-8',
          'Authorization': 'No'
      }
      })
    .then(response => response.json())
    .then(tokenObj => {
        this.test.reportSuccess('Token created successfully.');
        let hastokenProperty = Object.prototype.hasOwnProperty.call(tokenObj, "token");
        if(hastokenProperty === false) {
          this.test.reportError(`Token creation failed due to error: ${tokenObj.error}`);
          this.test.done();
        } else {
          let VideoSize = {
            "LD": [80, 45, 640, 360]
          };
          let StreamOpt = {
            video: true,
            audio: true,
            data: true,
            videoSize: VideoSize.SD,
            attributes: { name: "Test connectivity" }
          };
          let log_level = EnxRtc.Logger.getLogLevel();
          EnxRtc.Logger.setLogLevel(EnxRtc.Logger.NONE);
          EnxRtc.joinRoom(tokenObj.token, StreamOpt, (success, error) => {
            EnxRtc.Logger.setLogLevel(log_level);
            if (error && error != null) {
              // Look for error.type and error.msg.name to handle Exception
                this.test.reportError(`Room not joined due to error: ${error.type }`);
                this.test.done();
            } else if (success && success != null) {
              let rm = null;
              rm = success.room;
              rm.disconnect();
              this.test.reportSuccess('Room joined successfully.');
              this.test.done();
            }
          }
        )
      }
    })
    .catch((error) => {
      this.test.reportError(`Token creation failed due to error: ${error}`);
      this.test.done();
    });
  }
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports.default = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Room__ = __webpack_require__(11);


const APP = "app";

function validScope(scope) {
    if(scope == undefined || scope == APP) {
        return false;
    }
    return true;
}

const applicationData = {};
applicationData.setCustomData = (scope, data, callback) => {
    console.log('setCustomData');
};
applicationData.getCustomData = (options, callback) => {
    console.log('getCustomData');
    var ret = { result: 0 };
    if(false == validScope(options.scope)) {
        ret.result = 1;
        ret.error = "Invalid scope parameter "+ options.scope;
        callback(ret);
        return;
    }
    // ss event
};
applicationData.saveCustomData = (scope, data, callback) => {
    console.log('saveCustomData');
    var ret = { result: 0 };
    if(false == validScope(scope)) {
        ret.result = 1;
        ret.error = "Invalid scope parameter: "+ scope;
        callback(ret);
        return;
    }
    if(data == undefined || typeof(data) != 'object') {
        ret.result = 1;
        ret.error = "Invalid  data";
        callback(ret);
        return;
    }
    callback(ret);
};
/* harmony default export */ __webpack_exports__["a"] = (applicationData);

/***/ }),
/* 79 */
/***/ (function(module, exports) {

//import * as Hls from 'hls.js';



// const hlsStreaming = {};

// hlsStreaming.playStreamerURI = (elementID, streaming_url) => {
//     console.log('inside playHls');
//     const vid = document.getElementById(elementID);
//     let video = document.getElementById(elementID);
//     console.log('vid.nodeName: ',vid.nodeName);
//     if (vid.nodeName !== 'VIDEO') {
//       console.log('no video tag found');
//       video = document.createElement('video');
//       if(Hls.isSupported()) {
//         console.log('Hls is supported');
//         var hls = new Hls();
//         hls.loadSource(streaming_url);

//         hls.attachMedia(video);
//         hls.on(Hls.Events.MANIFEST_PARSED,function() {
//           video.play();
//         });
//       }
//       video.setAttribute('height', vid.getAttribute('height'));
//       video.setAttribute('width', vid.getAttribute('width'));
//       vid.appendChild(video);
//     }
// };


// export default hlsStreaming;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["adapter"] = __webpack_require__(81);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;(function (f) { if (true) { module.exports = f(); } else if (typeof define === 'function' && define.amd) { define([], f); } else { let g; if (typeof window !== 'undefined') { g = window; } else if (typeof global !== 'undefined') { g = global; } else if (typeof self !== 'undefined') { g = self; } else { g = this; } g.adapter = f(); } }(() => {
  let define,
    module,
    exports; return (function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { const c = typeof require === 'function' && require; if (!f && c) return require(i, !0); if (u) return u(i, !0); const a = new Error(`Cannot find module '${i}'`); throw a.code = 'MODULE_NOT_FOUND', a; } const p = n[i] = { exports: {} }; e[i][0].call(p.exports, (r) => { const n = e[i][1][r]; return o(n || r); }, p, p.exports, r, e, n, t); } return n[i].exports; } for (var u = typeof require === 'function' && require, i = 0; i < t.length; i++)o(t[i]); return o; } return r; }())({
      1: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        const _adapter_factory = require('./adapter_factory.js');

        const adapter = (0, _adapter_factory.adapterFactory)({ window });
        module.exports = adapter; // this is the difference from adapter_core.
      }, { './adapter_factory.js': 2 }],
      2: [function (require, module, exports) {
        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.adapterFactory = adapterFactory;

        const _utils = require('./utils');

        const utils = _interopRequireWildcard(_utils);

        const _chrome_shim = require('./chrome/chrome_shim');

        const chromeShim = _interopRequireWildcard(_chrome_shim);

        const _edge_shim = require('./edge/edge_shim');

        const edgeShim = _interopRequireWildcard(_edge_shim);

        const _firefox_shim = require('./firefox/firefox_shim');

        const firefoxShim = _interopRequireWildcard(_firefox_shim);

        const _safari_shim = require('./safari/safari_shim');

        const safariShim = _interopRequireWildcard(_safari_shim);

        const _common_shim = require('./common_shim');

        const commonShim = _interopRequireWildcard(_common_shim);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        // Shimming starts here.
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        function adapterFactory() {
          let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            window = _ref.window;

          const options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            shimChrome: true,
            shimFirefox: true,
            shimEdge: true,
            shimSafari: true,
          };

          // Utils.
          const logging = utils.log;
          const browserDetails = utils.detectBrowser(window);

          const adapter = {
            browserDetails,
            commonShim,
            extractVersion: utils.extractVersion,
            disableLog: utils.disableLog,
            disableWarnings: utils.disableWarnings,
          };

          // Shim browser if found.
          switch (browserDetails.browser) {
            case 'chrome':
              if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
                logging('Chrome shim is not included in this adapter release.');
                return adapter;
              }
              logging('adapter.js shimming chrome.');
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = chromeShim;

              chromeShim.shimGetUserMedia(window);
              chromeShim.shimMediaStream(window);
              chromeShim.shimPeerConnection(window);
              chromeShim.shimOnTrack(window);
              chromeShim.shimAddTrackRemoveTrack(window);
              chromeShim.shimGetSendersWithDtmf(window);
              chromeShim.shimGetStats(window);
              chromeShim.shimSenderReceiverGetStats(window);
              chromeShim.fixNegotiationNeeded(window);

              commonShim.shimRTCIceCandidate(window);
              commonShim.shimConnectionState(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              commonShim.removeAllowExtmapMixed(window);
              break;
            case 'firefox':
              if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
                logging('Firefox shim is not included in this adapter release.');
                return adapter;
              }
              logging('adapter.js shimming firefox.');
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = firefoxShim;

              firefoxShim.shimGetUserMedia(window);
              firefoxShim.shimPeerConnection(window);
              firefoxShim.shimOnTrack(window);
              firefoxShim.shimRemoveStream(window);
              firefoxShim.shimSenderGetStats(window);
              firefoxShim.shimReceiverGetStats(window);
              firefoxShim.shimRTCDataChannel(window);

              commonShim.shimRTCIceCandidate(window);
              commonShim.shimConnectionState(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              break;
            case 'edge':
              if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
                logging('MS edge shim is not included in this adapter release.');
                return adapter;
              }
              logging('adapter.js shimming edge.');
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = edgeShim;

              edgeShim.shimGetUserMedia(window);
              edgeShim.shimGetDisplayMedia(window);
              edgeShim.shimPeerConnection(window);
              edgeShim.shimReplaceTrack(window);

              // the edge shim implements the full RTCIceCandidate object.

              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              break;
            case 'safari':
              if (!safariShim || !options.shimSafari) {
                logging('Safari shim is not included in this adapter release.');
                return adapter;
              }
              logging('adapter.js shimming safari.');
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = safariShim;

              safariShim.shimRTCIceServerUrls(window);
              safariShim.shimCreateOfferLegacy(window);
              safariShim.shimCallbacksAPI(window);
              safariShim.shimLocalStreamsAPI(window);
              safariShim.shimRemoteStreamsAPI(window);
              safariShim.shimTrackEventTransceiver(window);
              safariShim.shimGetUserMedia(window);

              commonShim.shimRTCIceCandidate(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              commonShim.removeAllowExtmapMixed(window);
              break;
            default:
              logging('Unsupported browser!');
              break;
          }

          return adapter;
        }

        // Browser shims.
      }, {
        './chrome/chrome_shim': 3, './common_shim': 6, './edge/edge_shim': 7, './firefox/firefox_shim': 11, './safari/safari_shim': 14, './utils': 15,
      }],
      3: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

        const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

        const _getusermedia = require('./getusermedia');

        Object.defineProperty(exports, 'shimGetUserMedia', {
          enumerable: true,
          get: function get() {
            return _getusermedia.shimGetUserMedia;
          },
        });

        const _getdisplaymedia = require('./getdisplaymedia');

        Object.defineProperty(exports, 'shimGetDisplayMedia', {
          enumerable: true,
          get: function get() {
            return _getdisplaymedia.shimGetDisplayMedia;
          },
        });
        exports.shimMediaStream = shimMediaStream;
        exports.shimOnTrack = shimOnTrack;
        exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
        exports.shimGetStats = shimGetStats;
        exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
        exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
        exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
        exports.shimPeerConnection = shimPeerConnection;
        exports.fixNegotiationNeeded = fixNegotiationNeeded;

        const _utils = require('../utils.js');

        const utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value, enumerable: true, configurable: true, writable: true,
            });
          } else { obj[key] = value; } return obj;
        }

        function shimMediaStream(window) {
          window.MediaStream = window.MediaStream || window.webkitMediaStream;
        }

        function shimOnTrack(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
              get: function get() {
                return this._ontrack;
              },
              set: function set(f) {
                if (this._ontrack) {
                  this.removeEventListener('track', this._ontrack);
                }
                this.addEventListener('track', this._ontrack = f);
              },

              enumerable: true,
              configurable: true,
            });
            const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
            window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              const _this = this;

              if (!this._ontrackpoly) {
                this._ontrackpoly = function (e) {
                  // onaddstream does not fire when a track is added to an existing
                  // stream. But stream.onaddtrack is implemented so we use that.
                  e.stream.addEventListener('addtrack', (te) => {
                    let receiver = void 0;
                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = _this.getReceivers().find(r => r.track && r.track.id === te.track.id);
                    } else {
                      receiver = { track: te.track };
                    }

                    const event = new Event('track');
                    event.track = te.track;
                    event.receiver = receiver;
                    event.transceiver = { receiver };
                    event.streams = [e.stream];
                    _this.dispatchEvent(event);
                  });
                  e.stream.getTracks().forEach((track) => {
                    let receiver = void 0;
                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = _this.getReceivers().find(r => r.track && r.track.id === track.id);
                    } else {
                      receiver = { track };
                    }
                    const event = new Event('track');
                    event.track = track;
                    event.receiver = receiver;
                    event.transceiver = { receiver };
                    event.streams = [e.stream];
                    _this.dispatchEvent(event);
                  });
                };
                this.addEventListener('addstream', this._ontrackpoly);
              }
              return origSetRemoteDescription.apply(this, arguments);
            };
          } else {
            // even if RTCRtpTransceiver is in window, it is only used and
            // emitted in unified-plan. Unfortunately this means we need
            // to unconditionally wrap the event.
            utils.wrapPeerConnectionEvent(window, 'track', (e) => {
              if (!e.transceiver) {
                Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } });
              }
              return e;
            });
          }
        }

        function shimGetSendersWithDtmf(window) {
          // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
            const shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
              return {
                track,
                get dtmf() {
                  if (this._dtmf === undefined) {
                    if (track.kind === 'audio') {
                      this._dtmf = pc.createDTMFSender(track);
                    } else {
                      this._dtmf = null;
                    }
                  }
                  return this._dtmf;
                },
                _pc: pc,
              };
            };

            // augment addTrack when getSenders is not available.
            if (!window.RTCPeerConnection.prototype.getSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                this._senders = this._senders || [];
                return this._senders.slice(); // return a copy of the internal state.
              };
              const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
              window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
                let sender = origAddTrack.apply(this, arguments);
                if (!sender) {
                  sender = shimSenderWithDtmf(this, track);
                  this._senders.push(sender);
                }
                return sender;
              };

              const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
              window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
                origRemoveTrack.apply(this, arguments);
                const idx = this._senders.indexOf(sender);
                if (idx !== -1) {
                  this._senders.splice(idx, 1);
                }
              };
            }
            const origAddStream = window.RTCPeerConnection.prototype.addStream;
            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              const _this2 = this;

              this._senders = this._senders || [];
              origAddStream.apply(this, [stream]);
              stream.getTracks().forEach((track) => {
                _this2._senders.push(shimSenderWithDtmf(_this2, track));
              });
            };

            const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
            window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
              const _this3 = this;

              this._senders = this._senders || [];
              origRemoveStream.apply(this, [stream]);

              stream.getTracks().forEach((track) => {
                const sender = _this3._senders.find(s => s.track === track);
                if (sender) {
                  // remove sender
                  _this3._senders.splice(_this3._senders.indexOf(sender), 1);
                }
              });
            };
          } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
            const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              const _this4 = this;

              const senders = origGetSenders.apply(this, []);
              senders.forEach(sender => sender._pc = _this4);
              return senders;
            };

            Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
              get: function get() {
                if (this._dtmf === undefined) {
                  if (this.track.kind === 'audio') {
                    this._dtmf = this._pc.createDTMFSender(this.track);
                  } else {
                    this._dtmf = null;
                  }
                }
                return this._dtmf;
              },
            });
          }
        }

        function shimGetStats(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          const origGetStats = window.RTCPeerConnection.prototype.getStats;
          window.RTCPeerConnection.prototype.getStats = function getStats() {
            const _this5 = this;

            let _arguments = Array.prototype.slice.call(arguments),
              selector = _arguments[0],
              onSucc = _arguments[1],
              onErr = _arguments[2];

            // If selector is a function then we are in the old style stats so just
            // pass back the original getStats format to avoid breaking old users.


            if (arguments.length > 0 && typeof selector === 'function') {
              return origGetStats.apply(this, arguments);
            }

            // When spec-style getStats is supported, return those when called with
            // either no arguments or the selector argument is null.
            if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
              return origGetStats.apply(this, []);
            }

            const fixChromeStats_ = function fixChromeStats_(response) {
              const standardReport = {};
              const reports = response.result();
              reports.forEach((report) => {
                const standardStats = {
                  id: report.id,
                  timestamp: report.timestamp,
                  type: {
                    localcandidate: 'local-candidate',
                    remotecandidate: 'remote-candidate',
                  }[report.type] || report.type,
                };
                report.names().forEach((name) => {
                  standardStats[name] = report.stat(name);
                });
                standardReport[standardStats.id] = standardStats;
              });

              return standardReport;
            };

            // shim getStats with maplike support
            const makeMapStats = function makeMapStats(stats) {
              return new Map(Object.keys(stats).map(key => [key, stats[key]]));
            };

            if (arguments.length >= 2) {
              const successCallbackWrapper_ = function successCallbackWrapper_(response) {
                onSucc(makeMapStats(fixChromeStats_(response)));
              };

              return origGetStats.apply(this, [successCallbackWrapper_, selector]);
            }

            // promise-support
            return new Promise(((resolve, reject) => {
              origGetStats.apply(_this5, [function (response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
            })).then(onSucc, onErr);
          };
        }

        function shimSenderReceiverGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
            return;
          }

          // shim sender stats.
          if (!('getStats' in window.RTCRtpSender.prototype)) {
            const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
            if (origGetSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                const _this6 = this;

                const senders = origGetSenders.apply(this, []);
                senders.forEach(sender => sender._pc = _this6);
                return senders;
              };
            }

            const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
            if (origAddTrack) {
              window.RTCPeerConnection.prototype.addTrack = function addTrack() {
                const sender = origAddTrack.apply(this, arguments);
                sender._pc = this;
                return sender;
              };
            }
            window.RTCRtpSender.prototype.getStats = function getStats() {
              const sender = this;
              return this._pc.getStats().then(result => (
                /* Note: this will include stats of all senders that
                 *   send a track with the same id as sender.track as
                 *   it is not possible to identify the RTCRtpSender.
                 */
                utils.filterStats(result, sender.track, true)
              ));
            };
          }

          // shim receiver stats.
          if (!('getStats' in window.RTCRtpReceiver.prototype)) {
            const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
            if (origGetReceivers) {
              window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
                const _this7 = this;

                const receivers = origGetReceivers.apply(this, []);
                receivers.forEach(receiver => receiver._pc = _this7);
                return receivers;
              };
            }
            utils.wrapPeerConnectionEvent(window, 'track', (e) => {
              e.receiver._pc = e.srcElement;
              return e;
            });
            window.RTCRtpReceiver.prototype.getStats = function getStats() {
              const receiver = this;
              return this._pc.getStats().then(result => utils.filterStats(result, receiver.track, false));
            };
          }

          if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
            return;
          }

          // shim RTCPeerConnection.getStats(track).
          const origGetStats = window.RTCPeerConnection.prototype.getStats;
          window.RTCPeerConnection.prototype.getStats = function getStats() {
            if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
              const track = arguments[0];
              let sender = void 0;
              let receiver = void 0;
              let err = void 0;
              this.getSenders().forEach((s) => {
                if (s.track === track) {
                  if (sender) {
                    err = true;
                  } else {
                    sender = s;
                  }
                }
              });
              this.getReceivers().forEach((r) => {
                if (r.track === track) {
                  if (receiver) {
                    err = true;
                  } else {
                    receiver = r;
                  }
                }
                return r.track === track;
              });
              if (err || sender && receiver) {
                return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
              } else if (sender) {
                return sender.getStats();
              } else if (receiver) {
                return receiver.getStats();
              }
              return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
            }
            return origGetStats.apply(this, arguments);
          };
        }

        function shimAddTrackRemoveTrackWithNative(window) {
          // shim addTrack/removeTrack with native variants in order to make
          // the interactions with legacy getLocalStreams behave as in other browsers.
          // Keeps a mapping stream.id => [stream, rtpsenders...]
          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            const _this8 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            return Object.keys(this._shimmedLocalStreams).map(streamId => _this8._shimmedLocalStreams[streamId][0]);
          };

          const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
          window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
            if (!stream) {
              return origAddTrack.apply(this, arguments);
            }
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};

            const sender = origAddTrack.apply(this, arguments);
            if (!this._shimmedLocalStreams[stream.id]) {
              this._shimmedLocalStreams[stream.id] = [stream, sender];
            } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
              this._shimmedLocalStreams[stream.id].push(sender);
            }
            return sender;
          };

          const origAddStream = window.RTCPeerConnection.prototype.addStream;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            const _this9 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};

            stream.getTracks().forEach((track) => {
              const alreadyExists = _this9.getSenders().find(s => s.track === track);
              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            });
            const existingSenders = this.getSenders();
            origAddStream.apply(this, arguments);
            const newSenders = this.getSenders().filter(newSender => existingSenders.indexOf(newSender) === -1);
            this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
          };

          const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            delete this._shimmedLocalStreams[stream.id];
            return origRemoveStream.apply(this, arguments);
          };

          const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
          window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
            const _this10 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            if (sender) {
              Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
                const idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);
                if (idx !== -1) {
                  _this10._shimmedLocalStreams[streamId].splice(idx, 1);
                }
                if (_this10._shimmedLocalStreams[streamId].length === 1) {
                  delete _this10._shimmedLocalStreams[streamId];
                }
              });
            }
            return origRemoveTrack.apply(this, arguments);
          };
        }

        function shimAddTrackRemoveTrack(window) {
          if (!window.RTCPeerConnection) {
            return;
          }
          const browserDetails = utils.detectBrowser(window);
          // shim addTrack and removeTrack.
          if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
            return shimAddTrackRemoveTrackWithNative(window);
          }

          // also shim pc.getLocalStreams when addTrack is shimmed
          // to return the original streams.
          const origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;
          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            const _this11 = this;

            const nativeStreams = origGetLocalStreams.apply(this);
            this._reverseStreams = this._reverseStreams || {};
            return nativeStreams.map(stream => _this11._reverseStreams[stream.id]);
          };

          const origAddStream = window.RTCPeerConnection.prototype.addStream;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            const _this12 = this;

            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};

            stream.getTracks().forEach((track) => {
              const alreadyExists = _this12.getSenders().find(s => s.track === track);
              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            });
            // Add identity mapping for consistency with addTrack.
            // Unless this is being used with a stream from addTrack.
            if (!this._reverseStreams[stream.id]) {
              const newStream = new window.MediaStream(stream.getTracks());
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              stream = newStream;
            }
            origAddStream.apply(this, [stream]);
          };

          const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};

            origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
            delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
            delete this._streams[stream.id];
          };

          window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
            const _this13 = this;

            if (this.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            }
            const streams = [].slice.call(arguments, 1);
            if (streams.length !== 1 || !streams[0].getTracks().find(t => t === track)) {
              // this is not fully correct but all we can manage without
              // [[associated MediaStreams]] internal slot.
              throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
            }

            const alreadyExists = this.getSenders().find(s => s.track === track);
            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }

            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};
            const oldStream = this._streams[stream.id];
            if (oldStream) {
              // this is using odd Chrome behaviour, use with caution:
              // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
              // Note: we rely on the high-level addTrack/dtmf shim to
              // create the sender with a dtmf sender.
              oldStream.addTrack(track);

              // Trigger ONN async.
              Promise.resolve().then(() => {
                _this13.dispatchEvent(new Event('negotiationneeded'));
              });
            } else {
              const newStream = new window.MediaStream([track]);
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              this.addStream(newStream);
            }
            return this.getSenders().find(s => s.track === track);
          };

          // replace the internal stream id with the external one and
          // vice versa.
          function replaceInternalStreamId(pc, description) {
            let sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach((internalId) => {
              const externalStream = pc._reverseStreams[internalId];
              const internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp,
            });
          }
          function replaceExternalStreamId(pc, description) {
            let sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach((internalId) => {
              const externalStream = pc._reverseStreams[internalId];
              const internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp,
            });
          }
          ['createOffer', 'createAnswer'].forEach((method) => {
            const nativeMethod = window.RTCPeerConnection.prototype[method];
            const methodObj = _defineProperty({}, method, function () {
              const _this14 = this;

              const args = arguments;
              const isLegacyCall = arguments.length && typeof arguments[0] === 'function';
              if (isLegacyCall) {
                return nativeMethod.apply(this, [function (description) {
                  const desc = replaceInternalStreamId(_this14, description);
                  args[0].apply(null, [desc]);
                }, function (err) {
                  if (args[1]) {
                    args[1].apply(null, err);
                  }
                }, arguments[2]]);
              }
              return nativeMethod.apply(this, arguments).then(description => replaceInternalStreamId(_this14, description));
            });
            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });

          const origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;
          window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
            if (!arguments.length || !arguments[0].type) {
              return origSetLocalDescription.apply(this, arguments);
            }
            arguments[0] = replaceExternalStreamId(this, arguments[0]);
            return origSetLocalDescription.apply(this, arguments);
          };

          // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

          const origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
          Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
            get: function get() {
              const description = origLocalDescription.get.apply(this);
              if (description.type === '') {
                return description;
              }
              return replaceInternalStreamId(this, description);
            },
          });

          window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
            const _this15 = this;

            if (this.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            }
            // We can not yet check for sender instanceof RTCRtpSender
            // since we shim RTPSender. So we check if sender._pc is set.
            if (!sender._pc) {
              throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
            }
            const isLocal = sender._pc === this;
            if (!isLocal) {
              throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
            }

            // Search for the native stream the senders track belongs to.
            this._streams = this._streams || {};
            let stream = void 0;
            Object.keys(this._streams).forEach((streamid) => {
              const hasTrack = _this15._streams[streamid].getTracks().find(track => sender.track === track);
              if (hasTrack) {
                stream = _this15._streams[streamid];
              }
            });

            if (stream) {
              if (stream.getTracks().length === 1) {
                // if this is the last track of the stream, remove the stream. This
                // takes care of any shimmed _senders.
                this.removeStream(this._reverseStreams[stream.id]);
              } else {
                // relying on the same odd chrome behaviour as above.
                stream.removeTrack(sender.track);
              }
              this.dispatchEvent(new Event('negotiationneeded'));
            }
          };
        }

        function shimPeerConnection(window) {
          const browserDetails = utils.detectBrowser(window);

          if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.webkitRTCPeerConnection;
          }
          if (!window.RTCPeerConnection) {
            return;
          }

          // shim implicit creation of RTCSessionDescription/RTCIceCandidate
          if (browserDetails.version < 53) {
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach((method) => {
              const nativeMethod = window.RTCPeerConnection.prototype[method];
              const methodObj = _defineProperty({}, method, function () {
                arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                return nativeMethod.apply(this, arguments);
              });
              window.RTCPeerConnection.prototype[method] = methodObj[method];
            });
          }

          // support for addIceCandidate(null or undefined)
          const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
          window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
            if (!arguments[0]) {
              if (arguments[1]) {
                arguments[1].apply(null);
              }
              return Promise.resolve();
            }
            // Firefox 68+ emits and processes {candidate: "", ...}, ignore
            // in older versions. Native support planned for Chrome M77.
            if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
              return Promise.resolve();
            }
            return nativeAddIceCandidate.apply(this, arguments);
          };
        }

        function fixNegotiationNeeded(window) {
          utils.wrapPeerConnectionEvent(window, 'negotiationneeded', (e) => {
            const pc = e.target;
            if (pc.signalingState !== 'stable') {
              return;
            }
            return e;
          });
        }
      }, { '../utils.js': 15, './getdisplaymedia': 4, './getusermedia': 5 }],
      4: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shimGetDisplayMedia = shimGetDisplayMedia;
        function shimGetDisplayMedia(window, getSourceId) {
          if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }
          if (!window.navigator.mediaDevices) {
            return;
          }
          // getSourceId is a function that returns a promise resolving with
          // the sourceId of the screen/window/tab to be shared.
          if (typeof getSourceId !== 'function') {
            console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
            return;
          }
          window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
            return getSourceId(constraints).then((sourceId) => {
              const widthSpecified = constraints.video && constraints.video.width;
              const heightSpecified = constraints.video && constraints.video.height;
              const frameRateSpecified = constraints.video && constraints.video.frameRate;
              constraints.video = {
                mandatory: {
                  chromeMediaSource: 'desktop',
                  chromeMediaSourceId: sourceId,
                  maxFrameRate: frameRateSpecified || 3,
                },
              };
              if (widthSpecified) {
                constraints.video.mandatory.maxWidth = widthSpecified;
              }
              if (heightSpecified) {
                constraints.video.mandatory.maxHeight = heightSpecified;
              }
              return window.navigator.mediaDevices.getUserMedia(constraints);
            });
          };
        }
      }, {}],
      5: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

        exports.shimGetUserMedia = shimGetUserMedia;

        const _utils = require('../utils.js');

        const utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        const logging = utils.log;

        function shimGetUserMedia(window) {
          const navigator = window && window.navigator;

          if (!navigator.mediaDevices) {
            return;
          }

          const browserDetails = utils.detectBrowser(window);

          const constraintsToChrome_ = function constraintsToChrome_(c) {
            if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
              return c;
            }
            const cc = {};
            Object.keys(c).forEach((key) => {
              if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
                return;
              }
              const r = _typeof(c[key]) === 'object' ? c[key] : { ideal: c[key] };
              if (r.exact !== undefined && typeof r.exact === 'number') {
                r.min = r.max = r.exact;
              }
              const oldname_ = function oldname_(prefix, name) {
                if (prefix) {
                  return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                }
                return name === 'deviceId' ? 'sourceId' : name;
              };
              if (r.ideal !== undefined) {
                cc.optional = cc.optional || [];
                let oc = {};
                if (typeof r.ideal === 'number') {
                  oc[oldname_('min', key)] = r.ideal;
                  cc.optional.push(oc);
                  oc = {};
                  oc[oldname_('max', key)] = r.ideal;
                  cc.optional.push(oc);
                } else {
                  oc[oldname_('', key)] = r.ideal;
                  cc.optional.push(oc);
                }
              }
              if (r.exact !== undefined && typeof r.exact !== 'number') {
                cc.mandatory = cc.mandatory || {};
                cc.mandatory[oldname_('', key)] = r.exact;
              } else {
                ['min', 'max'].forEach((mix) => {
                  if (r[mix] !== undefined) {
                    cc.mandatory = cc.mandatory || {};
                    cc.mandatory[oldname_(mix, key)] = r[mix];
                  }
                });
              }
            });
            if (c.advanced) {
              cc.optional = (cc.optional || []).concat(c.advanced);
            }
            return cc;
          };

          const shimConstraints_ = function shimConstraints_(constraints, func) {
            if (browserDetails.version >= 61) {
              return func(constraints);
            }
            constraints = JSON.parse(JSON.stringify(constraints));
            if (constraints && _typeof(constraints.audio) === 'object') {
              const remap = function remap(obj, a, b) {
                if (a in obj && !(b in obj)) {
                  obj[b] = obj[a];
                  delete obj[a];
                }
              };
              constraints = JSON.parse(JSON.stringify(constraints));
              remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
              remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
              constraints.audio = constraintsToChrome_(constraints.audio);
            }
            if (constraints && _typeof(constraints.video) === 'object') {
              // Shim facingMode for mobile & surface pro.
              let face = constraints.video.facingMode;
              face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : { ideal: face });
              const getSupportedFacingModeLies = browserDetails.version < 66;

              if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
                delete constraints.video.facingMode;
                let matches = void 0;
                if (face.exact === 'environment' || face.ideal === 'environment') {
                  matches = ['back', 'rear'];
                } else if (face.exact === 'user' || face.ideal === 'user') {
                  matches = ['front'];
                }
                if (matches) {
                  // Look for matches in label, or use last cam for back (typical).
                  return navigator.mediaDevices.enumerateDevices().then((devices) => {
                    devices = devices.filter(d => d.kind === 'videoinput');
                    let dev = devices.find(d => matches.some(match => d.label.toLowerCase().includes(match)));
                    if (!dev && devices.length && matches.includes('back')) {
                      dev = devices[devices.length - 1]; // more likely the back cam
                    }
                    if (dev) {
                      constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
                    }
                    constraints.video = constraintsToChrome_(constraints.video);
                    logging(`chrome: ${JSON.stringify(constraints)}`);
                    return func(constraints);
                  });
                }
              }
              constraints.video = constraintsToChrome_(constraints.video);
            }
            logging(`chrome: ${JSON.stringify(constraints)}`);
            return func(constraints);
          };

          const shimError_ = function shimError_(e) {
            if (browserDetails.version >= 64) {
              return e;
            }
            return {
              name: {
                PermissionDeniedError: 'NotAllowedError',
                PermissionDismissedError: 'NotAllowedError',
                InvalidStateError: 'NotAllowedError',
                DevicesNotFoundError: 'NotFoundError',
                ConstraintNotSatisfiedError: 'OverconstrainedError',
                TrackStartError: 'NotReadableError',
                MediaDeviceFailedDueToShutdown: 'NotAllowedError',
                MediaDeviceKillSwitchOn: 'NotAllowedError',
                TabCaptureError: 'AbortError',
                ScreenCaptureError: 'AbortError',
                DeviceCaptureError: 'AbortError',
              }[e.name] || e.name,
              message: e.message,
              constraint: e.constraint || e.constraintName,
              toString: function toString() {
                return this.name + (this.message && ': ') + this.message;
              },
            };
          };

          const getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
            shimConstraints_(constraints, (c) => {
              navigator.webkitGetUserMedia(c, onSuccess, (e) => {
                if (onError) {
                  onError(shimError_(e));
                }
              });
            });
          };
          navigator.getUserMedia = getUserMedia_.bind(navigator);

          // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
          // function which returns a Promise, it does not accept spec-style
          // constraints.
          if (navigator.mediaDevices.getUserMedia) {
            const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function (cs) {
              return shimConstraints_(cs, c => origGetUserMedia(c).then((stream) => {
                if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                  stream.getTracks().forEach((track) => {
                    track.stop();
                  });
                  throw new DOMException('', 'NotFoundError');
                }
                return stream;
              }, e => Promise.reject(shimError_(e))));
            };
          }
        }
      }, { '../utils.js': 15 }],
      6: [function (require, module, exports) {
        /*
         *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

        exports.shimRTCIceCandidate = shimRTCIceCandidate;
        exports.shimMaxMessageSize = shimMaxMessageSize;
        exports.shimSendThrowTypeError = shimSendThrowTypeError;
        exports.shimConnectionState = shimConnectionState;
        exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

        const _sdp = require('sdp');

        const _sdp2 = _interopRequireDefault(_sdp);

        const _utils = require('./utils');

        const utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function shimRTCIceCandidate(window) {
          // foundation is arbitrarily chosen as an indicator for full support for
          // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
          if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
            return;
          }

          const NativeRTCIceCandidate = window.RTCIceCandidate;
          window.RTCIceCandidate = function RTCIceCandidate(args) {
            // Remove the a= which shouldn't be part of the candidate string.
            if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
              args = JSON.parse(JSON.stringify(args));
              args.candidate = args.candidate.substr(2);
            }

            if (args.candidate && args.candidate.length) {
              // Augment the native candidate with the parsed fields.
              const nativeCandidate = new NativeRTCIceCandidate(args);
              const parsedCandidate = _sdp2.default.parseCandidate(args.candidate);
              const augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate);

              // Add a serializer that does not serialize the extra attributes.
              augmentedCandidate.toJSON = function toJSON() {
                return {
                  candidate: augmentedCandidate.candidate,
                  sdpMid: augmentedCandidate.sdpMid,
                  sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                  usernameFragment: augmentedCandidate.usernameFragment,
                };
              };
              return augmentedCandidate;
            }
            return new NativeRTCIceCandidate(args);
          };
          window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

          // Hook up the augmented candidate in onicecandidate and
          // addEventListener('icecandidate', ...)
          utils.wrapPeerConnectionEvent(window, 'icecandidate', (e) => {
            if (e.candidate) {
              Object.defineProperty(e, 'candidate', {
                value: new window.RTCIceCandidate(e.candidate),
                writable: 'false',
              });
            }
            return e;
          });
        }

        function shimMaxMessageSize(window) {
          if (!window.RTCPeerConnection) {
            return;
          }
          const browserDetails = utils.detectBrowser(window);

          if (!('sctp' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
              get: function get() {
                return typeof this._sctp === 'undefined' ? null : this._sctp;
              },
            });
          }

          const sctpInDescription = function sctpInDescription(description) {
            if (!description || !description.sdp) {
              return false;
            }
            const sections = _sdp2.default.splitSections(description.sdp);
            sections.shift();
            return sections.some((mediaSection) => {
              const mLine = _sdp2.default.parseMLine(mediaSection);
              return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
            });
          };

          const getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
            // TODO: Is there a better solution for detecting Firefox?
            const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
            if (match === null || match.length < 2) {
              return -1;
            }
            const version = parseInt(match[1], 10);
            // Test for NaN (yes, this is ugly)
            return version !== version ? -1 : version;
          };

          const getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
            // Every implementation we know can send at least 64 KiB.
            // Note: Although Chrome is technically able to send up to 256 KiB, the
            //       data does not reach the other peer reliably.
            //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
            let canSendMaxMessageSize = 65536;
            if (browserDetails.browser === 'firefox') {
              if (browserDetails.version < 57) {
                if (remoteIsFirefox === -1) {
                  // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                  // fragmentation.
                  canSendMaxMessageSize = 16384;
                } else {
                  // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                  // messages. Thus, supporting ~2 GiB when sending.
                  canSendMaxMessageSize = 2147483637;
                }
              } else if (browserDetails.version < 60) {
                // Currently, all FF >= 57 will reset the remote maximum message size
                // to the default value when a data channel is created at a later
                // stage. :(
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
              } else {
                // FF >= 60 supports sending ~2 GiB
                canSendMaxMessageSize = 2147483637;
              }
            }
            return canSendMaxMessageSize;
          };

          const getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
            // Note: 65536 bytes is the default value from the SDP spec. Also,
            //       every implementation we know supports receiving 65536 bytes.
            let maxMessageSize = 65536;

            // FF 57 has a slightly incorrect default remote max message size, so
            // we need to adjust it here to avoid a failure when sending.
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
            if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
              maxMessageSize = 65535;
            }

            const match = _sdp2.default.matchPrefix(description.sdp, 'a=max-message-size:');
            if (match.length > 0) {
              maxMessageSize = parseInt(match[0].substr(19), 10);
            } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
              // If the maximum message size is not present in the remote SDP and
              // both local and remote are Firefox, the remote peer can receive
              // ~2 GiB.
              maxMessageSize = 2147483637;
            }
            return maxMessageSize;
          };

          const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
            this._sctp = null;
            // Chrome decided to not expose .sctp in plan-b mode.
            // As usual, adapter.js has to do an 'ugly worakaround'
            // to cover up the mess.
            if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
              let _getConfiguration = this.getConfiguration(),
                sdpSemantics = _getConfiguration.sdpSemantics;

              if (sdpSemantics === 'plan-b') {
                Object.defineProperty(this, 'sctp', {
                  get: function get() {
                    return typeof this._sctp === 'undefined' ? null : this._sctp;
                  },

                  enumerable: true,
                  configurable: true,
                });
              }
            }

            if (sctpInDescription(arguments[0])) {
              // Check if the remote is FF.
              const isFirefox = getRemoteFirefoxVersion(arguments[0]);

              // Get the maximum message size the local peer is capable of sending
              const canSendMMS = getCanSendMaxMessageSize(isFirefox);

              // Get the maximum message size of the remote peer.
              const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

              // Determine final maximum message size
              let maxMessageSize = void 0;
              if (canSendMMS === 0 && remoteMMS === 0) {
                maxMessageSize = Number.POSITIVE_INFINITY;
              } else if (canSendMMS === 0 || remoteMMS === 0) {
                maxMessageSize = Math.max(canSendMMS, remoteMMS);
              } else {
                maxMessageSize = Math.min(canSendMMS, remoteMMS);
              }

              // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
              // attribute.
              const sctp = {};
              Object.defineProperty(sctp, 'maxMessageSize', {
                get: function get() {
                  return maxMessageSize;
                },
              });
              this._sctp = sctp;
            }

            return origSetRemoteDescription.apply(this, arguments);
          };
        }

        function shimSendThrowTypeError(window) {
          if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
            return;
          }

          // Note: Although Firefox >= 57 has a native implementation, the maximum
          //       message size can be reset for all data channels at a later stage.
          //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

          function wrapDcSend(dc, pc) {
            const origDataChannelSend = dc.send;
            dc.send = function send() {
              const data = arguments[0];
              const length = data.length || data.size || data.byteLength;
              if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
                throw new TypeError(`Message too large (can send a maximum of ${pc.sctp.maxMessageSize} bytes)`);
              }
              return origDataChannelSend.apply(dc, arguments);
            };
          }
          const origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;
          window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
            const dataChannel = origCreateDataChannel.apply(this, arguments);
            wrapDcSend(dataChannel, this);
            return dataChannel;
          };
          utils.wrapPeerConnectionEvent(window, 'datachannel', (e) => {
            wrapDcSend(e.channel, e.target);
            return e;
          });
        }

        /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
         * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
         * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
         * since DTLS failures would be hidden. See
         * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
         * for the Firefox tracking bug.
         */
        function shimConnectionState(window) {
          if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
            return;
          }
          const proto = window.RTCPeerConnection.prototype;
          Object.defineProperty(proto, 'connectionState', {
            get: function get() {
              return {
                completed: 'connected',
                checking: 'connecting',
              }[this.iceConnectionState] || this.iceConnectionState;
            },

            enumerable: true,
            configurable: true,
          });
          Object.defineProperty(proto, 'onconnectionstatechange', {
            get: function get() {
              return this._onconnectionstatechange || null;
            },
            set: function set(cb) {
              if (this._onconnectionstatechange) {
                this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
                delete this._onconnectionstatechange;
              }
              if (cb) {
                this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
              }
            },

            enumerable: true,
            configurable: true,
          });

          ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {
            const origMethod = proto[method];
            proto[method] = function () {
              if (!this._connectionstatechangepoly) {
                this._connectionstatechangepoly = function (e) {
                  const pc = e.target;
                  if (pc._lastConnectionState !== pc.connectionState) {
                    pc._lastConnectionState = pc.connectionState;
                    const newEvent = new Event('connectionstatechange', e);
                    pc.dispatchEvent(newEvent);
                  }
                  return e;
                };
                this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
              }
              return origMethod.apply(this, arguments);
            };
          });
        }

        function removeAllowExtmapMixed(window) {
          /* remove a=extmap-allow-mixed for Chrome < M71 */
          if (!window.RTCPeerConnection) {
            return;
          }
          const browserDetails = utils.detectBrowser(window);
          if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
            return;
          }
          const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
            if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
              desc.sdp = desc.sdp.split('\n').filter(line => line.trim() !== 'a=extmap-allow-mixed').join('\n');
            }
            return nativeSRD.apply(this, arguments);
          };
        }
      }, { './utils': 15, sdp: 17 }],
      7: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

        const _getusermedia = require('./getusermedia');

        Object.defineProperty(exports, 'shimGetUserMedia', {
          enumerable: true,
          get: function get() {
            return _getusermedia.shimGetUserMedia;
          },
        });

        const _getdisplaymedia = require('./getdisplaymedia');

        Object.defineProperty(exports, 'shimGetDisplayMedia', {
          enumerable: true,
          get: function get() {
            return _getdisplaymedia.shimGetDisplayMedia;
          },
        });
        exports.shimPeerConnection = shimPeerConnection;
        exports.shimReplaceTrack = shimReplaceTrack;

        const _utils = require('../utils');

        const utils = _interopRequireWildcard(_utils);

        const _filtericeservers = require('./filtericeservers');

        const _rtcpeerconnectionShim = require('rtcpeerconnection-shim');

        const _rtcpeerconnectionShim2 = _interopRequireDefault(_rtcpeerconnectionShim);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        function shimPeerConnection(window) {
          const browserDetails = utils.detectBrowser(window);

          if (window.RTCIceGatherer) {
            if (!window.RTCIceCandidate) {
              window.RTCIceCandidate = function RTCIceCandidate(args) {
                return args;
              };
            }
            if (!window.RTCSessionDescription) {
              window.RTCSessionDescription = function RTCSessionDescription(args) {
                return args;
              };
            }
            // this adds an additional event listener to MediaStrackTrack that signals
            // when a tracks enabled property was changed. Workaround for a bug in
            // addStream, see below. No longer required in 15025+
            if (browserDetails.version < 15025) {
              const origMSTEnabled = Object.getOwnPropertyDescriptor(window.MediaStreamTrack.prototype, 'enabled');
              Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
                set: function set(value) {
                  origMSTEnabled.set.call(this, value);
                  const ev = new Event('enabled');
                  ev.enabled = value;
                  this.dispatchEvent(ev);
                },
              });
            }
          }

          // ORTC defines the DTMF sender a bit different.
          // https://github.com/w3c/ortc/issues/714
          if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
            Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
              get: function get() {
                if (this._dtmf === undefined) {
                  if (this.track.kind === 'audio') {
                    this._dtmf = new window.RTCDtmfSender(this);
                  } else if (this.track.kind === 'video') {
                    this._dtmf = null;
                  }
                }
                return this._dtmf;
              },
            });
          }
          // Edge currently only implements the RTCDtmfSender, not the
          // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
          if (window.RTCDtmfSender && !window.RTCDTMFSender) {
            window.RTCDTMFSender = window.RTCDtmfSender;
          }

          const RTCPeerConnectionShim = (0, _rtcpeerconnectionShim2.default)(window, browserDetails.version);
          window.RTCPeerConnection = function RTCPeerConnection(config) {
            if (config && config.iceServers) {
              config.iceServers = (0, _filtericeservers.filterIceServers)(config.iceServers, browserDetails.version);
              utils.log('ICE servers after filtering:', config.iceServers);
            }
            return new RTCPeerConnectionShim(config);
          };
          window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
        }

        function shimReplaceTrack(window) {
          // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
          if (window.RTCRtpSender && !('replaceTrack' in window.RTCRtpSender.prototype)) {
            window.RTCRtpSender.prototype.replaceTrack = window.RTCRtpSender.prototype.setTrack;
          }
        }
      }, {
        '../utils': 15, './filtericeservers': 8, './getdisplaymedia': 9, './getusermedia': 10, 'rtcpeerconnection-shim': 16,
      }],
      8: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.filterIceServers = filterIceServers;

        const _utils = require('../utils');

        const utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        // Edge does not like
        // 1) stun: filtered after 14393 unless ?transport=udp is present
        // 2) turn: that does not have all of turn:host:port?transport=udp
        // 3) turn: with ipv6 addresses
        // 4) turn: occurring muliple times
        function filterIceServers(iceServers, edgeVersion) {
          let hasTurn = false;
          iceServers = JSON.parse(JSON.stringify(iceServers));
          return iceServers.filter((server) => {
            if (server && (server.urls || server.url)) {
              let urls = server.urls || server.url;
              if (server.url && !server.urls) {
                utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              }
              const isString = typeof urls === 'string';
              if (isString) {
                urls = [urls];
              }
              urls = urls.filter((url) => {
                // filter STUN unconditionally.
                if (url.indexOf('stun:') === 0) {
                  return false;
                }

                const validTurn = url.startsWith('turn') && !url.startsWith('turn:[') && url.includes('transport=udp');
                if (validTurn && !hasTurn) {
                  hasTurn = true;
                  return true;
                }
                return validTurn && !hasTurn;
              });

              delete server.url;
              server.urls = isString ? urls[0] : urls;
              return !!urls.length;
            }
          });
        }
      }, { '../utils': 15 }],
      9: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shimGetDisplayMedia = shimGetDisplayMedia;
        function shimGetDisplayMedia(window) {
          if (!('getDisplayMedia' in window.navigator)) {
            return;
          }
          if (!window.navigator.mediaDevices) {
            return;
          }
          if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }
          window.navigator.mediaDevices.getDisplayMedia = window.navigator.getDisplayMedia.bind(window.navigator);
        }
      }, {}],
      10: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shimGetUserMedia = shimGetUserMedia;
        function shimGetUserMedia(window) {
          const navigator = window && window.navigator;

          const shimError_ = function shimError_(e) {
            return {
              name: { PermissionDeniedError: 'NotAllowedError' }[e.name] || e.name,
              message: e.message,
              constraint: e.constraint,
              toString: function toString() {
                return this.name;
              },
            };
          };

          // getUserMedia error shim.
          const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
          navigator.mediaDevices.getUserMedia = function (c) {
            return origGetUserMedia(c).catch(e => Promise.reject(shimError_(e)));
          };
        }
      }, {}],
      11: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

        const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

        const _getusermedia = require('./getusermedia');

        Object.defineProperty(exports, 'shimGetUserMedia', {
          enumerable: true,
          get: function get() {
            return _getusermedia.shimGetUserMedia;
          },
        });

        const _getdisplaymedia = require('./getdisplaymedia');

        Object.defineProperty(exports, 'shimGetDisplayMedia', {
          enumerable: true,
          get: function get() {
            return _getdisplaymedia.shimGetDisplayMedia;
          },
        });
        exports.shimOnTrack = shimOnTrack;
        exports.shimPeerConnection = shimPeerConnection;
        exports.shimSenderGetStats = shimSenderGetStats;
        exports.shimReceiverGetStats = shimReceiverGetStats;
        exports.shimRemoveStream = shimRemoveStream;
        exports.shimRTCDataChannel = shimRTCDataChannel;

        const _utils = require('../utils');

        const utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value, enumerable: true, configurable: true, writable: true,
            });
          } else { obj[key] = value; } return obj;
        }

        function shimOnTrack(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function get() {
                return { receiver: this.receiver };
              },
            });
          }
        }

        function shimPeerConnection(window) {
          const browserDetails = utils.detectBrowser(window);

          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
            return; // probably media.peerconnection.enabled=false in about:config
          }
          if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.mozRTCPeerConnection;
          }

          if (browserDetails.version < 53) {
            // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach((method) => {
              const nativeMethod = window.RTCPeerConnection.prototype[method];
              const methodObj = _defineProperty({}, method, function () {
                arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                return nativeMethod.apply(this, arguments);
              });
              window.RTCPeerConnection.prototype[method] = methodObj[method];
            });
          }

          // support for addIceCandidate(null or undefined)
          // as well as ignoring {sdpMid, candidate: ""}
          if (browserDetails.version < 68) {
            const nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;
            window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
              if (!arguments[0]) {
                if (arguments[1]) {
                  arguments[1].apply(null);
                }
                return Promise.resolve();
              }
              // Firefox 68+ emits and processes {candidate: "", ...}, ignore
              // in older versions.
              if (arguments[0] && arguments[0].candidate === '') {
                return Promise.resolve();
              }
              return nativeAddIceCandidate.apply(this, arguments);
            };
          }

          const modernStatsTypes = {
            inboundrtp: 'inbound-rtp',
            outboundrtp: 'outbound-rtp',
            candidatepair: 'candidate-pair',
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate',
          };

          const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
          window.RTCPeerConnection.prototype.getStats = function getStats() {
            let _arguments = Array.prototype.slice.call(arguments),
              selector = _arguments[0],
              onSucc = _arguments[1],
              onErr = _arguments[2];

            return nativeGetStats.apply(this, [selector || null]).then((stats) => {
              if (browserDetails.version < 53 && !onSucc) {
                // Shim only promise getStats with spec-hyphens in type names
                // Leave callback version alone; misc old uses of forEach before Map
                try {
                  stats.forEach((stat) => {
                    stat.type = modernStatsTypes[stat.type] || stat.type;
                  });
                } catch (e) {
                  if (e.name !== 'TypeError') {
                    throw e;
                  }
                  // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
                  stats.forEach((stat, i) => {
                    stats.set(i, Object.assign({}, stat, {
                      type: modernStatsTypes[stat.type] || stat.type,
                    }));
                  });
                }
              }
              return stats;
            }).then(onSucc, onErr);
          };
        }

        function shimSenderGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
            return;
          }
          if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
            return;
          }
          const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          if (origGetSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              const _this = this;

              const senders = origGetSenders.apply(this, []);
              senders.forEach(sender => sender._pc = _this);
              return senders;
            };
          }

          const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
          if (origAddTrack) {
            window.RTCPeerConnection.prototype.addTrack = function addTrack() {
              const sender = origAddTrack.apply(this, arguments);
              sender._pc = this;
              return sender;
            };
          }
          window.RTCRtpSender.prototype.getStats = function getStats() {
            return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
          };
        }

        function shimReceiverGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
            return;
          }
          if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
            return;
          }
          const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
          if (origGetReceivers) {
            window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
              const _this2 = this;

              const receivers = origGetReceivers.apply(this, []);
              receivers.forEach(receiver => receiver._pc = _this2);
              return receivers;
            };
          }
          utils.wrapPeerConnectionEvent(window, 'track', (e) => {
            e.receiver._pc = e.srcElement;
            return e;
          });
          window.RTCRtpReceiver.prototype.getStats = function getStats() {
            return this._pc.getStats(this.track);
          };
        }

        function shimRemoveStream(window) {
          if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
            return;
          }
          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            const _this3 = this;

            utils.deprecated('removeStream', 'removeTrack');
            this.getSenders().forEach((sender) => {
              if (sender.track && stream.getTracks().includes(sender.track)) {
                _this3.removeTrack(sender);
              }
            });
          };
        }

        function shimRTCDataChannel(window) {
          // rename DataChannel to RTCDataChannel (native fix in FF60):
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
          if (window.DataChannel && !window.RTCDataChannel) {
            window.RTCDataChannel = window.DataChannel;
          }
        }
      }, { '../utils': 15, './getdisplaymedia': 12, './getusermedia': 13 }],
      12: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });
        exports.shimGetDisplayMedia = shimGetDisplayMedia;
        function shimGetDisplayMedia(window, preferredMediaSource) {
          if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }
          if (!window.navigator.mediaDevices) {
            return;
          }
          window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
            if (!(constraints && constraints.video)) {
              const err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
              err.name = 'NotFoundError';
              // from https://heycam.github.io/webidl/#idl-DOMException-error-names
              err.code = 8;
              return Promise.reject(err);
            }
            if (constraints.video === true) {
              constraints.video = { mediaSource: preferredMediaSource };
            } else {
              constraints.video.mediaSource = preferredMediaSource;
            }
            return window.navigator.mediaDevices.getUserMedia(constraints);
          };
        }
      }, {}],
      13: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

        exports.shimGetUserMedia = shimGetUserMedia;

        const _utils = require('../utils');

        const utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        function shimGetUserMedia(window) {
          const browserDetails = utils.detectBrowser(window);
          const navigator = window && window.navigator;
          const MediaStreamTrack = window && window.MediaStreamTrack;

          navigator.getUserMedia = function (constraints, onSuccess, onError) {
            // Replace Firefox 44+'s deprecation warning with unprefixed version.
            utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
            navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
          };

          if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
            const remap = function remap(obj, a, b) {
              if (a in obj && !(b in obj)) {
                obj[b] = obj[a];
                delete obj[a];
              }
            };

            const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function (c) {
              if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
                c = JSON.parse(JSON.stringify(c));
                remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
                remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
              }
              return nativeGetUserMedia(c);
            };

            if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
              const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
              MediaStreamTrack.prototype.getSettings = function () {
                const obj = nativeGetSettings.apply(this, arguments);
                remap(obj, 'mozAutoGainControl', 'autoGainControl');
                remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
                return obj;
              };
            }

            if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
              const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
              MediaStreamTrack.prototype.applyConstraints = function (c) {
                if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
                  c = JSON.parse(JSON.stringify(c));
                  remap(c, 'autoGainControl', 'mozAutoGainControl');
                  remap(c, 'noiseSuppression', 'mozNoiseSuppression');
                }
                return nativeApplyConstraints.apply(this, [c]);
              };
            }
          }
        }
      }, { '../utils': 15 }],
      14: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

        exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
        exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
        exports.shimCallbacksAPI = shimCallbacksAPI;
        exports.shimGetUserMedia = shimGetUserMedia;
        exports.shimConstraints = shimConstraints;
        exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
        exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
        exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

        const _utils = require('../utils');

        const utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } const newObj = {}; if (obj != null) { for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; }

        function shimLocalStreamsAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }
          if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
              if (!this._localStreams) {
                this._localStreams = [];
              }
              return this._localStreams;
            };
          }
          if (!('addStream' in window.RTCPeerConnection.prototype)) {
            const _addTrack = window.RTCPeerConnection.prototype.addTrack;
            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              const _this = this;

              if (!this._localStreams) {
                this._localStreams = [];
              }
              if (!this._localStreams.includes(stream)) {
                this._localStreams.push(stream);
              }
              // Try to emulate Chrome's behaviour of adding in audio-video order.
              // Safari orders by track id.
              stream.getAudioTracks().forEach(track => _addTrack.call(_this, track, stream));
              stream.getVideoTracks().forEach(track => _addTrack.call(_this, track, stream));
            };

            window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
              const stream = arguments[1];
              if (stream) {
                if (!this._localStreams) {
                  this._localStreams = [stream];
                } else if (!this._localStreams.includes(stream)) {
                  this._localStreams.push(stream);
                }
              }
              return _addTrack.apply(this, arguments);
            };
          }
          if (!('removeStream' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
              const _this2 = this;

              if (!this._localStreams) {
                this._localStreams = [];
              }
              const index = this._localStreams.indexOf(stream);
              if (index === -1) {
                return;
              }
              this._localStreams.splice(index, 1);
              const tracks = stream.getTracks();
              this.getSenders().forEach((sender) => {
                if (tracks.includes(sender.track)) {
                  _this2.removeTrack(sender);
                }
              });
            };
          }
        }

        function shimRemoteStreamsAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }
          if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
              return this._remoteStreams ? this._remoteStreams : [];
            };
          }
          if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
              get: function get() {
                return this._onaddstream;
              },
              set: function set(f) {
                const _this3 = this;

                if (this._onaddstream) {
                  this.removeEventListener('addstream', this._onaddstream);
                  this.removeEventListener('track', this._onaddstreampoly);
                }
                this.addEventListener('addstream', this._onaddstream = f);
                this.addEventListener('track', this._onaddstreampoly = function (e) {
                  e.streams.forEach((stream) => {
                    if (!_this3._remoteStreams) {
                      _this3._remoteStreams = [];
                    }
                    if (_this3._remoteStreams.includes(stream)) {
                      return;
                    }
                    _this3._remoteStreams.push(stream);
                    const event = new Event('addstream');
                    event.stream = stream;
                    _this3.dispatchEvent(event);
                  });
                });
              },
            });
            const origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;
            window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              const pc = this;
              if (!this._onaddstreampoly) {
                this.addEventListener('track', this._onaddstreampoly = function (e) {
                  e.streams.forEach((stream) => {
                    if (!pc._remoteStreams) {
                      pc._remoteStreams = [];
                    }
                    if (pc._remoteStreams.indexOf(stream) >= 0) {
                      return;
                    }
                    pc._remoteStreams.push(stream);
                    const event = new Event('addstream');
                    event.stream = stream;
                    pc.dispatchEvent(event);
                  });
                });
              }
              return origSetRemoteDescription.apply(pc, arguments);
            };
          }
        }

        function shimCallbacksAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }
          const prototype = window.RTCPeerConnection.prototype;
          const origCreateOffer = prototype.createOffer;
          const origCreateAnswer = prototype.createAnswer;
          const setLocalDescription = prototype.setLocalDescription;
          const setRemoteDescription = prototype.setRemoteDescription;
          const addIceCandidate = prototype.addIceCandidate;

          prototype.createOffer = function createOffer(successCallback, failureCallback) {
            const options = arguments.length >= 2 ? arguments[2] : arguments[0];
            const promise = origCreateOffer.apply(this, [options]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
            const options = arguments.length >= 2 ? arguments[2] : arguments[0];
            const promise = origCreateAnswer.apply(this, [options]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          let withCallback = function withCallback(description, successCallback, failureCallback) {
            const promise = setLocalDescription.apply(this, [description]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };
          prototype.setLocalDescription = withCallback;

          withCallback = function withCallback(description, successCallback, failureCallback) {
            const promise = setRemoteDescription.apply(this, [description]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };
          prototype.setRemoteDescription = withCallback;

          withCallback = function withCallback(candidate, successCallback, failureCallback) {
            const promise = addIceCandidate.apply(this, [candidate]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };
          prototype.addIceCandidate = withCallback;
        }

        function shimGetUserMedia(window) {
          const navigator = window && window.navigator;

          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            // shim not needed in Safari 12.1
            const mediaDevices = navigator.mediaDevices;
            const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
            navigator.mediaDevices.getUserMedia = function (constraints) {
              return _getUserMedia(shimConstraints(constraints));
            };
          }

          if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
              navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
            };
          }
        }

        function shimConstraints(constraints) {
          if (constraints && constraints.video !== undefined) {
            return Object.assign({}, constraints, { video: utils.compactObject(constraints.video) });
          }

          return constraints;
        }

        function shimRTCIceServerUrls(window) {
          // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
          const OrigPeerConnection = window.RTCPeerConnection;
          window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
            if (pcConfig && pcConfig.iceServers) {
              const newIceServers = [];
              for (let i = 0; i < pcConfig.iceServers.length; i++) {
                let server = pcConfig.iceServers[i];
                if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                  utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                  server = JSON.parse(JSON.stringify(server));
                  server.urls = server.url;
                  delete server.url;
                  newIceServers.push(server);
                } else {
                  newIceServers.push(pcConfig.iceServers[i]);
                }
              }
              pcConfig.iceServers = newIceServers;
            }
            return new OrigPeerConnection(pcConfig, pcConstraints);
          };
          window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
          // wrap static methods. Currently just generateCertificate.
          if ('generateCertificate' in window.RTCPeerConnection) {
            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
              get: function get() {
                return OrigPeerConnection.generateCertificate;
              },
            });
          }
        }

        function shimTrackEventTransceiver(window) {
          // Add event.transceiver member over deprecated event.receiver
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function get() {
                return { receiver: this.receiver };
              },
            });
          }
        }

        function shimCreateOfferLegacy(window) {
          const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
          window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
            if (offerOptions) {
              if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
                // support bit values
                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
              }
              const audioTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'audio');
              if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
                if (audioTransceiver.direction === 'sendrecv') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('sendonly');
                  } else {
                    audioTransceiver.direction = 'sendonly';
                  }
                } else if (audioTransceiver.direction === 'recvonly') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('inactive');
                  } else {
                    audioTransceiver.direction = 'inactive';
                  }
                }
              } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
                this.addTransceiver('audio');
              }

              if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
                // support bit values
                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
              }
              const videoTransceiver = this.getTransceivers().find(transceiver => transceiver.receiver.track.kind === 'video');
              if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
                if (videoTransceiver.direction === 'sendrecv') {
                  if (videoTransceiver.setDirection) {
                    videoTransceiver.setDirection('sendonly');
                  } else {
                    videoTransceiver.direction = 'sendonly';
                  }
                } else if (videoTransceiver.direction === 'recvonly') {
                  if (videoTransceiver.setDirection) {
                    videoTransceiver.setDirection('inactive');
                  } else {
                    videoTransceiver.direction = 'inactive';
                  }
                }
              } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
                this.addTransceiver('video');
              }
            }
            return origCreateOffer.apply(this, arguments);
          };
        }
      }, { '../utils': 15 }],
      15: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        Object.defineProperty(exports, '__esModule', {
          value: true,
        });

        const _typeof = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : typeof obj; };

        exports.extractVersion = extractVersion;
        exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
        exports.disableLog = disableLog;
        exports.disableWarnings = disableWarnings;
        exports.log = log;
        exports.deprecated = deprecated;
        exports.detectBrowser = detectBrowser;
        exports.compactObject = compactObject;
        exports.walkStats = walkStats;
        exports.filterStats = filterStats;

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value, enumerable: true, configurable: true, writable: true,
            });
          } else { obj[key] = value; } return obj;
        }

        let logDisabled_ = true;
        let deprecationWarnings_ = true;

        /**
         * Extract browser version out of the provided user agent string.
         *
         * @param {!string} uastring userAgent string.
         * @param {!string} expr Regular expression used as match criteria.
         * @param {!number} pos position in the version string to be returned.
         * @return {!number} browser version.
         */
        function extractVersion(uastring, expr, pos) {
          const match = uastring.match(expr);
          return match && match.length >= pos && parseInt(match[pos], 10);
        }

        // Wraps the peerconnection event eventNameToWrap in a function
        // which returns the modified event object (or false to prevent
        // the event).
        function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
          if (!window.RTCPeerConnection) {
            return;
          }
          const proto = window.RTCPeerConnection.prototype;
          const nativeAddEventListener = proto.addEventListener;
          proto.addEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap) {
              return nativeAddEventListener.apply(this, arguments);
            }
            const wrappedCallback = function wrappedCallback(e) {
              const modifiedEvent = wrapper(e);
              if (modifiedEvent) {
                cb(modifiedEvent);
              }
            };
            this._eventMap = this._eventMap || {};
            this._eventMap[cb] = wrappedCallback;
            return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
          };

          const nativeRemoveEventListener = proto.removeEventListener;
          proto.removeEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
              return nativeRemoveEventListener.apply(this, arguments);
            }
            const unwrappedCb = this._eventMap[cb];
            delete this._eventMap[cb];
            return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
          };

          Object.defineProperty(proto, `on${eventNameToWrap}`, {
            get: function get() {
              return this[`_on${eventNameToWrap}`];
            },
            set: function set(cb) {
              if (this[`_on${eventNameToWrap}`]) {
                this.removeEventListener(eventNameToWrap, this[`_on${eventNameToWrap}`]);
                delete this[`_on${eventNameToWrap}`];
              }
              if (cb) {
                this.addEventListener(eventNameToWrap, this[`_on${eventNameToWrap}`] = cb);
              }
            },

            enumerable: true,
            configurable: true,
          });
        }

        function disableLog(bool) {
          if (typeof bool !== 'boolean') {
            return new Error(`Argument type: ${typeof bool === 'undefined' ? 'undefined' : _typeof(bool)}. Please use a boolean.`);
          }
          logDisabled_ = bool;
          return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
        }

        /**
         * Disable or enable deprecation warnings
         * @param {!boolean} bool set to true to disable warnings.
         */
        function disableWarnings(bool) {
          if (typeof bool !== 'boolean') {
            return new Error(`Argument type: ${typeof bool === 'undefined' ? 'undefined' : _typeof(bool)}. Please use a boolean.`);
          }
          deprecationWarnings_ = !bool;
          return `adapter.js deprecation warnings ${bool ? 'disabled' : 'enabled'}`;
        }

        function log() {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
            if (logDisabled_) {
              return;
            }
            if (typeof console !== 'undefined' && typeof console.log === 'function') {
              console.log(...arguments);
            }
          }
        }

        /**
         * Shows a deprecation warning suggesting the modern and spec-compatible API.
         */
        function deprecated(oldMethod, newMethod) {
          if (!deprecationWarnings_) {
            return;
          }
          console.warn(`${oldMethod} is deprecated, please use ${newMethod} instead.`);
        }

        /**
         * Browser detector.
         *
         * @return {object} result containing browser and version
         *     properties.
         */
        function detectBrowser(window) {
          const navigator = window.navigator;

          // Returned result object.

          const result = { browser: null, version: null };

          // Fail early if it's not a browser
          if (typeof window === 'undefined' || !window.navigator) {
            result.browser = 'Not a browser.';
            return result;
          }

          if (navigator.mozGetUserMedia) {
            // Firefox.
            result.browser = 'firefox';
            result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
          } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
            // Chrome, Chromium, Webview, Opera.
            // Version matches Chrome/WebRTC version.
            // Chrome 74 removed webkitGetUserMedia on http as well so we need the
            // more complicated fallback to webkitRTCPeerConnection.
            result.browser = 'chrome';
            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
            // Edge.
            result.browser = 'edge';
            result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
          } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
            // Safari.
            result.browser = 'safari';
            result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
            result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
          } else {
            // Default fallthrough: not supported.
            result.browser = 'Not a supported browser.';
            return result;
          }

          return result;
        }

        /**
         * Checks if something is an object.
         *
         * @param {*} val The something you want to check.
         * @return true if val is an object, false otherwise.
         */
        function isObject(val) {
          return Object.prototype.toString.call(val) === '[object Object]';
        }

        /**
         * Remove all empty objects and undefined values
         * from a nested object -- an enhanced and vanilla version
         * of Lodash's `compact`.
         */
        function compactObject(data) {
          if (!isObject(data)) {
            return data;
          }

          return Object.keys(data).reduce((accumulator, key) => {
            const isObj = isObject(data[key]);
            const value = isObj ? compactObject(data[key]) : data[key];
            const isEmptyObject = isObj && !Object.keys(value).length;
            if (value === undefined || isEmptyObject) {
              return accumulator;
            }
            return Object.assign(accumulator, _defineProperty({}, key, value));
          }, {});
        }

        /* iterates the stats graph recursively. */
        function walkStats(stats, base, resultSet) {
          if (!base || resultSet.has(base.id)) {
            return;
          }
          resultSet.set(base.id, base);
          Object.keys(base).forEach((name) => {
            if (name.endsWith('Id')) {
              walkStats(stats, stats.get(base[name]), resultSet);
            } else if (name.endsWith('Ids')) {
              base[name].forEach((id) => {
                walkStats(stats, stats.get(id), resultSet);
              });
            }
          });
        }

        /* filter getStats for a sender/receiver track. */
        function filterStats(result, track, outbound) {
          const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
          const filteredResult = new Map();
          if (track === null) {
            return filteredResult;
          }
          const trackStats = [];
          result.forEach((value) => {
            if (value.type === 'track' && value.trackIdentifier === track.id) {
              trackStats.push(value);
            }
          });
          trackStats.forEach((trackStat) => {
            result.forEach((stats) => {
              if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
                walkStats(result, stats, filteredResult);
              }
            });
          });
          return filteredResult;
        }
      }, {}],
      16: [function (require, module, exports) {
        /*
         *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        const SDPUtils = require('sdp');

        function fixStatsType(stat) {
          return {
            inboundrtp: 'inbound-rtp',
            outboundrtp: 'outbound-rtp',
            candidatepair: 'candidate-pair',
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate',
          }[stat.type] || stat.type;
        }

        function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
          let sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

          // Map ICE parameters (ufrag, pwd) to SDP.
          sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());

          // Map DTLS parameters to SDP.
          sdp += SDPUtils.writeDtlsParameters(
            transceiver.dtlsTransport.getLocalParameters(),
            type === 'offer' ? 'actpass' : dtlsRole || 'active',
          );

          sdp += `a=mid:${transceiver.mid}\r\n`;

          if (transceiver.rtpSender && transceiver.rtpReceiver) {
            sdp += 'a=sendrecv\r\n';
          } else if (transceiver.rtpSender) {
            sdp += 'a=sendonly\r\n';
          } else if (transceiver.rtpReceiver) {
            sdp += 'a=recvonly\r\n';
          } else {
            sdp += 'a=inactive\r\n';
          }

          if (transceiver.rtpSender) {
            const trackId = transceiver.rtpSender._initialTrackId ||
              transceiver.rtpSender.track.id;
            transceiver.rtpSender._initialTrackId = trackId;
            // spec.
            const msid = `msid:${stream ? stream.id : '-'} ${trackId}\r\n`;
            sdp += `a=${msid}`;
            // for Chrome. Legacy should no longer be required.
            sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc
              } ${msid}`;

            // RTX
            if (transceiver.sendEncodingParameters[0].rtx) {
              sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc
                } ${msid}`;
              sdp += `a=ssrc-group:FID ${transceiver.sendEncodingParameters[0].ssrc} ${transceiver.sendEncodingParameters[0].rtx.ssrc
                }\r\n`;
            }
          }
          // FIXME: this should be written by writeRtpDescription.
          sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc
            } cname:${SDPUtils.localCName}\r\n`;
          if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
            sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc
              } cname:${SDPUtils.localCName}\r\n`;
          }
          return sdp;
        }

        // Edge does not like
        // 1) stun: filtered after 14393 unless ?transport=udp is present
        // 2) turn: that does not have all of turn:host:port?transport=udp
        // 3) turn: with ipv6 addresses
        // 4) turn: occurring muliple times
        function filterIceServers(iceServers, edgeVersion) {
          let hasTurn = false;
          iceServers = JSON.parse(JSON.stringify(iceServers));
          return iceServers.filter((server) => {
            if (server && (server.urls || server.url)) {
              let urls = server.urls || server.url;
              if (server.url && !server.urls) {
                console.warn('RTCIceServer.url is deprecated! Use urls instead.');
              }
              const isString = typeof urls === 'string';
              if (isString) {
                urls = [urls];
              }
              urls = urls.filter((url) => {
                const validTurn = url.indexOf('turn:') === 0 &&
                  url.indexOf('transport=udp') !== -1 &&
                  url.indexOf('turn:[') === -1 &&
                  !hasTurn;

                if (validTurn) {
                  hasTurn = true;
                  return true;
                }
                return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
                  url.indexOf('?transport=udp') === -1;
              });

              delete server.url;
              server.urls = isString ? urls[0] : urls;
              return !!urls.length;
            }
          });
        }

        // Determines the intersection of local and remote capabilities.
        function getCommonCapabilities(localCapabilities, remoteCapabilities) {
          const commonCapabilities = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: [],
          };

          const findCodecByPayloadType = function (pt, codecs) {
            pt = parseInt(pt, 10);
            for (let i = 0; i < codecs.length; i++) {
              if (codecs[i].payloadType === pt ||
                codecs[i].preferredPayloadType === pt) {
                return codecs[i];
              }
            }
          };

          const rtxCapabilityMatches = function (lRtx, rRtx, lCodecs, rCodecs) {
            const lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
            const rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
            return lCodec && rCodec &&
              lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
          };

          localCapabilities.codecs.forEach((lCodec) => {
            for (let i = 0; i < remoteCapabilities.codecs.length; i++) {
              let rCodec = remoteCapabilities.codecs[i];
              if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
                lCodec.clockRate === rCodec.clockRate) {
                if (lCodec.name.toLowerCase() === 'rtx' &&
                  lCodec.parameters && rCodec.parameters.apt) {
                  // for RTX we need to find the local rtx that has a apt
                  // which points to the same local codec as the remote one.
                  if (!rtxCapabilityMatches(
                    lCodec, rCodec,
                    localCapabilities.codecs, remoteCapabilities.codecs,
                  )) {
                    continue;
                  }
                }
                rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
                // number of channels is the highest common number of channels
                rCodec.numChannels = Math.min(
                  lCodec.numChannels,
                  rCodec.numChannels,
                );
                // push rCodec so we reply with offerer payload type
                commonCapabilities.codecs.push(rCodec);

                // determine common feedback mechanisms
                rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter((fb) => {
                  for (let j = 0; j < lCodec.rtcpFeedback.length; j++) {
                    if (lCodec.rtcpFeedback[j].type === fb.type &&
                      lCodec.rtcpFeedback[j].parameter === fb.parameter) {
                      return true;
                    }
                  }
                  return false;
                });
                // FIXME: also need to determine .parameters
                //  see https://github.com/openpeer/ortc/issues/569
                break;
              }
            }
          });

          localCapabilities.headerExtensions.forEach((lHeaderExtension) => {
            for (let i = 0; i < remoteCapabilities.headerExtensions.length;
              i++) {
              const rHeaderExtension = remoteCapabilities.headerExtensions[i];
              if (lHeaderExtension.uri === rHeaderExtension.uri) {
                commonCapabilities.headerExtensions.push(rHeaderExtension);
                break;
              }
            }
          });

          // FIXME: fecMechanisms
          return commonCapabilities;
        }

        // is action=setLocalDescription with type allowed in signalingState
        function isActionAllowedInSignalingState(action, type, signalingState) {
          return {
            offer: {
              setLocalDescription: ['stable', 'have-local-offer'],
              setRemoteDescription: ['stable', 'have-remote-offer'],
            },
            answer: {
              setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
              setRemoteDescription: ['have-local-offer', 'have-remote-pranswer'],
            },
          }[type][action].indexOf(signalingState) !== -1;
        }

        function maybeAddCandidate(iceTransport, candidate) {
          // Edge's internal representation adds some fields therefore
          // not all field are taken into account.
          const alreadyAdded = iceTransport.getRemoteCandidates()
            .find(remoteCandidate => candidate.foundation === remoteCandidate.foundation &&
              candidate.ip === remoteCandidate.ip &&
              candidate.port === remoteCandidate.port &&
              candidate.priority === remoteCandidate.priority &&
              candidate.protocol === remoteCandidate.protocol &&
              candidate.type === remoteCandidate.type);
          if (!alreadyAdded) {
            iceTransport.addRemoteCandidate(candidate);
          }
          return !alreadyAdded;
        }


        function makeError(name, description) {
          const e = new Error(description);
          e.name = name;
          // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
          e.code = {
            NotSupportedError: 9,
            InvalidStateError: 11,
            InvalidAccessError: 15,
            TypeError: undefined,
            OperationError: undefined,
          }[name];
          return e;
        }

        module.exports = function (window, edgeVersion) {
          // https://w3c.github.io/mediacapture-main/#mediastream
          // Helper function to add the track to the stream and
          // dispatch the event ourselves.
          function addTrackToStreamAndFireEvent(track, stream) {
            stream.addTrack(track);
            stream.dispatchEvent(new window.MediaStreamTrackEvent(
              'addtrack',
              { track },
            ));
          }

          function removeTrackFromStreamAndFireEvent(track, stream) {
            stream.removeTrack(track);
            stream.dispatchEvent(new window.MediaStreamTrackEvent(
              'removetrack',
              { track },
            ));
          }

          function fireAddTrack(pc, track, receiver, streams) {
            const trackEvent = new Event('track');
            trackEvent.track = track;
            trackEvent.receiver = receiver;
            trackEvent.transceiver = { receiver };
            trackEvent.streams = streams;
            window.setTimeout(() => {
              pc._dispatchEvent('track', trackEvent);
            });
          }

          const RTCPeerConnection = function (config) {
            const pc = this;

            const _eventTarget = document.createDocumentFragment();
            ['addEventListener', 'removeEventListener', 'dispatchEvent']
              .forEach((method) => {
                pc[method] = _eventTarget[method].bind(_eventTarget);
              });

            this.canTrickleIceCandidates = null;

            this.needNegotiation = false;

            this.localStreams = [];
            this.remoteStreams = [];

            this._localDescription = null;
            this._remoteDescription = null;

            this.signalingState = 'stable';
            this.iceConnectionState = 'new';
            this.connectionState = 'new';
            this.iceGatheringState = 'new';

            config = JSON.parse(JSON.stringify(config || {}));

            this.usingBundle = config.bundlePolicy === 'max-bundle';
            if (config.rtcpMuxPolicy === 'negotiate') {
              throw (makeError(
                'NotSupportedError',
                'rtcpMuxPolicy \'negotiate\' is not supported',
              ));
            } else if (!config.rtcpMuxPolicy) {
              config.rtcpMuxPolicy = 'require';
            }

            switch (config.iceTransportPolicy) {
              case 'all':
              case 'relay':
                break;
              default:
                config.iceTransportPolicy = 'all';
                break;
            }

            switch (config.bundlePolicy) {
              case 'balanced':
              case 'max-compat':
              case 'max-bundle':
                break;
              default:
                config.bundlePolicy = 'balanced';
                break;
            }

            config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

            this._iceGatherers = [];
            if (config.iceCandidatePoolSize) {
              for (let i = config.iceCandidatePoolSize; i > 0; i--) {
                this._iceGatherers.push(new window.RTCIceGatherer({
                  iceServers: config.iceServers,
                  gatherPolicy: config.iceTransportPolicy,
                }));
              }
            } else {
              config.iceCandidatePoolSize = 0;
            }

            this._config = config;

            // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
            // everything that is needed to describe a SDP m-line.
            this.transceivers = [];

            this._sdpSessionId = SDPUtils.generateSessionId();
            this._sdpSessionVersion = 0;

            this._dtlsRole = undefined; // role for a=setup to use in answers.

            this._isClosed = false;
          };

          Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
            configurable: true,
            get() {
              return this._localDescription;
            },
          });
          Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
            configurable: true,
            get() {
              return this._remoteDescription;
            },
          });

          // set up event handlers on prototype
          RTCPeerConnection.prototype.onicecandidate = null;
          RTCPeerConnection.prototype.onaddstream = null;
          RTCPeerConnection.prototype.ontrack = null;
          RTCPeerConnection.prototype.onremovestream = null;
          RTCPeerConnection.prototype.onsignalingstatechange = null;
          RTCPeerConnection.prototype.oniceconnectionstatechange = null;
          RTCPeerConnection.prototype.onconnectionstatechange = null;
          RTCPeerConnection.prototype.onicegatheringstatechange = null;
          RTCPeerConnection.prototype.onnegotiationneeded = null;
          RTCPeerConnection.prototype.ondatachannel = null;

          RTCPeerConnection.prototype._dispatchEvent = function (name, event) {
            if (this._isClosed) {
              return;
            }
            this.dispatchEvent(event);
            if (typeof this[`on${name}`] === 'function') {
              this[`on${name}`](event);
            }
          };

          RTCPeerConnection.prototype._emitGatheringStateChange = function () {
            const event = new Event('icegatheringstatechange');
            this._dispatchEvent('icegatheringstatechange', event);
          };

          RTCPeerConnection.prototype.getConfiguration = function () {
            return this._config;
          };

          RTCPeerConnection.prototype.getLocalStreams = function () {
            return this.localStreams;
          };

          RTCPeerConnection.prototype.getRemoteStreams = function () {
            return this.remoteStreams;
          };

          // internal helper to create a transceiver object.
          // (which is not yet the same as the WebRTC 1.0 transceiver)
          RTCPeerConnection.prototype._createTransceiver = function (kind, doNotAdd) {
            const hasBundleTransport = this.transceivers.length > 0;
            const transceiver = {
              track: null,
              iceGatherer: null,
              iceTransport: null,
              dtlsTransport: null,
              localCapabilities: null,
              remoteCapabilities: null,
              rtpSender: null,
              rtpReceiver: null,
              kind,
              mid: null,
              sendEncodingParameters: null,
              recvEncodingParameters: null,
              stream: null,
              associatedRemoteMediaStreams: [],
              wantReceive: true,
            };
            if (this.usingBundle && hasBundleTransport) {
              transceiver.iceTransport = this.transceivers[0].iceTransport;
              transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
            } else {
              const transports = this._createIceAndDtlsTransports();
              transceiver.iceTransport = transports.iceTransport;
              transceiver.dtlsTransport = transports.dtlsTransport;
            }
            if (!doNotAdd) {
              this.transceivers.push(transceiver);
            }
            return transceiver;
          };

          RTCPeerConnection.prototype.addTrack = function (track, stream) {
            if (this._isClosed) {
              throw makeError(
                'InvalidStateError',
                'Attempted to call addTrack on a closed peerconnection.',
              );
            }

            const alreadyExists = this.transceivers.find(s => s.track === track);

            if (alreadyExists) {
              throw makeError('InvalidAccessError', 'Track already exists.');
            }

            let transceiver;
            for (let i = 0; i < this.transceivers.length; i++) {
              if (!this.transceivers[i].track &&
                this.transceivers[i].kind === track.kind) {
                transceiver = this.transceivers[i];
              }
            }
            if (!transceiver) {
              transceiver = this._createTransceiver(track.kind);
            }

            this._maybeFireNegotiationNeeded();

            if (this.localStreams.indexOf(stream) === -1) {
              this.localStreams.push(stream);
            }

            transceiver.track = track;
            transceiver.stream = stream;
            transceiver.rtpSender = new window.RTCRtpSender(
              track,
              transceiver.dtlsTransport,
            );
            return transceiver.rtpSender;
          };

          RTCPeerConnection.prototype.addStream = function (stream) {
            const pc = this;
            if (edgeVersion >= 15025) {
              stream.getTracks().forEach((track) => {
                pc.addTrack(track, stream);
              });
            } else {
              // Clone is necessary for local demos mostly, attaching directly
              // to two different senders does not work (build 10547).
              // Fixed in 15025 (or earlier)
              const clonedStream = stream.clone();
              stream.getTracks().forEach((track, idx) => {
                const clonedTrack = clonedStream.getTracks()[idx];
                track.addEventListener('enabled', (event) => {
                  clonedTrack.enabled = event.enabled;
                });
              });
              clonedStream.getTracks().forEach((track) => {
                pc.addTrack(track, clonedStream);
              });
            }
          };

          RTCPeerConnection.prototype.removeTrack = function (sender) {
            if (this._isClosed) {
              throw makeError(
                'InvalidStateError',
                'Attempted to call removeTrack on a closed peerconnection.',
              );
            }

            if (!(sender instanceof window.RTCRtpSender)) {
              throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
                'does not implement interface RTCRtpSender.');
            }

            const transceiver = this.transceivers.find(t => t.rtpSender === sender);

            if (!transceiver) {
              throw makeError(
                'InvalidAccessError',
                'Sender was not created by this connection.',
              );
            }
            const stream = transceiver.stream;

            transceiver.rtpSender.stop();
            transceiver.rtpSender = null;
            transceiver.track = null;
            transceiver.stream = null;

            // remove the stream from the set of local streams
            const localStreams = this.transceivers.map(t => t.stream);
            if (localStreams.indexOf(stream) === -1 &&
              this.localStreams.indexOf(stream) > -1) {
              this.localStreams.splice(this.localStreams.indexOf(stream), 1);
            }

            this._maybeFireNegotiationNeeded();
          };

          RTCPeerConnection.prototype.removeStream = function (stream) {
            const pc = this;
            stream.getTracks().forEach((track) => {
              const sender = pc.getSenders().find(s => s.track === track);
              if (sender) {
                pc.removeTrack(sender);
              }
            });
          };

          RTCPeerConnection.prototype.getSenders = function () {
            return this.transceivers.filter(transceiver => !!transceiver.rtpSender)
              .map(transceiver => transceiver.rtpSender);
          };

          RTCPeerConnection.prototype.getReceivers = function () {
            return this.transceivers.filter(transceiver => !!transceiver.rtpReceiver)
              .map(transceiver => transceiver.rtpReceiver);
          };


          RTCPeerConnection.prototype._createIceGatherer = function (
            sdpMLineIndex,
            usingBundle,
          ) {
            const pc = this;
            if (usingBundle && sdpMLineIndex > 0) {
              return this.transceivers[0].iceGatherer;
            } else if (this._iceGatherers.length) {
              return this._iceGatherers.shift();
            }
            const iceGatherer = new window.RTCIceGatherer({
              iceServers: this._config.iceServers,
              gatherPolicy: this._config.iceTransportPolicy,
            });
            Object.defineProperty(
              iceGatherer, 'state',
              { value: 'new', writable: true },
            );

            this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
            this.transceivers[sdpMLineIndex].bufferCandidates = function (event) {
              const end = !event.candidate || Object.keys(event.candidate).length === 0;
              // polyfill since RTCIceGatherer.state is not implemented in
              // Edge 10547 yet.
              iceGatherer.state = end ? 'completed' : 'gathering';
              if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
                pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
              }
            };
            iceGatherer.addEventListener(
              'localcandidate',
              this.transceivers[sdpMLineIndex].bufferCandidates,
            );
            return iceGatherer;
          };

          // start gathering from an RTCIceGatherer.
          RTCPeerConnection.prototype._gather = function (mid, sdpMLineIndex) {
            const pc = this;
            const iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
            if (iceGatherer.onlocalcandidate) {
              return;
            }
            const bufferedCandidateEvents =
              this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
            this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
            iceGatherer.removeEventListener(
              'localcandidate',
              this.transceivers[sdpMLineIndex].bufferCandidates,
            );
            iceGatherer.onlocalcandidate = function (evt) {
              if (pc.usingBundle && sdpMLineIndex > 0) {
                // if we know that we use bundle we can drop candidates with
                // dpMLineIndex > 0. If we don't do this then our state gets
                // confused since we dispose the extra ice gatherer.
                return;
              }
              const event = new Event('icecandidate');
              event.candidate = { sdpMid: mid, sdpMLineIndex };

              const cand = evt.candidate;
              // Edge emits an empty object for RTCIceCandidateComplete
              const end = !cand || Object.keys(cand).length === 0;
              if (end) {
                // polyfill since RTCIceGatherer.state is not implemented in
                // Edge 10547 yet.
                if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
                  iceGatherer.state = 'completed';
                }
              } else {
                if (iceGatherer.state === 'new') {
                  iceGatherer.state = 'gathering';
                }
                // RTCIceCandidate doesn't have a component, needs to be added
                cand.component = 1;
                // also the usernameFragment. TODO: update SDP to take both variants.
                cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

                const serializedCandidate = SDPUtils.writeCandidate(cand);
                event.candidate = Object.assign(
                  event.candidate,
                  SDPUtils.parseCandidate(serializedCandidate),
                );

                event.candidate.candidate = serializedCandidate;
                event.candidate.toJSON = function () {
                  return {
                    candidate: event.candidate.candidate,
                    sdpMid: event.candidate.sdpMid,
                    sdpMLineIndex: event.candidate.sdpMLineIndex,
                    usernameFragment: event.candidate.usernameFragment,
                  };
                };
              }

              // update local description.
              const sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
              if (!end) {
                sections[event.candidate.sdpMLineIndex] +=
                  `a=${event.candidate.candidate}\r\n`;
              } else {
                sections[event.candidate.sdpMLineIndex] +=
                  'a=end-of-candidates\r\n';
              }
              pc._localDescription.sdp =
                SDPUtils.getDescription(pc._localDescription.sdp) +
                sections.join('');
              const complete = pc.transceivers.every(transceiver => transceiver.iceGatherer &&
                transceiver.iceGatherer.state === 'completed');

              if (pc.iceGatheringState !== 'gathering') {
                pc.iceGatheringState = 'gathering';
                pc._emitGatheringStateChange();
              }

              // Emit candidate. Also emit null candidate when all gatherers are
              // complete.
              if (!end) {
                pc._dispatchEvent('icecandidate', event);
              }
              if (complete) {
                pc._dispatchEvent('icecandidate', new Event('icecandidate'));
                pc.iceGatheringState = 'complete';
                pc._emitGatheringStateChange();
              }
            };

            // emit already gathered candidates.
            window.setTimeout(() => {
              bufferedCandidateEvents.forEach((e) => {
                iceGatherer.onlocalcandidate(e);
              });
            }, 0);
          };

          // Create ICE transport and DTLS transport.
          RTCPeerConnection.prototype._createIceAndDtlsTransports = function () {
            const pc = this;
            const iceTransport = new window.RTCIceTransport(null);
            iceTransport.onicestatechange = function () {
              pc._updateIceConnectionState();
              pc._updateConnectionState();
            };

            const dtlsTransport = new window.RTCDtlsTransport(iceTransport);
            dtlsTransport.ondtlsstatechange = function () {
              pc._updateConnectionState();
            };
            dtlsTransport.onerror = function () {
              // onerror does not set state to failed by itself.
              Object.defineProperty(
                dtlsTransport, 'state',
                { value: 'failed', writable: true },
              );
              pc._updateConnectionState();
            };

            return {
              iceTransport,
              dtlsTransport,
            };
          };

          // Destroy ICE gatherer, ICE transport and DTLS transport.
          // Without triggering the callbacks.
          RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function (sdpMLineIndex) {
            const iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
            if (iceGatherer) {
              delete iceGatherer.onlocalcandidate;
              delete this.transceivers[sdpMLineIndex].iceGatherer;
            }
            const iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
            if (iceTransport) {
              delete iceTransport.onicestatechange;
              delete this.transceivers[sdpMLineIndex].iceTransport;
            }
            const dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
            if (dtlsTransport) {
              delete dtlsTransport.ondtlsstatechange;
              delete dtlsTransport.onerror;
              delete this.transceivers[sdpMLineIndex].dtlsTransport;
            }
          };

          // Start the RTP Sender and Receiver for a transceiver.
          RTCPeerConnection.prototype._transceive = function (
            transceiver,
            send, recv,
          ) {
            const params = getCommonCapabilities(
              transceiver.localCapabilities,
              transceiver.remoteCapabilities,
            );
            if (send && transceiver.rtpSender) {
              params.encodings = transceiver.sendEncodingParameters;
              params.rtcp = {
                cname: SDPUtils.localCName,
                compound: transceiver.rtcpParameters.compound,
              };
              if (transceiver.recvEncodingParameters.length) {
                params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
              }
              transceiver.rtpSender.send(params);
            }
            if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
              // remove RTX field in Edge 14942
              if (transceiver.kind === 'video'
                && transceiver.recvEncodingParameters
                && edgeVersion < 15019) {
                transceiver.recvEncodingParameters.forEach((p) => {
                  delete p.rtx;
                });
              }
              if (transceiver.recvEncodingParameters.length) {
                params.encodings = transceiver.recvEncodingParameters;
              } else {
                params.encodings = [{}];
              }
              params.rtcp = {
                compound: transceiver.rtcpParameters.compound,
              };
              if (transceiver.rtcpParameters.cname) {
                params.rtcp.cname = transceiver.rtcpParameters.cname;
              }
              if (transceiver.sendEncodingParameters.length) {
                params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
              }
              transceiver.rtpReceiver.receive(params);
            }
          };

          RTCPeerConnection.prototype.setLocalDescription = function (description) {
            const pc = this;

            // Note: pranswer is not supported.
            if (['offer', 'answer'].indexOf(description.type) === -1) {
              return Promise.reject(makeError(
                'TypeError',
                `Unsupported type "${description.type}"`,
              ));
            }

            if (!isActionAllowedInSignalingState(
              'setLocalDescription',
              description.type, pc.signalingState,
            ) || pc._isClosed) {
              return Promise.reject(makeError(
                'InvalidStateError',
                `Can not set local ${description.type
                } in state ${pc.signalingState}`,
              ));
            }

            let sections;
            let sessionpart;
            if (description.type === 'offer') {
              // VERY limited support for SDP munging. Limited to:
              // * changing the order of codecs
              sections = SDPUtils.splitSections(description.sdp);
              sessionpart = sections.shift();
              sections.forEach((mediaSection, sdpMLineIndex) => {
                const caps = SDPUtils.parseRtpParameters(mediaSection);
                pc.transceivers[sdpMLineIndex].localCapabilities = caps;
              });

              pc.transceivers.forEach((transceiver, sdpMLineIndex) => {
                pc._gather(transceiver.mid, sdpMLineIndex);
              });
            } else if (description.type === 'answer') {
              sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
              sessionpart = sections.shift();
              const isIceLite = SDPUtils.matchPrefix(
                sessionpart,
                'a=ice-lite',
              ).length > 0;
              sections.forEach((mediaSection, sdpMLineIndex) => {
                const transceiver = pc.transceivers[sdpMLineIndex];
                const iceGatherer = transceiver.iceGatherer;
                const iceTransport = transceiver.iceTransport;
                const dtlsTransport = transceiver.dtlsTransport;
                const localCapabilities = transceiver.localCapabilities;
                const remoteCapabilities = transceiver.remoteCapabilities;

                // treat bundle-only as not-rejected.
                const rejected = SDPUtils.isRejected(mediaSection) &&
                  SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

                if (!rejected && !transceiver.rejected) {
                  const remoteIceParameters = SDPUtils.getIceParameters(mediaSection, sessionpart);
                  const remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection, sessionpart);
                  if (isIceLite) {
                    remoteDtlsParameters.role = 'server';
                  }

                  if (!pc.usingBundle || sdpMLineIndex === 0) {
                    pc._gather(transceiver.mid, sdpMLineIndex);
                    if (iceTransport.state === 'new') {
                      iceTransport.start(
                        iceGatherer, remoteIceParameters,
                        isIceLite ? 'controlling' : 'controlled',
                      );
                    }
                    if (dtlsTransport.state === 'new') {
                      dtlsTransport.start(remoteDtlsParameters);
                    }
                  }

                  // Calculate intersection of capabilities.
                  const params = getCommonCapabilities(
                    localCapabilities,
                    remoteCapabilities,
                  );

                  // Start the RTCRtpSender. The RTCRtpReceiver for this
                  // transceiver has already been started in setRemoteDescription.
                  pc._transceive(
                    transceiver,
                    params.codecs.length > 0,
                    false,
                  );
                }
              });
            }

            pc._localDescription = {
              type: description.type,
              sdp: description.sdp,
            };
            if (description.type === 'offer') {
              pc._updateSignalingState('have-local-offer');
            } else {
              pc._updateSignalingState('stable');
            }

            return Promise.resolve();
          };

          RTCPeerConnection.prototype.setRemoteDescription = function (description) {
            const pc = this;

            // Note: pranswer is not supported.
            if (['offer', 'answer'].indexOf(description.type) === -1) {
              return Promise.reject(makeError(
                'TypeError',
                `Unsupported type "${description.type}"`,
              ));
            }

            if (!isActionAllowedInSignalingState(
              'setRemoteDescription',
              description.type, pc.signalingState,
            ) || pc._isClosed) {
              return Promise.reject(makeError(
                'InvalidStateError',
                `Can not set remote ${description.type
                } in state ${pc.signalingState}`,
              ));
            }

            const streams = {};
            pc.remoteStreams.forEach((stream) => {
              streams[stream.id] = stream;
            });
            const receiverList = [];
            const sections = SDPUtils.splitSections(description.sdp);
            const sessionpart = sections.shift();
            const isIceLite = SDPUtils.matchPrefix(
              sessionpart,
              'a=ice-lite',
            ).length > 0;
            const usingBundle = SDPUtils.matchPrefix(
              sessionpart,
              'a=group:BUNDLE ',
            ).length > 0;
            pc.usingBundle = usingBundle;
            const iceOptions = SDPUtils.matchPrefix(
              sessionpart,
              'a=ice-options:',
            )[0];
            if (iceOptions) {
              pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
                .indexOf('trickle') >= 0;
            } else {
              pc.canTrickleIceCandidates = false;
            }

            sections.forEach((mediaSection, sdpMLineIndex) => {
              const lines = SDPUtils.splitLines(mediaSection);
              const kind = SDPUtils.getKind(mediaSection);
              // treat bundle-only as not-rejected.
              const rejected = SDPUtils.isRejected(mediaSection) &&
                SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
              const protocol = lines[0].substr(2).split(' ')[2];

              const direction = SDPUtils.getDirection(mediaSection, sessionpart);
              const remoteMsid = SDPUtils.parseMsid(mediaSection);

              const mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

              // Reject datachannels which are not implemented yet.
              if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
                protocol === 'UDP/DTLS/SCTP'))) {
                // TODO: this is dangerous in the case where a non-rejected m-line
                //     becomes rejected.
                pc.transceivers[sdpMLineIndex] = {
                  mid,
                  kind,
                  protocol,
                  rejected: true,
                };
                return;
              }

              if (!rejected && pc.transceivers[sdpMLineIndex] &&
                pc.transceivers[sdpMLineIndex].rejected) {
                // recycle a rejected transceiver.
                pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
              }

              let transceiver;
              let iceGatherer;
              let iceTransport;
              let dtlsTransport;
              let rtpReceiver;
              let sendEncodingParameters;
              let recvEncodingParameters;
              let localCapabilities;

              let track;
              // FIXME: ensure the mediaSection has rtcp-mux set.
              const remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
              let remoteIceParameters;
              let remoteDtlsParameters;
              if (!rejected) {
                remoteIceParameters = SDPUtils.getIceParameters(
                  mediaSection,
                  sessionpart,
                );
                remoteDtlsParameters = SDPUtils.getDtlsParameters(
                  mediaSection,
                  sessionpart,
                );
                remoteDtlsParameters.role = 'client';
              }
              recvEncodingParameters =
                SDPUtils.parseRtpEncodingParameters(mediaSection);

              const rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

              const isComplete = SDPUtils.matchPrefix(
                mediaSection,
                'a=end-of-candidates', sessionpart,
              ).length > 0;
              const cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                .map(cand => SDPUtils.parseCandidate(cand))
                .filter(cand => cand.component === 1);

              // Check if we can use BUNDLE and dispose transports.
              if ((description.type === 'offer' || description.type === 'answer') &&
                !rejected && usingBundle && sdpMLineIndex > 0 &&
                pc.transceivers[sdpMLineIndex]) {
                pc._disposeIceAndDtlsTransports(sdpMLineIndex);
                pc.transceivers[sdpMLineIndex].iceGatherer =
                  pc.transceivers[0].iceGatherer;
                pc.transceivers[sdpMLineIndex].iceTransport =
                  pc.transceivers[0].iceTransport;
                pc.transceivers[sdpMLineIndex].dtlsTransport =
                  pc.transceivers[0].dtlsTransport;
                if (pc.transceivers[sdpMLineIndex].rtpSender) {
                  pc.transceivers[sdpMLineIndex].rtpSender.setTransport(pc.transceivers[0].dtlsTransport);
                }
                if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                  pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(pc.transceivers[0].dtlsTransport);
                }
              }
              if (description.type === 'offer' && !rejected) {
                transceiver = pc.transceivers[sdpMLineIndex] ||
                  pc._createTransceiver(kind);
                transceiver.mid = mid;

                if (!transceiver.iceGatherer) {
                  transceiver.iceGatherer = pc._createIceGatherer(
                    sdpMLineIndex,
                    usingBundle,
                  );
                }

                if (cands.length && transceiver.iceTransport.state === 'new') {
                  if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                    transceiver.iceTransport.setRemoteCandidates(cands);
                  } else {
                    cands.forEach((candidate) => {
                      maybeAddCandidate(transceiver.iceTransport, candidate);
                    });
                  }
                }

                localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

                // filter RTX until additional stuff needed for RTX is implemented
                // in adapter.js
                if (edgeVersion < 15019) {
                  localCapabilities.codecs = localCapabilities.codecs.filter(codec => codec.name !== 'rtx');
                }

                sendEncodingParameters = transceiver.sendEncodingParameters || [{
                  ssrc: (2 * sdpMLineIndex + 2) * 1001,
                }];

                // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
                let isNewTrack = false;
                if (direction === 'sendrecv' || direction === 'sendonly') {
                  isNewTrack = !transceiver.rtpReceiver;
                  rtpReceiver = transceiver.rtpReceiver ||
                    new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

                  if (isNewTrack) {
                    let stream;
                    track = rtpReceiver.track;
                    // FIXME: does not work with Plan B.
                    if (remoteMsid && remoteMsid.stream === '-') {
                      // no-op. a stream id of '-' means: no associated stream.
                    } else if (remoteMsid) {
                      if (!streams[remoteMsid.stream]) {
                        streams[remoteMsid.stream] = new window.MediaStream();
                        Object.defineProperty(streams[remoteMsid.stream], 'id', {
                          get() {
                            return remoteMsid.stream;
                          },
                        });
                      }
                      Object.defineProperty(track, 'id', {
                        get() {
                          return remoteMsid.track;
                        },
                      });
                      stream = streams[remoteMsid.stream];
                    } else {
                      if (!streams.default) {
                        streams.default = new window.MediaStream();
                      }
                      stream = streams.default;
                    }
                    if (stream) {
                      addTrackToStreamAndFireEvent(track, stream);
                      transceiver.associatedRemoteMediaStreams.push(stream);
                    }
                    receiverList.push([track, rtpReceiver, stream]);
                  }
                } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
                  transceiver.associatedRemoteMediaStreams.forEach((s) => {
                    const nativeTrack = s.getTracks().find(t => t.id === transceiver.rtpReceiver.track.id);
                    if (nativeTrack) {
                      removeTrackFromStreamAndFireEvent(nativeTrack, s);
                    }
                  });
                  transceiver.associatedRemoteMediaStreams = [];
                }

                transceiver.localCapabilities = localCapabilities;
                transceiver.remoteCapabilities = remoteCapabilities;
                transceiver.rtpReceiver = rtpReceiver;
                transceiver.rtcpParameters = rtcpParameters;
                transceiver.sendEncodingParameters = sendEncodingParameters;
                transceiver.recvEncodingParameters = recvEncodingParameters;

                // Start the RTCRtpReceiver now. The RTPSender is started in
                // setLocalDescription.
                pc._transceive(
                  pc.transceivers[sdpMLineIndex],
                  false,
                  isNewTrack,
                );
              } else if (description.type === 'answer' && !rejected) {
                transceiver = pc.transceivers[sdpMLineIndex];
                iceGatherer = transceiver.iceGatherer;
                iceTransport = transceiver.iceTransport;
                dtlsTransport = transceiver.dtlsTransport;
                rtpReceiver = transceiver.rtpReceiver;
                sendEncodingParameters = transceiver.sendEncodingParameters;
                localCapabilities = transceiver.localCapabilities;

                pc.transceivers[sdpMLineIndex].recvEncodingParameters =
                  recvEncodingParameters;
                pc.transceivers[sdpMLineIndex].remoteCapabilities =
                  remoteCapabilities;
                pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

                if (cands.length && iceTransport.state === 'new') {
                  if ((isIceLite || isComplete) &&
                    (!usingBundle || sdpMLineIndex === 0)) {
                    iceTransport.setRemoteCandidates(cands);
                  } else {
                    cands.forEach((candidate) => {
                      maybeAddCandidate(transceiver.iceTransport, candidate);
                    });
                  }
                }

                if (!usingBundle || sdpMLineIndex === 0) {
                  if (iceTransport.state === 'new') {
                    iceTransport.start(
                      iceGatherer, remoteIceParameters,
                      'controlling',
                    );
                  }
                  if (dtlsTransport.state === 'new') {
                    dtlsTransport.start(remoteDtlsParameters);
                  }
                }

                // If the offer contained RTX but the answer did not,
                // remove RTX from sendEncodingParameters.
                const commonCapabilities = getCommonCapabilities(
                  transceiver.localCapabilities,
                  transceiver.remoteCapabilities,
                );

                const hasRtx = commonCapabilities.codecs.filter(c => c.name.toLowerCase() === 'rtx').length;
                if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                  delete transceiver.sendEncodingParameters[0].rtx;
                }

                pc._transceive(
                  transceiver,
                  direction === 'sendrecv' || direction === 'recvonly',
                  direction === 'sendrecv' || direction === 'sendonly',
                );

                // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
                if (rtpReceiver &&
                  (direction === 'sendrecv' || direction === 'sendonly')) {
                  track = rtpReceiver.track;
                  if (remoteMsid) {
                    if (!streams[remoteMsid.stream]) {
                      streams[remoteMsid.stream] = new window.MediaStream();
                    }
                    addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
                    receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
                  } else {
                    if (!streams.default) {
                      streams.default = new window.MediaStream();
                    }
                    addTrackToStreamAndFireEvent(track, streams.default);
                    receiverList.push([track, rtpReceiver, streams.default]);
                  }
                } else {
                  // FIXME: actually the receiver should be created later.
                  delete transceiver.rtpReceiver;
                }
              }
            });

            if (pc._dtlsRole === undefined) {
              pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
            }

            pc._remoteDescription = {
              type: description.type,
              sdp: description.sdp,
            };
            if (description.type === 'offer') {
              pc._updateSignalingState('have-remote-offer');
            } else {
              pc._updateSignalingState('stable');
            }
            Object.keys(streams).forEach((sid) => {
              const stream = streams[sid];
              if (stream.getTracks().length) {
                if (pc.remoteStreams.indexOf(stream) === -1) {
                  pc.remoteStreams.push(stream);
                  const event = new Event('addstream');
                  event.stream = stream;
                  window.setTimeout(() => {
                    pc._dispatchEvent('addstream', event);
                  });
                }

                receiverList.forEach((item) => {
                  const track = item[0];
                  const receiver = item[1];
                  if (stream.id !== item[2].id) {
                    return;
                  }
                  fireAddTrack(pc, track, receiver, [stream]);
                });
              }
            });
            receiverList.forEach((item) => {
              if (item[2]) {
                return;
              }
              fireAddTrack(pc, item[0], item[1], []);
            });

            // check whether addIceCandidate({}) was called within four seconds after
            // setRemoteDescription.
            window.setTimeout(() => {
              if (!(pc && pc.transceivers)) {
                return;
              }
              pc.transceivers.forEach((transceiver) => {
                if (transceiver.iceTransport &&
                  transceiver.iceTransport.state === 'new' &&
                  transceiver.iceTransport.getRemoteCandidates().length > 0) {
                  console.warn('Timeout for addRemoteCandidate. Consider sending ' +
                    'an end-of-candidates notification');
                  transceiver.iceTransport.addRemoteCandidate({});
                }
              });
            }, 4000);

            return Promise.resolve();
          };

          RTCPeerConnection.prototype.close = function () {
            this.transceivers.forEach((transceiver) => {
              /* not yet
              if (transceiver.iceGatherer) {
                transceiver.iceGatherer.close();
              }
              */
              if (transceiver.iceTransport) {
                transceiver.iceTransport.stop();
              }
              if (transceiver.dtlsTransport) {
                transceiver.dtlsTransport.stop();
              }
              if (transceiver.rtpSender) {
                transceiver.rtpSender.stop();
              }
              if (transceiver.rtpReceiver) {
                transceiver.rtpReceiver.stop();
              }
            });
            // FIXME: clean up tracks, local streams, remote streams, etc
            this._isClosed = true;
            this._updateSignalingState('closed');
          };

          // Update the signaling state.
          RTCPeerConnection.prototype._updateSignalingState = function (newState) {
            this.signalingState = newState;
            const event = new Event('signalingstatechange');
            this._dispatchEvent('signalingstatechange', event);
          };

          // Determine whether to fire the negotiationneeded event.
          RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function () {
            const pc = this;
            if (this.signalingState !== 'stable' || this.needNegotiation === true) {
              return;
            }
            this.needNegotiation = true;
            window.setTimeout(() => {
              if (pc.needNegotiation) {
                pc.needNegotiation = false;
                const event = new Event('negotiationneeded');
                pc._dispatchEvent('negotiationneeded', event);
              }
            }, 0);
          };

          // Update the ice connection state.
          RTCPeerConnection.prototype._updateIceConnectionState = function () {
            let newState;
            const states = {
              new: 0,
              closed: 0,
              checking: 0,
              connected: 0,
              completed: 0,
              disconnected: 0,
              failed: 0,
            };
            this.transceivers.forEach((transceiver) => {
              if (transceiver.iceTransport && !transceiver.rejected) {
                states[transceiver.iceTransport.state]++;
              }
            });

            newState = 'new';
            if (states.failed > 0) {
              newState = 'failed';
            } else if (states.checking > 0) {
              newState = 'checking';
            } else if (states.disconnected > 0) {
              newState = 'disconnected';
            } else if (states.new > 0) {
              newState = 'new';
            } else if (states.connected > 0) {
              newState = 'connected';
            } else if (states.completed > 0) {
              newState = 'completed';
            }

            if (newState !== this.iceConnectionState) {
              this.iceConnectionState = newState;
              const event = new Event('iceconnectionstatechange');
              this._dispatchEvent('iceconnectionstatechange', event);
            }
          };

          // Update the connection state.
          RTCPeerConnection.prototype._updateConnectionState = function () {
            let newState;
            const states = {
              new: 0,
              closed: 0,
              connecting: 0,
              connected: 0,
              completed: 0,
              disconnected: 0,
              failed: 0,
            };
            this.transceivers.forEach((transceiver) => {
              if (transceiver.iceTransport && transceiver.dtlsTransport &&
                !transceiver.rejected) {
                states[transceiver.iceTransport.state]++;
                states[transceiver.dtlsTransport.state]++;
              }
            });
            // ICETransport.completed and connected are the same for this purpose.
            states.connected += states.completed;

            newState = 'new';
            if (states.failed > 0) {
              newState = 'failed';
            } else if (states.connecting > 0) {
              newState = 'connecting';
            } else if (states.disconnected > 0) {
              newState = 'disconnected';
            } else if (states.new > 0) {
              newState = 'new';
            } else if (states.connected > 0) {
              newState = 'connected';
            }

            if (newState !== this.connectionState) {
              this.connectionState = newState;
              const event = new Event('connectionstatechange');
              this._dispatchEvent('connectionstatechange', event);
            }
          };

          RTCPeerConnection.prototype.createOffer = function () {
            const pc = this;

            if (pc._isClosed) {
              return Promise.reject(makeError(
                'InvalidStateError',
                'Can not call createOffer after close',
              ));
            }

            let numAudioTracks = pc.transceivers.filter(t => t.kind === 'audio').length;
            let numVideoTracks = pc.transceivers.filter(t => t.kind === 'video').length;

            // Determine number of audio and video tracks we need to send/recv.
            const offerOptions = arguments[0];
            if (offerOptions) {
              // Reject Chrome legacy constraints.
              if (offerOptions.mandatory || offerOptions.optional) {
                throw new TypeError('Legacy mandatory/optional constraints not supported.');
              }
              if (offerOptions.offerToReceiveAudio !== undefined) {
                if (offerOptions.offerToReceiveAudio === true) {
                  numAudioTracks = 1;
                } else if (offerOptions.offerToReceiveAudio === false) {
                  numAudioTracks = 0;
                } else {
                  numAudioTracks = offerOptions.offerToReceiveAudio;
                }
              }
              if (offerOptions.offerToReceiveVideo !== undefined) {
                if (offerOptions.offerToReceiveVideo === true) {
                  numVideoTracks = 1;
                } else if (offerOptions.offerToReceiveVideo === false) {
                  numVideoTracks = 0;
                } else {
                  numVideoTracks = offerOptions.offerToReceiveVideo;
                }
              }
            }

            pc.transceivers.forEach((transceiver) => {
              if (transceiver.kind === 'audio') {
                numAudioTracks--;
                if (numAudioTracks < 0) {
                  transceiver.wantReceive = false;
                }
              } else if (transceiver.kind === 'video') {
                numVideoTracks--;
                if (numVideoTracks < 0) {
                  transceiver.wantReceive = false;
                }
              }
            });

            // Create M-lines for recvonly streams.
            while (numAudioTracks > 0 || numVideoTracks > 0) {
              if (numAudioTracks > 0) {
                pc._createTransceiver('audio');
                numAudioTracks--;
              }
              if (numVideoTracks > 0) {
                pc._createTransceiver('video');
                numVideoTracks--;
              }
            }

            let sdp = SDPUtils.writeSessionBoilerplate(
              pc._sdpSessionId,
              pc._sdpSessionVersion++,
            );
            pc.transceivers.forEach((transceiver, sdpMLineIndex) => {
              // For each track, create an ice gatherer, ice transport,
              // dtls transport, potentially rtpsender and rtpreceiver.
              const track = transceiver.track;
              const kind = transceiver.kind;
              const mid = transceiver.mid || SDPUtils.generateIdentifier();
              transceiver.mid = mid;

              if (!transceiver.iceGatherer) {
                transceiver.iceGatherer = pc._createIceGatherer(
                  sdpMLineIndex,
                  pc.usingBundle,
                );
              }

              const localCapabilities = window.RTCRtpSender.getCapabilities(kind);
              // filter RTX until additional stuff needed for RTX is implemented
              // in adapter.js
              if (edgeVersion < 15019) {
                localCapabilities.codecs = localCapabilities.codecs.filter(codec => codec.name !== 'rtx');
              }
              localCapabilities.codecs.forEach((codec) => {
                // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
                // by adding level-asymmetry-allowed=1
                if (codec.name === 'H264' &&
                  codec.parameters['level-asymmetry-allowed'] === undefined) {
                  codec.parameters['level-asymmetry-allowed'] = '1';
                }

                // for subsequent offers, we might have to re-use the payload
                // type of the last offer.
                if (transceiver.remoteCapabilities &&
                  transceiver.remoteCapabilities.codecs) {
                  transceiver.remoteCapabilities.codecs.forEach((remoteCodec) => {
                    if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                      codec.clockRate === remoteCodec.clockRate) {
                      codec.preferredPayloadType = remoteCodec.payloadType;
                    }
                  });
                }
              });
              localCapabilities.headerExtensions.forEach((hdrExt) => {
                const remoteExtensions = transceiver.remoteCapabilities &&
                  transceiver.remoteCapabilities.headerExtensions || [];
                remoteExtensions.forEach((rHdrExt) => {
                  if (hdrExt.uri === rHdrExt.uri) {
                    hdrExt.id = rHdrExt.id;
                  }
                });
              });

              // generate an ssrc now, to be used later in rtpSender.send
              const sendEncodingParameters = transceiver.sendEncodingParameters || [{
                ssrc: (2 * sdpMLineIndex + 1) * 1001,
              }];
              if (track) {
                // add RTX
                if (edgeVersion >= 15019 && kind === 'video' &&
                  !sendEncodingParameters[0].rtx) {
                  sendEncodingParameters[0].rtx = {
                    ssrc: sendEncodingParameters[0].ssrc + 1,
                  };
                }
              }

              if (transceiver.wantReceive) {
                transceiver.rtpReceiver = new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);
              }

              transceiver.localCapabilities = localCapabilities;
              transceiver.sendEncodingParameters = sendEncodingParameters;
            });

            // always offer BUNDLE and dispose on return if not supported.
            if (pc._config.bundlePolicy !== 'max-compat') {
              sdp += `a=group:BUNDLE ${pc.transceivers.map(t => t.mid).join(' ')}\r\n`;
            }
            sdp += 'a=ice-options:trickle\r\n';

            pc.transceivers.forEach((transceiver, sdpMLineIndex) => {
              sdp += writeMediaSection(
                transceiver, transceiver.localCapabilities,
                'offer', transceiver.stream, pc._dtlsRole,
              );
              sdp += 'a=rtcp-rsize\r\n';

              if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
                (sdpMLineIndex === 0 || !pc.usingBundle)) {
                transceiver.iceGatherer.getLocalCandidates().forEach((cand) => {
                  cand.component = 1;
                  sdp += `a=${SDPUtils.writeCandidate(cand)}\r\n`;
                });

                if (transceiver.iceGatherer.state === 'completed') {
                  sdp += 'a=end-of-candidates\r\n';
                }
              }
            });

            const desc = new window.RTCSessionDescription({
              type: 'offer',
              sdp,
            });
            return Promise.resolve(desc);
          };

          RTCPeerConnection.prototype.createAnswer = function () {
            const pc = this;

            if (pc._isClosed) {
              return Promise.reject(makeError(
                'InvalidStateError',
                'Can not call createAnswer after close',
              ));
            }

            if (!(pc.signalingState === 'have-remote-offer' ||
              pc.signalingState === 'have-local-pranswer')) {
              return Promise.reject(makeError(
                'InvalidStateError',
                `Can not call createAnswer in signalingState ${pc.signalingState}`,
              ));
            }

            let sdp = SDPUtils.writeSessionBoilerplate(
              pc._sdpSessionId,
              pc._sdpSessionVersion++,
            );
            if (pc.usingBundle) {
              sdp += `a=group:BUNDLE ${pc.transceivers.map(t => t.mid).join(' ')}\r\n`;
            }
            sdp += 'a=ice-options:trickle\r\n';

            const mediaSectionsInOffer = SDPUtils.getMediaSections(pc._remoteDescription.sdp).length;
            pc.transceivers.forEach((transceiver, sdpMLineIndex) => {
              if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
                return;
              }
              if (transceiver.rejected) {
                if (transceiver.kind === 'application') {
                  if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
                    sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
                  } else {
                    sdp += `m=application 0 ${transceiver.protocol
                      } webrtc-datachannel\r\n`;
                  }
                } else if (transceiver.kind === 'audio') {
                  sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
                    'a=rtpmap:0 PCMU/8000\r\n';
                } else if (transceiver.kind === 'video') {
                  sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
                    'a=rtpmap:120 VP8/90000\r\n';
                }
                sdp += `${'c=IN IP4 0.0.0.0\r\n' +
                  'a=inactive\r\n' +
                  'a=mid:'}${transceiver.mid}\r\n`;
                return;
              }

              // FIXME: look at direction.
              if (transceiver.stream) {
                let localTrack;
                if (transceiver.kind === 'audio') {
                  localTrack = transceiver.stream.getAudioTracks()[0];
                } else if (transceiver.kind === 'video') {
                  localTrack = transceiver.stream.getVideoTracks()[0];
                }
                if (localTrack) {
                  // add RTX
                  if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
                    !transceiver.sendEncodingParameters[0].rtx) {
                    transceiver.sendEncodingParameters[0].rtx = {
                      ssrc: transceiver.sendEncodingParameters[0].ssrc + 1,
                    };
                  }
                }
              }

              // Calculate intersection of capabilities.
              const commonCapabilities = getCommonCapabilities(
                transceiver.localCapabilities,
                transceiver.remoteCapabilities,
              );

              const hasRtx = commonCapabilities.codecs.filter(c => c.name.toLowerCase() === 'rtx').length;
              if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                delete transceiver.sendEncodingParameters[0].rtx;
              }

              sdp += writeMediaSection(
                transceiver, commonCapabilities,
                'answer', transceiver.stream, pc._dtlsRole,
              );
              if (transceiver.rtcpParameters &&
                transceiver.rtcpParameters.reducedSize) {
                sdp += 'a=rtcp-rsize\r\n';
              }
            });

            const desc = new window.RTCSessionDescription({
              type: 'answer',
              sdp,
            });
            return Promise.resolve(desc);
          };

          RTCPeerConnection.prototype.addIceCandidate = function (candidate) {
            const pc = this;
            let sections;
            if (candidate && !(candidate.sdpMLineIndex !== undefined ||
              candidate.sdpMid)) {
              return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
            }

            // TODO: needs to go into ops queue.
            return new Promise(((resolve, reject) => {
              if (!pc._remoteDescription) {
                return reject(makeError(
                  'InvalidStateError',
                  'Can not add ICE candidate without a remote description',
                ));
              } else if (!candidate || candidate.candidate === '') {
                for (let j = 0; j < pc.transceivers.length; j++) {
                  if (pc.transceivers[j].rejected) {
                    continue;
                  }
                  pc.transceivers[j].iceTransport.addRemoteCandidate({});
                  sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                  sections[j] += 'a=end-of-candidates\r\n';
                  pc._remoteDescription.sdp =
                    SDPUtils.getDescription(pc._remoteDescription.sdp) +
                    sections.join('');
                  if (pc.usingBundle) {
                    break;
                  }
                }
              } else {
                let sdpMLineIndex = candidate.sdpMLineIndex;
                if (candidate.sdpMid) {
                  for (let i = 0; i < pc.transceivers.length; i++) {
                    if (pc.transceivers[i].mid === candidate.sdpMid) {
                      sdpMLineIndex = i;
                      break;
                    }
                  }
                }
                const transceiver = pc.transceivers[sdpMLineIndex];
                if (transceiver) {
                  if (transceiver.rejected) {
                    return resolve();
                  }
                  const cand = Object.keys(candidate.candidate).length > 0 ?
                    SDPUtils.parseCandidate(candidate.candidate) : {};
                  // Ignore Chrome's invalid candidates since Edge does not like them.
                  if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
                    return resolve();
                  }
                  // Ignore RTCP candidates, we assume RTCP-MUX.
                  if (cand.component && cand.component !== 1) {
                    return resolve();
                  }
                  // when using bundle, avoid adding candidates to the wrong
                  // ice transport. And avoid adding candidates added in the SDP.
                  if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
                    transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
                    if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                      return reject(makeError(
                        'OperationError',
                        'Can not add ICE candidate',
                      ));
                    }
                  }

                  // update the remoteDescription.
                  let candidateString = candidate.candidate.trim();
                  if (candidateString.indexOf('a=') === 0) {
                    candidateString = candidateString.substr(2);
                  }
                  sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
                  sections[sdpMLineIndex] += `a=${cand.type ? candidateString : 'end-of-candidates'
                    }\r\n`;
                  pc._remoteDescription.sdp =
                    SDPUtils.getDescription(pc._remoteDescription.sdp) +
                    sections.join('');
                } else {
                  return reject(makeError(
                    'OperationError',
                    'Can not add ICE candidate',
                  ));
                }
              }
              resolve();
            }));
          };

          RTCPeerConnection.prototype.getStats = function (selector) {
            if (selector && selector instanceof window.MediaStreamTrack) {
              let senderOrReceiver = null;
              this.transceivers.forEach((transceiver) => {
                if (transceiver.rtpSender &&
                  transceiver.rtpSender.track === selector) {
                  senderOrReceiver = transceiver.rtpSender;
                } else if (transceiver.rtpReceiver &&
                  transceiver.rtpReceiver.track === selector) {
                  senderOrReceiver = transceiver.rtpReceiver;
                }
              });
              if (!senderOrReceiver) {
                throw makeError('InvalidAccessError', 'Invalid selector.');
              }
              return senderOrReceiver.getStats();
            }

            const promises = [];
            this.transceivers.forEach((transceiver) => {
              ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
                'dtlsTransport'].forEach((method) => {
                  if (transceiver[method]) {
                    promises.push(transceiver[method].getStats());
                  }
                });
            });
            return Promise.all(promises).then((allStats) => {
              const results = new Map();
              allStats.forEach((stats) => {
                stats.forEach((stat) => {
                  results.set(stat.id, stat);
                });
              });
              return results;
            });
          };

          // fix low-level stat names and return Map instead of object.
          const ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
            'RTCIceTransport', 'RTCDtlsTransport'];
          ortcObjects.forEach((ortcObjectName) => {
            const obj = window[ortcObjectName];
            if (obj && obj.prototype && obj.prototype.getStats) {
              const nativeGetstats = obj.prototype.getStats;
              obj.prototype.getStats = function () {
                return nativeGetstats.apply(this)
                  .then((nativeStats) => {
                    const mapStats = new Map();
                    Object.keys(nativeStats).forEach((id) => {
                      nativeStats[id].type = fixStatsType(nativeStats[id]);
                      mapStats.set(id, nativeStats[id]);
                    });
                    return mapStats;
                  });
              };
            }
          });

          // legacy callback shims. Should be moved to adapter.js some days.
          let methods = ['createOffer', 'createAnswer'];
          methods.forEach((method) => {
            const nativeMethod = RTCPeerConnection.prototype[method];
            RTCPeerConnection.prototype[method] = function () {
              const args = arguments;
              if (typeof args[0] === 'function' ||
                typeof args[1] === 'function') { // legacy
                return nativeMethod.apply(this, [arguments[2]])
                  .then((description) => {
                    if (typeof args[0] === 'function') {
                      args[0].apply(null, [description]);
                    }
                  }, (error) => {
                    if (typeof args[1] === 'function') {
                      args[1].apply(null, [error]);
                    }
                  });
              }
              return nativeMethod.apply(this, arguments);
            };
          });

          methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
          methods.forEach((method) => {
            const nativeMethod = RTCPeerConnection.prototype[method];
            RTCPeerConnection.prototype[method] = function () {
              const args = arguments;
              if (typeof args[1] === 'function' ||
                typeof args[2] === 'function') { // legacy
                return nativeMethod.apply(this, arguments)
                  .then(() => {
                    if (typeof args[1] === 'function') {
                      args[1].apply(null);
                    }
                  }, (error) => {
                    if (typeof args[2] === 'function') {
                      args[2].apply(null, [error]);
                    }
                  });
              }
              return nativeMethod.apply(this, arguments);
            };
          });

          // getStats is special. It doesn't have a spec legacy method yet we support
          // getStats(something, cb) without error callbacks.
          ['getStats'].forEach((method) => {
            const nativeMethod = RTCPeerConnection.prototype[method];
            RTCPeerConnection.prototype[method] = function () {
              const args = arguments;
              if (typeof args[1] === 'function') {
                return nativeMethod.apply(this, arguments)
                  .then(() => {
                    if (typeof args[1] === 'function') {
                      args[1].apply(null);
                    }
                  });
              }
              return nativeMethod.apply(this, arguments);
            };
          });

          return RTCPeerConnection;
        };
      }, { sdp: 17 }],
      17: [function (require, module, exports) {
        /* eslint-env node */


        // SDP helpers.
        const SDPUtils = {};

        // Generate an alphanumeric identifier for cname or mids.
        // TODO: use UUIDs instead? https://gist.github.com/jed/982883
        SDPUtils.generateIdentifier = function () {
          return Math.random().toString(36).substr(2, 10);
        };

        // The RTCP CNAME used by all peerconnections from the same JS.
        SDPUtils.localCName = SDPUtils.generateIdentifier();

        // Splits SDP into lines, dealing with both CRLF and LF.
        SDPUtils.splitLines = function (blob) {
          return blob.trim().split('\n').map(line => line.trim());
        };
        // Splits SDP into sessionpart and mediasections. Ensures CRLF.
        SDPUtils.splitSections = function (blob) {
          const parts = blob.split('\nm=');
          return parts.map((part, index) => `${(index > 0 ? `m=${part}` : part).trim()}\r\n`);
        };

        // returns the session description.
        SDPUtils.getDescription = function (blob) {
          const sections = SDPUtils.splitSections(blob);
          return sections && sections[0];
        };

        // returns the individual media sections.
        SDPUtils.getMediaSections = function (blob) {
          const sections = SDPUtils.splitSections(blob);
          sections.shift();
          return sections;
        };

        // Returns lines that start with a certain prefix.
        SDPUtils.matchPrefix = function (blob, prefix) {
          return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
        };

        // Parses an ICE candidate line. Sample input:
        // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
        // rport 55996"
        SDPUtils.parseCandidate = function (line) {
          let parts;
          // Parse both variants.
          if (line.indexOf('a=candidate:') === 0) {
            parts = line.substring(12).split(' ');
          } else {
            parts = line.substring(10).split(' ');
          }

          const candidate = {
            foundation: parts[0],
            component: parseInt(parts[1], 10),
            protocol: parts[2].toLowerCase(),
            priority: parseInt(parts[3], 10),
            ip: parts[4],
            address: parts[4], // address is an alias for ip.
            port: parseInt(parts[5], 10),
            // skip parts[6] == 'typ'
            type: parts[7],
          };

          for (let i = 8; i < parts.length; i += 2) {
            switch (parts[i]) {
              case 'raddr':
                candidate.relatedAddress = parts[i + 1];
                break;
              case 'rport':
                candidate.relatedPort = parseInt(parts[i + 1], 10);
                break;
              case 'tcptype':
                candidate.tcpType = parts[i + 1];
                break;
              case 'ufrag':
                candidate.ufrag = parts[i + 1]; // for backward compability.
                candidate.usernameFragment = parts[i + 1];
                break;
              default: // extension handling, in particular ufrag
                candidate[parts[i]] = parts[i + 1];
                break;
            }
          }
          return candidate;
        };

        // Translates a candidate object into SDP candidate attribute.
        SDPUtils.writeCandidate = function (candidate) {
          const sdp = [];
          sdp.push(candidate.foundation);
          sdp.push(candidate.component);
          sdp.push(candidate.protocol.toUpperCase());
          sdp.push(candidate.priority);
          sdp.push(candidate.address || candidate.ip);
          sdp.push(candidate.port);

          const type = candidate.type;
          sdp.push('typ');
          sdp.push(type);
          if (type !== 'host' && candidate.relatedAddress &&
            candidate.relatedPort) {
            sdp.push('raddr');
            sdp.push(candidate.relatedAddress);
            sdp.push('rport');
            sdp.push(candidate.relatedPort);
          }
          if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
            sdp.push('tcptype');
            sdp.push(candidate.tcpType);
          }
          if (candidate.usernameFragment || candidate.ufrag) {
            sdp.push('ufrag');
            sdp.push(candidate.usernameFragment || candidate.ufrag);
          }
          return `candidate:${sdp.join(' ')}`;
        };

        // Parses an ice-options line, returns an array of option tags.
        // a=ice-options:foo bar
        SDPUtils.parseIceOptions = function (line) {
          return line.substr(14).split(' ');
        };

        // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
        // a=rtpmap:111 opus/48000/2
        SDPUtils.parseRtpMap = function (line) {
          let parts = line.substr(9).split(' ');
          const parsed = {
            payloadType: parseInt(parts.shift(), 10), // was: id
          };

          parts = parts[0].split('/');

          parsed.name = parts[0];
          parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
          parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
          // legacy alias, got renamed back to channels in ORTC.
          parsed.numChannels = parsed.channels;
          return parsed;
        };

        // Generate an a=rtpmap line from RTCRtpCodecCapability or
        // RTCRtpCodecParameters.
        SDPUtils.writeRtpMap = function (codec) {
          let pt = codec.payloadType;
          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }
          const channels = codec.channels || codec.numChannels || 1;
          return `a=rtpmap:${pt} ${codec.name}/${codec.clockRate
            }${channels !== 1 ? `/${channels}` : ''}\r\n`;
        };

        // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
        SDPUtils.parseExtmap = function (line) {
          const parts = line.substr(9).split(' ');
          return {
            id: parseInt(parts[0], 10),
            direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
            uri: parts[1],
          };
        };

        // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
        // RTCRtpHeaderExtension.
        SDPUtils.writeExtmap = function (headerExtension) {
          return `a=extmap:${headerExtension.id || headerExtension.preferredId
            }${headerExtension.direction && headerExtension.direction !== 'sendrecv'
              ? `/${headerExtension.direction}`
              : ''
            } ${headerExtension.uri}\r\n`;
        };

        // Parses an ftmp line, returns dictionary. Sample input:
        // a=fmtp:96 vbr=on;cng=on
        // Also deals with vbr=on; cng=on
        SDPUtils.parseFmtp = function (line) {
          const parsed = {};
          let kv;
          const parts = line.substr(line.indexOf(' ') + 1).split(';');
          for (let j = 0; j < parts.length; j++) {
            kv = parts[j].trim().split('=');
            parsed[kv[0].trim()] = kv[1];
          }
          return parsed;
        };

        // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
        SDPUtils.writeFmtp = function (codec) {
          let line = '';
          let pt = codec.payloadType;
          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }
          if (codec.parameters && Object.keys(codec.parameters).length) {
            const params = [];
            Object.keys(codec.parameters).forEach((param) => {
              if (codec.parameters[param]) {
                params.push(`${param}=${codec.parameters[param]}`);
              } else {
                params.push(param);
              }
            });
            line += `a=fmtp:${pt} ${params.join(';')}\r\n`;
          }
          return line;
        };

        // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
        // a=rtcp-fb:98 nack rpsi
        SDPUtils.parseRtcpFb = function (line) {
          const parts = line.substr(line.indexOf(' ') + 1).split(' ');
          return {
            type: parts.shift(),
            parameter: parts.join(' '),
          };
        };
        // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
        SDPUtils.writeRtcpFb = function (codec) {
          let lines = '';
          let pt = codec.payloadType;
          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }
          if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
            // FIXME: special handling for trr-int?
            codec.rtcpFeedback.forEach((fb) => {
              lines += `a=rtcp-fb:${pt} ${fb.type
                }${fb.parameter && fb.parameter.length ? ` ${fb.parameter}` : ''
                }\r\n`;
            });
          }
          return lines;
        };

        // Parses an RFC 5576 ssrc media attribute. Sample input:
        // a=ssrc:3735928559 cname:something
        SDPUtils.parseSsrcMedia = function (line) {
          const sp = line.indexOf(' ');
          const parts = {
            ssrc: parseInt(line.substr(7, sp - 7), 10),
          };
          const colon = line.indexOf(':', sp);
          if (colon > -1) {
            parts.attribute = line.substr(sp + 1, colon - sp - 1);
            parts.value = line.substr(colon + 1);
          } else {
            parts.attribute = line.substr(sp + 1);
          }
          return parts;
        };

        SDPUtils.parseSsrcGroup = function (line) {
          const parts = line.substr(13).split(' ');
          return {
            semantics: parts.shift(),
            ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
          };
        };

        // Extracts the MID (RFC 5888) from a media section.
        // returns the MID or undefined if no mid line was found.
        SDPUtils.getMid = function (mediaSection) {
          const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
          if (mid) {
            return mid.substr(6);
          }
        };

        SDPUtils.parseFingerprint = function (line) {
          const parts = line.substr(14).split(' ');
          return {
            algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
            value: parts[1],
          };
        };

        // Extracts DTLS parameters from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the fingerprint line as input. See also getIceParameters.
        SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
          const lines = SDPUtils.matchPrefix(
            mediaSection + sessionpart,
            'a=fingerprint:',
          );
          // Note: a=setup line is ignored since we use the 'auto' role.
          // Note2: 'algorithm' is not case sensitive except in Edge.
          return {
            role: 'auto',
            fingerprints: lines.map(SDPUtils.parseFingerprint),
          };
        };

        // Serializes DTLS parameters to SDP.
        SDPUtils.writeDtlsParameters = function (params, setupType) {
          let sdp = `a=setup:${setupType}\r\n`;
          params.fingerprints.forEach((fp) => {
            sdp += `a=fingerprint:${fp.algorithm} ${fp.value}\r\n`;
          });
          return sdp;
        };
        // Parses ICE information from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the ice-ufrag and ice-pwd lines as input.
        SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
          let lines = SDPUtils.splitLines(mediaSection);
          // Search in session part, too.
          lines = lines.concat(SDPUtils.splitLines(sessionpart));
          const iceParameters = {
            usernameFragment: lines.filter(line => line.indexOf('a=ice-ufrag:') === 0)[0].substr(12),
            password: lines.filter(line => line.indexOf('a=ice-pwd:') === 0)[0].substr(10),
          };
          return iceParameters;
        };

        // Serializes ICE parameters to SDP.
        SDPUtils.writeIceParameters = function (params) {
          return `a=ice-ufrag:${params.usernameFragment}\r\n` +
            `a=ice-pwd:${params.password}\r\n`;
        };

        // Parses the SDP media section and returns RTCRtpParameters.
        SDPUtils.parseRtpParameters = function (mediaSection) {
          const description = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: [],
            rtcp: [],
          };
          const lines = SDPUtils.splitLines(mediaSection);
          const mline = lines[0].split(' ');
          for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
            const pt = mline[i];
            const rtpmapline = SDPUtils.matchPrefix(mediaSection, `a=rtpmap:${pt} `)[0];
            if (rtpmapline) {
              const codec = SDPUtils.parseRtpMap(rtpmapline);
              const fmtps = SDPUtils.matchPrefix(mediaSection, `a=fmtp:${pt} `);
              // Only the first a=fmtp:<pt> is considered.
              codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
              codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, `a=rtcp-fb:${pt} `)
                .map(SDPUtils.parseRtcpFb);
              description.codecs.push(codec);
              // parse FEC mechanisms from rtpmap lines.
              switch (codec.name.toUpperCase()) {
                case 'RED':
                case 'ULPFEC':
                  description.fecMechanisms.push(codec.name.toUpperCase());
                  break;
                default: // only RED and ULPFEC are recognized as FEC mechanisms.
                  break;
              }
            }
          }
          SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach((line) => {
            description.headerExtensions.push(SDPUtils.parseExtmap(line));
          });
          // FIXME: parse rtcp.
          return description;
        };

        // Generates parts of the SDP media section describing the capabilities /
        // parameters.
        SDPUtils.writeRtpDescription = function (kind, caps) {
          let sdp = '';

          // Build the mline.
          sdp += `m=${kind} `;
          sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
          sdp += ' UDP/TLS/RTP/SAVPF ';
          sdp += `${caps.codecs.map((codec) => {
            if (codec.preferredPayloadType !== undefined) {
              return codec.preferredPayloadType;
            }
            return codec.payloadType;
          }).join(' ')}\r\n`;

          sdp += 'c=IN IP4 0.0.0.0\r\n';
          sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

          // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
          caps.codecs.forEach((codec) => {
            sdp += SDPUtils.writeRtpMap(codec);
            sdp += SDPUtils.writeFmtp(codec);
            sdp += SDPUtils.writeRtcpFb(codec);
          });
          let maxptime = 0;
          caps.codecs.forEach((codec) => {
            if (codec.maxptime > maxptime) {
              maxptime = codec.maxptime;
            }
          });
          if (maxptime > 0) {
            sdp += `a=maxptime:${maxptime}\r\n`;
          }
          sdp += 'a=rtcp-mux\r\n';

          if (caps.headerExtensions) {
            caps.headerExtensions.forEach((extension) => {
              sdp += SDPUtils.writeExtmap(extension);
            });
          }
          // FIXME: write fecMechanisms.
          return sdp;
        };

        // Parses the SDP media section and returns an array of
        // RTCRtpEncodingParameters.
        SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
          const encodingParameters = [];
          const description = SDPUtils.parseRtpParameters(mediaSection);
          const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
          const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

          // filter a=ssrc:... cname:, ignore PlanB-msid
          const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
            .map(line => SDPUtils.parseSsrcMedia(line))
            .filter(parts => parts.attribute === 'cname');
          const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
          let secondarySsrc;

          const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
            .map((line) => {
              const parts = line.substr(17).split(' ');
              return parts.map(part => parseInt(part, 10));
            });
          if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
            secondarySsrc = flows[0][1];
          }

          description.codecs.forEach((codec) => {
            if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
              let encParam = {
                ssrc: primarySsrc,
                codecPayloadType: parseInt(codec.parameters.apt, 10),
              };
              if (primarySsrc && secondarySsrc) {
                encParam.rtx = { ssrc: secondarySsrc };
              }
              encodingParameters.push(encParam);
              if (hasRed) {
                encParam = JSON.parse(JSON.stringify(encParam));
                encParam.fec = {
                  ssrc: primarySsrc,
                  mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
                };
                encodingParameters.push(encParam);
              }
            }
          });
          if (encodingParameters.length === 0 && primarySsrc) {
            encodingParameters.push({
              ssrc: primarySsrc,
            });
          }

          // we support both b=AS and b=TIAS but interpret AS as TIAS.
          let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
          if (bandwidth.length) {
            if (bandwidth[0].indexOf('b=TIAS:') === 0) {
              bandwidth = parseInt(bandwidth[0].substr(7), 10);
            } else if (bandwidth[0].indexOf('b=AS:') === 0) {
              // use formula from JSEP to convert b=AS to TIAS value.
              bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
                - (50 * 40 * 8);
            } else {
              bandwidth = undefined;
            }
            encodingParameters.forEach((params) => {
              params.maxBitrate = bandwidth;
            });
          }
          return encodingParameters;
        };

        // parses http://draft.ortc.org/#rtcrtcpparameters*
        SDPUtils.parseRtcpParameters = function (mediaSection) {
          const rtcpParameters = {};

          // Gets the first SSRC. Note tha with RTX there might be multiple
          // SSRCs.
          const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
            .map(line => SDPUtils.parseSsrcMedia(line))
            .filter(obj => obj.attribute === 'cname')[0];
          if (remoteSsrc) {
            rtcpParameters.cname = remoteSsrc.value;
            rtcpParameters.ssrc = remoteSsrc.ssrc;
          }

          // Edge uses the compound attribute instead of reducedSize
          // compound is !reducedSize
          const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
          rtcpParameters.reducedSize = rsize.length > 0;
          rtcpParameters.compound = rsize.length === 0;

          // parses the rtcp-mux attrbute.
          // Note that Edge does not support unmuxed RTCP.
          const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
          rtcpParameters.mux = mux.length > 0;

          return rtcpParameters;
        };

        // parses either a=msid: or a=ssrc:... msid lines and returns
        // the id of the MediaStream and MediaStreamTrack.
        SDPUtils.parseMsid = function (mediaSection) {
          let parts;
          const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
          if (spec.length === 1) {
            parts = spec[0].substr(7).split(' ');
            return { stream: parts[0], track: parts[1] };
          }
          const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
            .map(line => SDPUtils.parseSsrcMedia(line))
            .filter(msidParts => msidParts.attribute === 'msid');
          if (planB.length > 0) {
            parts = planB[0].value.split(' ');
            return { stream: parts[0], track: parts[1] };
          }
        };

        // Generate a session ID for SDP.
        // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
        // recommends using a cryptographically random +ve 64-bit value
        // but right now this should be acceptable and within the right range
        SDPUtils.generateSessionId = function () {
          return Math.random().toString().substr(2, 21);
        };

        // Write boilder plate for start of SDP
        // sessId argument is optional - if not supplied it will
        // be generated randomly
        // sessVersion is optional and defaults to 2
        // sessUser is optional and defaults to 'thisisadapterortc'
        SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
          let sessionId;
          const version = sessVer !== undefined ? sessVer : 2;
          if (sessId) {
            sessionId = sessId;
          } else {
            sessionId = SDPUtils.generateSessionId();
          }
          const user = sessUser || 'thisisadapterortc';
          // FIXME: sess-id should be an NTP timestamp.
          return `${'v=0\r\n' +
            'o='}${user} ${sessionId} ${version
            } IN IP4 127.0.0.1\r\n` +
            's=-\r\n' +
            't=0 0\r\n';
        };

        SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
          let sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

          // Map ICE parameters (ufrag, pwd) to SDP.
          sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters());

          // Map DTLS parameters to SDP.
          sdp += SDPUtils.writeDtlsParameters(
            transceiver.dtlsTransport.getLocalParameters(),
            type === 'offer' ? 'actpass' : 'active',
          );

          sdp += `a=mid:${transceiver.mid}\r\n`;

          if (transceiver.direction) {
            sdp += `a=${transceiver.direction}\r\n`;
          } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
            sdp += 'a=sendrecv\r\n';
          } else if (transceiver.rtpSender) {
            sdp += 'a=sendonly\r\n';
          } else if (transceiver.rtpReceiver) {
            sdp += 'a=recvonly\r\n';
          } else {
            sdp += 'a=inactive\r\n';
          }

          if (transceiver.rtpSender) {
            // spec.
            const msid = `msid:${stream.id} ${transceiver.rtpSender.track.id}\r\n`;
            sdp += `a=${msid}`;

            // for Chrome.
            sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc
              } ${msid}`;
            if (transceiver.sendEncodingParameters[0].rtx) {
              sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc
                } ${msid}`;
              sdp += `a=ssrc-group:FID ${transceiver.sendEncodingParameters[0].ssrc} ${transceiver.sendEncodingParameters[0].rtx.ssrc
                }\r\n`;
            }
          }
          // FIXME: this should be written by writeRtpDescription.
          sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc
            } cname:${SDPUtils.localCName}\r\n`;
          if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
            sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc
              } cname:${SDPUtils.localCName}\r\n`;
          }
          return sdp;
        };

        // Gets the direction from the mediaSection or the sessionpart.
        SDPUtils.getDirection = function (mediaSection, sessionpart) {
          // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
          const lines = SDPUtils.splitLines(mediaSection);
          for (let i = 0; i < lines.length; i++) {
            switch (lines[i]) {
              case 'a=sendrecv':
              case 'a=sendonly':
              case 'a=recvonly':
              case 'a=inactive':
                return lines[i].substr(2);
              default:
              // FIXME: What should happen here?
            }
          }
          if (sessionpart) {
            return SDPUtils.getDirection(sessionpart);
          }
          return 'sendrecv';
        };

        SDPUtils.getKind = function (mediaSection) {
          const lines = SDPUtils.splitLines(mediaSection);
          const mline = lines[0].split(' ');
          return mline[0].substr(2);
        };

        SDPUtils.isRejected = function (mediaSection) {
          return mediaSection.split(' ', 2)[1] === '0';
        };

        SDPUtils.parseMLine = function (mediaSection) {
          const lines = SDPUtils.splitLines(mediaSection);
          const parts = lines[0].substr(2).split(' ');
          return {
            kind: parts[0],
            port: parseInt(parts[1], 10),
            protocol: parts[2],
            fmt: parts.slice(3).join(' '),
          };
        };

        SDPUtils.parseOLine = function (mediaSection) {
          const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
          const parts = line.substr(2).split(' ');
          return {
            username: parts[0],
            sessionId: parts[1],
            sessionVersion: parseInt(parts[2], 10),
            netType: parts[3],
            addressType: parts[4],
            address: parts[5],
          };
        };

        // a very naive interpretation of a valid SDP.
        SDPUtils.isValidSDP = function (blob) {
          if (typeof blob !== 'string' || blob.length === 0) {
            return false;
          }
          const lines = SDPUtils.splitLines(blob);
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
              return false;
            }
            // TODO: check the modifier a bit more.
          }
          return true;
        };

        // Expose public methods.
        if (typeof module === 'object') {
          module.exports = SDPUtils;
        }
      }, {}],
    }, {}, [1])(1);
}));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(83)(__webpack_require__(84))

/***/ }),
/* 83 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = "/* globals $$, jQuery, Elements, document, window, L */\n\n/**\n* Copyright 2013 Marc J. Schmidt. See the LICENSE file at the top-level\n* directory of this distribution and at\n* https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n*/\nthis.L = this.L || {};\n\n/**\n * @param {HTMLElement} element\n * @param {String}      prop\n * @returns {String|Number}\n */\nL.GetComputedStyle = (computedElement, prop) => {\n  if (computedElement.currentStyle) {\n    return computedElement.currentStyle[prop];\n  } else if (window.getComputedStyle) {\n    return window.getComputedStyle(computedElement, null).getPropertyValue(prop);\n  }\n  return computedElement.style[prop];\n};\n\n/**\n *\n * @type {Function}\n * @constructor\n */\nL.ElementQueries = function ElementQueries() {\n  /**\n   *\n   * @param element\n   * @returns {Number}\n   */\n  function getEmSize(element = document.documentElement) {\n    const fontSize = L.GetComputedStyle(element, 'fontSize');\n    return parseFloat(fontSize) || 16;\n  }\n\n  /**\n   *\n   * @copyright https://github.com/Mr0grog/element-query/blob/master/LICENSE\n   *\n   * @param element\n   * @param value\n   * @param units\n   * @returns {*}\n   */\n  function convertToPx(element, originalValue) {\n    let vh;\n    let vw;\n    let chooser;\n    const units = originalValue.replace(/[0-9]*/, '');\n    const value = parseFloat(originalValue);\n    switch (units) {\n      case 'px':\n        return value;\n      case 'em':\n        return value * getEmSize(element);\n      case 'rem':\n        return value * getEmSize();\n      // Viewport units!\n      // According to http://quirksmode.org/mobile/tableViewport.html\n      // documentElement.clientWidth/Height gets us the most reliable info\n      case 'vw':\n        return (value * document.documentElement.clientWidth) / 100;\n      case 'vh':\n        return (value * document.documentElement.clientHeight) / 100;\n      case 'vmin':\n      case 'vmax':\n        vw = document.documentElement.clientWidth / 100;\n        vh = document.documentElement.clientHeight / 100;\n        chooser = Math[units === 'vmin' ? 'min' : 'max'];\n        return value * chooser(vw, vh);\n      default:\n        return value;\n      // for now, not supporting physical units (since they are just a set number of px)\n      // or ex/ch (getting accurate measurements is hard)\n    }\n  }\n\n  /**\n   *\n   * @param {HTMLElement} element\n   * @constructor\n   */\n  function SetupInformation(element) {\n    this.element = element;\n    this.options = [];\n    let i;\n    let j;\n    let option;\n    let width = 0;\n    let height = 0;\n    let value;\n    let actualValue;\n    let attrValues;\n    let attrValue;\n    let attrName;\n\n    /**\n     * @param option {mode: 'min|max', property: 'width|height', value: '123px'}\n     */\n    this.addOption = (newOption) => {\n      this.options.push(newOption);\n    };\n\n    const attributes = ['min-width', 'min-height', 'max-width', 'max-height'];\n\n    /**\n     * Extracts the computed width/height and sets to min/max- attribute.\n     */\n    this.call = () => {\n      // extract current dimensions\n      width = this.element.offsetWidth;\n      height = this.element.offsetHeight;\n\n      attrValues = {};\n\n      for (i = 0, j = this.options.length; i < j; i += 1) {\n        option = this.options[i];\n        value = convertToPx(this.element, option.value);\n\n        actualValue = option.property === 'width' ? width : height;\n        attrName = `${option.mode}-${option.property}`;\n        attrValue = '';\n\n        if (option.mode === 'min' && actualValue >= value) {\n          attrValue += option.value;\n        }\n\n        if (option.mode === 'max' && actualValue <= value) {\n          attrValue += option.value;\n        }\n\n        if (!attrValues[attrName]) attrValues[attrName] = '';\n        if (attrValue && (` ${attrValues[attrName]} `)\n          .indexOf(` ${attrValue} `) === -1) {\n          attrValues[attrName] += ` ${attrValue}`;\n        }\n      }\n\n      for (let k = 0; k < attributes.length; k += 1) {\n        if (attrValues[attributes[k]]) {\n          this.element.setAttribute(\n            attributes[k],\n            attrValues[attributes[k]].substr(1),\n          );\n        } else {\n          this.element.removeAttribute(attributes[k]);\n        }\n      }\n    };\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object}      options\n   */\n  function setupElement(originalElement, options) {\n    const element = originalElement;\n    if (element.elementQueriesSetupInformation) {\n      element.elementQueriesSetupInformation.addOption(options);\n    } else {\n      element.elementQueriesSetupInformation = new SetupInformation(element);\n      element.elementQueriesSetupInformation.addOption(options);\n      element.sensor = new L.ResizeSensor(element, () => {\n        element.elementQueriesSetupInformation.call();\n      });\n    }\n    element.elementQueriesSetupInformation.call();\n    return element;\n  }\n\n  /**\n   * @param {String} selector\n   * @param {String} mode min|max\n   * @param {String} property width|height\n   * @param {String} value\n   */\n  function queueQuery(selector, mode, property, value) {\n    let query;\n    if (document.querySelectorAll) query = document.querySelectorAll.bind(document);\n    if (!query && typeof $$ !== 'undefined') query = $$;\n    if (!query && typeof jQuery !== 'undefined') query = jQuery;\n\n    if (!query) {\n      throw new Error('No document.querySelectorAll, jQuery or Mootools\\'s $$ found.');\n    }\n\n    const elements = query(selector) || [];\n    for (let i = 0, j = elements.length; i < j; i += 1) {\n      elements[i] = setupElement(elements[i], {\n        mode,\n        property,\n        value,\n      });\n    }\n  }\n\n  const regex = /,?([^,\\n]*)\\[[\\s\\t]*(min|max)-(width|height)[\\s\\t]*[~$^]?=[\\s\\t]*\"([^\"]*)\"[\\s\\t]*]([^\\n\\s{]*)/mgi; // jshint ignore:line\n\n  /**\n   * @param {String} css\n   */\n  function extractQuery(originalCss) {\n    let match;\n    const css = originalCss.replace(/'/g, '\"');\n    while ((match = regex.exec(css)) !== null) {\n      if (match.length > 5) {\n        queueQuery(match[1] || match[5], match[2], match[3], match[4]);\n      }\n    }\n  }\n\n  /**\n   * @param {CssRule[]|String} rules\n   */\n  function readRules(originalRules) {\n    if (!originalRules) {\n      return;\n    }\n    let selector = '';\n    let rules = originalRules;\n    if (typeof originalRules === 'string') {\n      rules = originalRules.toLowerCase();\n      if (rules.indexOf('min-width') !== -1 || rules.indexOf('max-width') !== -1) {\n        extractQuery(rules);\n      }\n    } else {\n      for (let i = 0, j = rules.length; i < j; i += 1) {\n        if (rules[i].type === 1) {\n          selector = rules[i].selectorText || rules[i].cssText;\n          if (selector.indexOf('min-height') !== -1 ||\n            selector.indexOf('max-height') !== -1) {\n            extractQuery(selector);\n          } else if (selector.indexOf('min-width') !== -1 ||\n            selector.indexOf('max-width') !== -1) {\n            extractQuery(selector);\n          }\n        } else if (rules[i].type === 4) {\n          readRules(rules[i].cssRules || rules[i].rules);\n        }\n      }\n    }\n  }\n\n  /**\n   * Searches all css rules and setups the event listener\n   * to all elements with element query rules..\n   */\n  this.init = () => {\n    const styleSheets = document.styleSheets || [];\n    for (let i = 0, j = styleSheets.length; i < j; i += 1) {\n      readRules(styleSheets[i].cssText ||\n        styleSheets[i].cssRules ||\n        styleSheets[i].rules);\n    }\n  };\n};\n\nfunction init() {\n  (new L.ElementQueries()).init();\n}\n\nif (window.addEventListener) {\n  window.addEventListener('load', init, false);\n} else {\n  window.attachEvent('onload', init);\n}\n\n/**\n * Iterate over each of the provided element(s).\n *\n * @param {HTMLElement|HTMLElement[]} elements\n * @param {Function}                  callback\n */\nfunction forEachElement(elements, callback = () => { }) {\n  const elementsType = Object.prototype.toString.call(elements);\n  const isCollectionTyped = (elementsType === '[object Array]' ||\n    (elementsType === '[object NodeList]') ||\n    (elementsType === '[object HTMLCollection]') ||\n    (typeof jQuery !== 'undefined' && elements instanceof jQuery) || // jquery\n    (typeof Elements !== 'undefined' && elements instanceof Elements) // mootools\n  );\n  let i = 0;\n  const j = elements.length;\n  if (isCollectionTyped) {\n    for (; i < j; i += 1) {\n      callback(elements[i]);\n    }\n  } else {\n    callback(elements);\n  }\n}\n/**\n * Class for dimension change detection.\n *\n * @param {Element|Element[]|Elements|jQuery} element\n * @param {Function} callback\n *\n * @constructor\n */\nL.ResizeSensor = function ResizeSensor(element, callback = () => { }) {\n  /**\n   *\n   * @constructor\n   */\n  function EventQueue() {\n    let q = [];\n    this.add = (ev) => {\n      q.push(ev);\n    };\n\n    let i;\n    let j;\n    this.call = () => {\n      for (i = 0, j = q.length; i < j; i += 1) {\n        q[i].call();\n      }\n    };\n\n    this.remove = (ev) => {\n      const newQueue = [];\n      for (i = 0, j = q.length; i < j; i += 1) {\n        if (q[i] !== ev) newQueue.push(q[i]);\n      }\n      q = newQueue;\n    };\n\n    this.length = () => q.length;\n  }\n\n  /**\n   *\n   * @param {HTMLElement} element\n   * @param {Function}    resized\n   */\n  function attachResizeEvent(htmlElement, resized) {\n    // Only used for the dirty checking, so the event callback count is limted\n    //  to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time,\n    // because the sensor is too fast and\n    // would generate too many unnecessary events.\n    const customRequestAnimationFrame = window.requestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      function delay(fn) {\n        return window.setTimeout(fn, 20);\n      };\n\n    const newElement = htmlElement;\n    if (!newElement.resizedAttached) {\n      newElement.resizedAttached = new EventQueue();\n      newElement.resizedAttached.add(resized);\n    } else if (newElement.resizedAttached) {\n      newElement.resizedAttached.add(resized);\n      return;\n    }\n\n    newElement.resizeSensor = document.createElement('div');\n    newElement.resizeSensor.className = 'resize-sensor';\n    const style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; ' +\n      'overflow: hidden; z-index: -1; visibility: hidden;';\n    const styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n    newElement.resizeSensor.style.cssText = style;\n    newElement.resizeSensor.innerHTML =\n      `<div class=\"resize-sensor-expand\" style=\"${style}\">` +\n      `<div style=\"${styleChild}\"></div>` +\n      '</div>' +\n      `<div class=\"resize-sensor-shrink\" style=\"${style}\">` +\n      `<div style=\"${styleChild} width: 200%; height: 200%\"></div>` +\n      '</div>';\n    newElement.appendChild(newElement.resizeSensor);\n\n    if (L.GetComputedStyle(newElement, 'position') === 'static') {\n      newElement.style.position = 'relative';\n    }\n\n    const expand = newElement.resizeSensor.childNodes[0];\n    const expandChild = expand.childNodes[0];\n    const shrink = newElement.resizeSensor.childNodes[1];\n\n    const reset = () => {\n      expandChild.style.width = `${100000}px`;\n      expandChild.style.height = `${100000}px`;\n\n      expand.scrollLeft = 100000;\n      expand.scrollTop = 100000;\n\n      shrink.scrollLeft = 100000;\n      shrink.scrollTop = 100000;\n    };\n\n    reset();\n    let dirty = false;\n\n    const dirtyChecking = () => {\n      if (!newElement.resizedAttached) return;\n\n      if (dirty) {\n        newElement.resizedAttached.call();\n        dirty = false;\n      }\n\n      customRequestAnimationFrame(dirtyChecking);\n    };\n\n    customRequestAnimationFrame(dirtyChecking);\n    let lastWidth;\n    let lastHeight;\n    let cachedWidth;\n    let cachedHeight; // useful to not query offsetWidth twice\n\n    const onScroll = () => {\n      if ((cachedWidth = newElement.offsetWidth) !== lastWidth ||\n        (cachedHeight = newElement.offsetHeight) !== lastHeight) {\n        dirty = true;\n\n        lastWidth = cachedWidth;\n        lastHeight = cachedHeight;\n      }\n      reset();\n    };\n\n    const addEvent = (el, name, cb) => {\n      if (el.attachEvent) {\n        el.attachEvent(`on${name}`, cb);\n      } else {\n        el.addEventListener(name, cb);\n      }\n    };\n\n    addEvent(expand, 'scroll', onScroll);\n    addEvent(shrink, 'scroll', onScroll);\n  }\n\n  forEachElement(element, (elem) => {\n    attachResizeEvent(elem, callback);\n  });\n\n  this.detach = (ev) => {\n    L.ResizeSensor.detach(element, ev);\n  };\n};\n\nL.ResizeSensor.detach = (element, ev) => {\n  forEachElement(element, (elem) => {\n    const elementItem = elem;\n    if (elementItem.resizedAttached && typeof ev === 'function') {\n      elementItem.resizedAttached.remove(ev);\n      if (elementItem.resizedAttached.length()) return;\n    }\n    if (elementItem.resizeSensor) {\n      if (elementItem.contains(elementItem.resizeSensor)) {\n        elementItem.removeChild(elementItem.resizeSensor);\n      }\n      delete elementItem.resizeSensor;\n      delete elementItem.resizedAttached;\n    }\n  });\n};\n"

/***/ })
/******/ ])["default"];
//# sourceMappingURL=EnxRtc.js.map
